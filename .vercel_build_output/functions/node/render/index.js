var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[Object.keys(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[Object.keys(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};

// node_modules/@sveltejs/kit/dist/install-fetch.js
function dataUriToBuffer(uri) {
  if (!/^data:/i.test(uri)) {
    throw new TypeError('`uri` does not appear to be a Data URI (must begin with "data:")');
  }
  uri = uri.replace(/\r?\n/g, "");
  const firstComma = uri.indexOf(",");
  if (firstComma === -1 || firstComma <= 4) {
    throw new TypeError("malformed data: URI");
  }
  const meta = uri.substring(5, firstComma).split(";");
  let charset = "";
  let base64 = false;
  const type = meta[0] || "text/plain";
  let typeFull = type;
  for (let i = 1; i < meta.length; i++) {
    if (meta[i] === "base64") {
      base64 = true;
    } else {
      typeFull += `;${meta[i]}`;
      if (meta[i].indexOf("charset=") === 0) {
        charset = meta[i].substring(8);
      }
    }
  }
  if (!meta[0] && !charset.length) {
    typeFull += ";charset=US-ASCII";
    charset = "US-ASCII";
  }
  const encoding = base64 ? "base64" : "ascii";
  const data2 = unescape(uri.substring(firstComma + 1));
  const buffer = Buffer.from(data2, encoding);
  buffer.type = type;
  buffer.typeFull = typeFull;
  buffer.charset = charset;
  return buffer;
}
async function* toIterator(parts, clone2 = true) {
  for (let part of parts) {
    if ("stream" in part) {
      yield* part.stream();
    } else if (ArrayBuffer.isView(part)) {
      if (clone2) {
        let position = part.byteOffset;
        let end = part.byteOffset + part.byteLength;
        while (position !== end) {
          const size = Math.min(end - position, POOL_SIZE);
          const chunk = part.buffer.slice(position, position + size);
          position += chunk.byteLength;
          yield new Uint8Array(chunk);
        }
      } else {
        yield part;
      }
    } else {
      let position = 0;
      while (position !== part.size) {
        const chunk = part.slice(position, Math.min(part.size, position + POOL_SIZE));
        const buffer = await chunk.arrayBuffer();
        position += buffer.byteLength;
        yield new Uint8Array(buffer);
      }
    }
  }
}
function isFormData(object) {
  return typeof object === "object" && typeof object.append === "function" && typeof object.set === "function" && typeof object.get === "function" && typeof object.getAll === "function" && typeof object.delete === "function" && typeof object.keys === "function" && typeof object.values === "function" && typeof object.entries === "function" && typeof object.constructor === "function" && object[NAME] === "FormData";
}
function getHeader(boundary, name, field) {
  let header = "";
  header += `${dashes}${boundary}${carriage}`;
  header += `Content-Disposition: form-data; name="${name}"`;
  if (isBlob(field)) {
    header += `; filename="${field.name}"${carriage}`;
    header += `Content-Type: ${field.type || "application/octet-stream"}`;
  }
  return `${header}${carriage.repeat(2)}`;
}
async function* formDataIterator(form, boundary) {
  for (const [name, value] of form) {
    yield getHeader(boundary, name, value);
    if (isBlob(value)) {
      yield* value.stream();
    } else {
      yield value;
    }
    yield carriage;
  }
  yield getFooter(boundary);
}
function getFormDataLength(form, boundary) {
  let length = 0;
  for (const [name, value] of form) {
    length += Buffer.byteLength(getHeader(boundary, name, value));
    length += isBlob(value) ? value.size : Buffer.byteLength(String(value));
    length += carriageLength;
  }
  length += Buffer.byteLength(getFooter(boundary));
  return length;
}
async function consumeBody(data2) {
  if (data2[INTERNALS$2].disturbed) {
    throw new TypeError(`body used already for: ${data2.url}`);
  }
  data2[INTERNALS$2].disturbed = true;
  if (data2[INTERNALS$2].error) {
    throw data2[INTERNALS$2].error;
  }
  let { body } = data2;
  if (body === null) {
    return Buffer.alloc(0);
  }
  if (isBlob(body)) {
    body = import_stream.default.Readable.from(body.stream());
  }
  if (Buffer.isBuffer(body)) {
    return body;
  }
  if (!(body instanceof import_stream.default)) {
    return Buffer.alloc(0);
  }
  const accum = [];
  let accumBytes = 0;
  try {
    for await (const chunk of body) {
      if (data2.size > 0 && accumBytes + chunk.length > data2.size) {
        const error2 = new FetchError(`content size at ${data2.url} over limit: ${data2.size}`, "max-size");
        body.destroy(error2);
        throw error2;
      }
      accumBytes += chunk.length;
      accum.push(chunk);
    }
  } catch (error2) {
    const error_ = error2 instanceof FetchBaseError ? error2 : new FetchError(`Invalid response body while trying to fetch ${data2.url}: ${error2.message}`, "system", error2);
    throw error_;
  }
  if (body.readableEnded === true || body._readableState.ended === true) {
    try {
      if (accum.every((c) => typeof c === "string")) {
        return Buffer.from(accum.join(""));
      }
      return Buffer.concat(accum, accumBytes);
    } catch (error2) {
      throw new FetchError(`Could not create Buffer from response body for ${data2.url}: ${error2.message}`, "system", error2);
    }
  } else {
    throw new FetchError(`Premature close of server response while trying to fetch ${data2.url}`);
  }
}
function fromRawHeaders(headers = []) {
  return new Headers(headers.reduce((result, value, index2, array) => {
    if (index2 % 2 === 0) {
      result.push(array.slice(index2, index2 + 2));
    }
    return result;
  }, []).filter(([name, value]) => {
    try {
      validateHeaderName(name);
      validateHeaderValue(name, String(value));
      return true;
    } catch {
      return false;
    }
  }));
}
async function fetch(url, options_) {
  return new Promise((resolve2, reject) => {
    const request = new Request(url, options_);
    const options2 = getNodeRequestOptions(request);
    if (!supportedSchemas.has(options2.protocol)) {
      throw new TypeError(`node-fetch cannot load ${url}. URL scheme "${options2.protocol.replace(/:$/, "")}" is not supported.`);
    }
    if (options2.protocol === "data:") {
      const data2 = dataUriToBuffer$1(request.url);
      const response2 = new Response(data2, { headers: { "Content-Type": data2.typeFull } });
      resolve2(response2);
      return;
    }
    const send = (options2.protocol === "https:" ? import_https.default : import_http.default).request;
    const { signal } = request;
    let response = null;
    const abort = () => {
      const error2 = new AbortError("The operation was aborted.");
      reject(error2);
      if (request.body && request.body instanceof import_stream.default.Readable) {
        request.body.destroy(error2);
      }
      if (!response || !response.body) {
        return;
      }
      response.body.emit("error", error2);
    };
    if (signal && signal.aborted) {
      abort();
      return;
    }
    const abortAndFinalize = () => {
      abort();
      finalize();
    };
    const request_ = send(options2);
    if (signal) {
      signal.addEventListener("abort", abortAndFinalize);
    }
    const finalize = () => {
      request_.abort();
      if (signal) {
        signal.removeEventListener("abort", abortAndFinalize);
      }
    };
    request_.on("error", (error2) => {
      reject(new FetchError(`request to ${request.url} failed, reason: ${error2.message}`, "system", error2));
      finalize();
    });
    fixResponseChunkedTransferBadEnding(request_, (error2) => {
      response.body.destroy(error2);
    });
    if (process.version < "v14") {
      request_.on("socket", (s2) => {
        let endedWithEventsCount;
        s2.prependListener("end", () => {
          endedWithEventsCount = s2._eventsCount;
        });
        s2.prependListener("close", (hadError) => {
          if (response && endedWithEventsCount < s2._eventsCount && !hadError) {
            const error2 = new Error("Premature close");
            error2.code = "ERR_STREAM_PREMATURE_CLOSE";
            response.body.emit("error", error2);
          }
        });
      });
    }
    request_.on("response", (response_) => {
      request_.setTimeout(0);
      const headers = fromRawHeaders(response_.rawHeaders);
      if (isRedirect(response_.statusCode)) {
        const location = headers.get("Location");
        const locationURL = location === null ? null : new URL(location, request.url);
        switch (request.redirect) {
          case "error":
            reject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, "no-redirect"));
            finalize();
            return;
          case "manual":
            if (locationURL !== null) {
              headers.set("Location", locationURL);
            }
            break;
          case "follow": {
            if (locationURL === null) {
              break;
            }
            if (request.counter >= request.follow) {
              reject(new FetchError(`maximum redirect reached at: ${request.url}`, "max-redirect"));
              finalize();
              return;
            }
            const requestOptions = {
              headers: new Headers(request.headers),
              follow: request.follow,
              counter: request.counter + 1,
              agent: request.agent,
              compress: request.compress,
              method: request.method,
              body: request.body,
              signal: request.signal,
              size: request.size
            };
            if (response_.statusCode !== 303 && request.body && options_.body instanceof import_stream.default.Readable) {
              reject(new FetchError("Cannot follow redirect with body being a readable stream", "unsupported-redirect"));
              finalize();
              return;
            }
            if (response_.statusCode === 303 || (response_.statusCode === 301 || response_.statusCode === 302) && request.method === "POST") {
              requestOptions.method = "GET";
              requestOptions.body = void 0;
              requestOptions.headers.delete("content-length");
            }
            resolve2(fetch(new Request(locationURL, requestOptions)));
            finalize();
            return;
          }
          default:
            return reject(new TypeError(`Redirect option '${request.redirect}' is not a valid value of RequestRedirect`));
        }
      }
      if (signal) {
        response_.once("end", () => {
          signal.removeEventListener("abort", abortAndFinalize);
        });
      }
      let body = (0, import_stream.pipeline)(response_, new import_stream.PassThrough(), reject);
      if (process.version < "v12.10") {
        response_.on("aborted", abortAndFinalize);
      }
      const responseOptions = {
        url: request.url,
        status: response_.statusCode,
        statusText: response_.statusMessage,
        headers,
        size: request.size,
        counter: request.counter,
        highWaterMark: request.highWaterMark
      };
      const codings = headers.get("Content-Encoding");
      if (!request.compress || request.method === "HEAD" || codings === null || response_.statusCode === 204 || response_.statusCode === 304) {
        response = new Response(body, responseOptions);
        resolve2(response);
        return;
      }
      const zlibOptions = {
        flush: import_zlib.default.Z_SYNC_FLUSH,
        finishFlush: import_zlib.default.Z_SYNC_FLUSH
      };
      if (codings === "gzip" || codings === "x-gzip") {
        body = (0, import_stream.pipeline)(body, import_zlib.default.createGunzip(zlibOptions), reject);
        response = new Response(body, responseOptions);
        resolve2(response);
        return;
      }
      if (codings === "deflate" || codings === "x-deflate") {
        const raw = (0, import_stream.pipeline)(response_, new import_stream.PassThrough(), reject);
        raw.once("data", (chunk) => {
          body = (chunk[0] & 15) === 8 ? (0, import_stream.pipeline)(body, import_zlib.default.createInflate(), reject) : (0, import_stream.pipeline)(body, import_zlib.default.createInflateRaw(), reject);
          response = new Response(body, responseOptions);
          resolve2(response);
        });
        return;
      }
      if (codings === "br") {
        body = (0, import_stream.pipeline)(body, import_zlib.default.createBrotliDecompress(), reject);
        response = new Response(body, responseOptions);
        resolve2(response);
        return;
      }
      response = new Response(body, responseOptions);
      resolve2(response);
    });
    writeToStream(request_, request);
  });
}
function fixResponseChunkedTransferBadEnding(request, errorCallback) {
  const LAST_CHUNK = Buffer.from("0\r\n\r\n");
  let isChunkedTransfer = false;
  let properLastChunkReceived = false;
  let previousChunk;
  request.on("response", (response) => {
    const { headers } = response;
    isChunkedTransfer = headers["transfer-encoding"] === "chunked" && !headers["content-length"];
  });
  request.on("socket", (socket) => {
    const onSocketClose = () => {
      if (isChunkedTransfer && !properLastChunkReceived) {
        const error2 = new Error("Premature close");
        error2.code = "ERR_STREAM_PREMATURE_CLOSE";
        errorCallback(error2);
      }
    };
    socket.prependListener("close", onSocketClose);
    request.on("abort", () => {
      socket.removeListener("close", onSocketClose);
    });
    socket.on("data", (buf) => {
      properLastChunkReceived = Buffer.compare(buf.slice(-5), LAST_CHUNK) === 0;
      if (!properLastChunkReceived && previousChunk) {
        properLastChunkReceived = Buffer.compare(previousChunk.slice(-3), LAST_CHUNK.slice(0, 3)) === 0 && Buffer.compare(buf.slice(-2), LAST_CHUNK.slice(3)) === 0;
      }
      previousChunk = buf;
    });
  });
}
var import_http, import_https, import_zlib, import_stream, import_util, import_crypto, import_url, commonjsGlobal, src, dataUriToBuffer$1, ponyfill_es2018, POOL_SIZE$1, POOL_SIZE, _Blob, Blob2, Blob$1, FetchBaseError, FetchError, NAME, isURLSearchParameters, isBlob, isAbortSignal, carriage, dashes, carriageLength, getFooter, getBoundary, INTERNALS$2, Body, clone, extractContentType, getTotalBytes, writeToStream, validateHeaderName, validateHeaderValue, Headers, redirectStatus, isRedirect, INTERNALS$1, Response, getSearch, INTERNALS, isRequest, Request, getNodeRequestOptions, AbortError, supportedSchemas;
var init_install_fetch = __esm({
  "node_modules/@sveltejs/kit/dist/install-fetch.js"() {
    init_shims();
    import_http = __toModule(require("http"));
    import_https = __toModule(require("https"));
    import_zlib = __toModule(require("zlib"));
    import_stream = __toModule(require("stream"));
    import_util = __toModule(require("util"));
    import_crypto = __toModule(require("crypto"));
    import_url = __toModule(require("url"));
    commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
    src = dataUriToBuffer;
    dataUriToBuffer$1 = src;
    ponyfill_es2018 = { exports: {} };
    (function(module2, exports) {
      (function(global2, factory) {
        factory(exports);
      })(commonjsGlobal, function(exports2) {
        const SymbolPolyfill = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? Symbol : (description) => `Symbol(${description})`;
        function noop2() {
          return void 0;
        }
        function getGlobals() {
          if (typeof self !== "undefined") {
            return self;
          } else if (typeof window !== "undefined") {
            return window;
          } else if (typeof commonjsGlobal !== "undefined") {
            return commonjsGlobal;
          }
          return void 0;
        }
        const globals2 = getGlobals();
        function typeIsObject(x) {
          return typeof x === "object" && x !== null || typeof x === "function";
        }
        const rethrowAssertionErrorRejection = noop2;
        const originalPromise = Promise;
        const originalPromiseThen = Promise.prototype.then;
        const originalPromiseResolve = Promise.resolve.bind(originalPromise);
        const originalPromiseReject = Promise.reject.bind(originalPromise);
        function newPromise(executor) {
          return new originalPromise(executor);
        }
        function promiseResolvedWith(value) {
          return originalPromiseResolve(value);
        }
        function promiseRejectedWith(reason) {
          return originalPromiseReject(reason);
        }
        function PerformPromiseThen(promise, onFulfilled, onRejected) {
          return originalPromiseThen.call(promise, onFulfilled, onRejected);
        }
        function uponPromise(promise, onFulfilled, onRejected) {
          PerformPromiseThen(PerformPromiseThen(promise, onFulfilled, onRejected), void 0, rethrowAssertionErrorRejection);
        }
        function uponFulfillment(promise, onFulfilled) {
          uponPromise(promise, onFulfilled);
        }
        function uponRejection(promise, onRejected) {
          uponPromise(promise, void 0, onRejected);
        }
        function transformPromiseWith(promise, fulfillmentHandler, rejectionHandler) {
          return PerformPromiseThen(promise, fulfillmentHandler, rejectionHandler);
        }
        function setPromiseIsHandledToTrue(promise) {
          PerformPromiseThen(promise, void 0, rethrowAssertionErrorRejection);
        }
        const queueMicrotask = (() => {
          const globalQueueMicrotask = globals2 && globals2.queueMicrotask;
          if (typeof globalQueueMicrotask === "function") {
            return globalQueueMicrotask;
          }
          const resolvedPromise = promiseResolvedWith(void 0);
          return (fn) => PerformPromiseThen(resolvedPromise, fn);
        })();
        function reflectCall(F, V, args) {
          if (typeof F !== "function") {
            throw new TypeError("Argument is not a function");
          }
          return Function.prototype.apply.call(F, V, args);
        }
        function promiseCall(F, V, args) {
          try {
            return promiseResolvedWith(reflectCall(F, V, args));
          } catch (value) {
            return promiseRejectedWith(value);
          }
        }
        const QUEUE_MAX_ARRAY_SIZE = 16384;
        class SimpleQueue {
          constructor() {
            this._cursor = 0;
            this._size = 0;
            this._front = {
              _elements: [],
              _next: void 0
            };
            this._back = this._front;
            this._cursor = 0;
            this._size = 0;
          }
          get length() {
            return this._size;
          }
          push(element) {
            const oldBack = this._back;
            let newBack = oldBack;
            if (oldBack._elements.length === QUEUE_MAX_ARRAY_SIZE - 1) {
              newBack = {
                _elements: [],
                _next: void 0
              };
            }
            oldBack._elements.push(element);
            if (newBack !== oldBack) {
              this._back = newBack;
              oldBack._next = newBack;
            }
            ++this._size;
          }
          shift() {
            const oldFront = this._front;
            let newFront = oldFront;
            const oldCursor = this._cursor;
            let newCursor = oldCursor + 1;
            const elements = oldFront._elements;
            const element = elements[oldCursor];
            if (newCursor === QUEUE_MAX_ARRAY_SIZE) {
              newFront = oldFront._next;
              newCursor = 0;
            }
            --this._size;
            this._cursor = newCursor;
            if (oldFront !== newFront) {
              this._front = newFront;
            }
            elements[oldCursor] = void 0;
            return element;
          }
          forEach(callback) {
            let i = this._cursor;
            let node = this._front;
            let elements = node._elements;
            while (i !== elements.length || node._next !== void 0) {
              if (i === elements.length) {
                node = node._next;
                elements = node._elements;
                i = 0;
                if (elements.length === 0) {
                  break;
                }
              }
              callback(elements[i]);
              ++i;
            }
          }
          peek() {
            const front = this._front;
            const cursor = this._cursor;
            return front._elements[cursor];
          }
        }
        function ReadableStreamReaderGenericInitialize(reader, stream) {
          reader._ownerReadableStream = stream;
          stream._reader = reader;
          if (stream._state === "readable") {
            defaultReaderClosedPromiseInitialize(reader);
          } else if (stream._state === "closed") {
            defaultReaderClosedPromiseInitializeAsResolved(reader);
          } else {
            defaultReaderClosedPromiseInitializeAsRejected(reader, stream._storedError);
          }
        }
        function ReadableStreamReaderGenericCancel(reader, reason) {
          const stream = reader._ownerReadableStream;
          return ReadableStreamCancel(stream, reason);
        }
        function ReadableStreamReaderGenericRelease(reader) {
          if (reader._ownerReadableStream._state === "readable") {
            defaultReaderClosedPromiseReject(reader, new TypeError(`Reader was released and can no longer be used to monitor the stream's closedness`));
          } else {
            defaultReaderClosedPromiseResetToRejected(reader, new TypeError(`Reader was released and can no longer be used to monitor the stream's closedness`));
          }
          reader._ownerReadableStream._reader = void 0;
          reader._ownerReadableStream = void 0;
        }
        function readerLockException(name) {
          return new TypeError("Cannot " + name + " a stream using a released reader");
        }
        function defaultReaderClosedPromiseInitialize(reader) {
          reader._closedPromise = newPromise((resolve2, reject) => {
            reader._closedPromise_resolve = resolve2;
            reader._closedPromise_reject = reject;
          });
        }
        function defaultReaderClosedPromiseInitializeAsRejected(reader, reason) {
          defaultReaderClosedPromiseInitialize(reader);
          defaultReaderClosedPromiseReject(reader, reason);
        }
        function defaultReaderClosedPromiseInitializeAsResolved(reader) {
          defaultReaderClosedPromiseInitialize(reader);
          defaultReaderClosedPromiseResolve(reader);
        }
        function defaultReaderClosedPromiseReject(reader, reason) {
          if (reader._closedPromise_reject === void 0) {
            return;
          }
          setPromiseIsHandledToTrue(reader._closedPromise);
          reader._closedPromise_reject(reason);
          reader._closedPromise_resolve = void 0;
          reader._closedPromise_reject = void 0;
        }
        function defaultReaderClosedPromiseResetToRejected(reader, reason) {
          defaultReaderClosedPromiseInitializeAsRejected(reader, reason);
        }
        function defaultReaderClosedPromiseResolve(reader) {
          if (reader._closedPromise_resolve === void 0) {
            return;
          }
          reader._closedPromise_resolve(void 0);
          reader._closedPromise_resolve = void 0;
          reader._closedPromise_reject = void 0;
        }
        const AbortSteps = SymbolPolyfill("[[AbortSteps]]");
        const ErrorSteps = SymbolPolyfill("[[ErrorSteps]]");
        const CancelSteps = SymbolPolyfill("[[CancelSteps]]");
        const PullSteps = SymbolPolyfill("[[PullSteps]]");
        const NumberIsFinite = Number.isFinite || function(x) {
          return typeof x === "number" && isFinite(x);
        };
        const MathTrunc = Math.trunc || function(v) {
          return v < 0 ? Math.ceil(v) : Math.floor(v);
        };
        function isDictionary(x) {
          return typeof x === "object" || typeof x === "function";
        }
        function assertDictionary(obj, context) {
          if (obj !== void 0 && !isDictionary(obj)) {
            throw new TypeError(`${context} is not an object.`);
          }
        }
        function assertFunction(x, context) {
          if (typeof x !== "function") {
            throw new TypeError(`${context} is not a function.`);
          }
        }
        function isObject(x) {
          return typeof x === "object" && x !== null || typeof x === "function";
        }
        function assertObject(x, context) {
          if (!isObject(x)) {
            throw new TypeError(`${context} is not an object.`);
          }
        }
        function assertRequiredArgument(x, position, context) {
          if (x === void 0) {
            throw new TypeError(`Parameter ${position} is required in '${context}'.`);
          }
        }
        function assertRequiredField(x, field, context) {
          if (x === void 0) {
            throw new TypeError(`${field} is required in '${context}'.`);
          }
        }
        function convertUnrestrictedDouble(value) {
          return Number(value);
        }
        function censorNegativeZero(x) {
          return x === 0 ? 0 : x;
        }
        function integerPart(x) {
          return censorNegativeZero(MathTrunc(x));
        }
        function convertUnsignedLongLongWithEnforceRange(value, context) {
          const lowerBound = 0;
          const upperBound = Number.MAX_SAFE_INTEGER;
          let x = Number(value);
          x = censorNegativeZero(x);
          if (!NumberIsFinite(x)) {
            throw new TypeError(`${context} is not a finite number`);
          }
          x = integerPart(x);
          if (x < lowerBound || x > upperBound) {
            throw new TypeError(`${context} is outside the accepted range of ${lowerBound} to ${upperBound}, inclusive`);
          }
          if (!NumberIsFinite(x) || x === 0) {
            return 0;
          }
          return x;
        }
        function assertReadableStream(x, context) {
          if (!IsReadableStream(x)) {
            throw new TypeError(`${context} is not a ReadableStream.`);
          }
        }
        function AcquireReadableStreamDefaultReader(stream) {
          return new ReadableStreamDefaultReader(stream);
        }
        function ReadableStreamAddReadRequest(stream, readRequest) {
          stream._reader._readRequests.push(readRequest);
        }
        function ReadableStreamFulfillReadRequest(stream, chunk, done) {
          const reader = stream._reader;
          const readRequest = reader._readRequests.shift();
          if (done) {
            readRequest._closeSteps();
          } else {
            readRequest._chunkSteps(chunk);
          }
        }
        function ReadableStreamGetNumReadRequests(stream) {
          return stream._reader._readRequests.length;
        }
        function ReadableStreamHasDefaultReader(stream) {
          const reader = stream._reader;
          if (reader === void 0) {
            return false;
          }
          if (!IsReadableStreamDefaultReader(reader)) {
            return false;
          }
          return true;
        }
        class ReadableStreamDefaultReader {
          constructor(stream) {
            assertRequiredArgument(stream, 1, "ReadableStreamDefaultReader");
            assertReadableStream(stream, "First parameter");
            if (IsReadableStreamLocked(stream)) {
              throw new TypeError("This stream has already been locked for exclusive reading by another reader");
            }
            ReadableStreamReaderGenericInitialize(this, stream);
            this._readRequests = new SimpleQueue();
          }
          get closed() {
            if (!IsReadableStreamDefaultReader(this)) {
              return promiseRejectedWith(defaultReaderBrandCheckException("closed"));
            }
            return this._closedPromise;
          }
          cancel(reason = void 0) {
            if (!IsReadableStreamDefaultReader(this)) {
              return promiseRejectedWith(defaultReaderBrandCheckException("cancel"));
            }
            if (this._ownerReadableStream === void 0) {
              return promiseRejectedWith(readerLockException("cancel"));
            }
            return ReadableStreamReaderGenericCancel(this, reason);
          }
          read() {
            if (!IsReadableStreamDefaultReader(this)) {
              return promiseRejectedWith(defaultReaderBrandCheckException("read"));
            }
            if (this._ownerReadableStream === void 0) {
              return promiseRejectedWith(readerLockException("read from"));
            }
            let resolvePromise;
            let rejectPromise;
            const promise = newPromise((resolve2, reject) => {
              resolvePromise = resolve2;
              rejectPromise = reject;
            });
            const readRequest = {
              _chunkSteps: (chunk) => resolvePromise({ value: chunk, done: false }),
              _closeSteps: () => resolvePromise({ value: void 0, done: true }),
              _errorSteps: (e) => rejectPromise(e)
            };
            ReadableStreamDefaultReaderRead(this, readRequest);
            return promise;
          }
          releaseLock() {
            if (!IsReadableStreamDefaultReader(this)) {
              throw defaultReaderBrandCheckException("releaseLock");
            }
            if (this._ownerReadableStream === void 0) {
              return;
            }
            if (this._readRequests.length > 0) {
              throw new TypeError("Tried to release a reader lock when that reader has pending read() calls un-settled");
            }
            ReadableStreamReaderGenericRelease(this);
          }
        }
        Object.defineProperties(ReadableStreamDefaultReader.prototype, {
          cancel: { enumerable: true },
          read: { enumerable: true },
          releaseLock: { enumerable: true },
          closed: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(ReadableStreamDefaultReader.prototype, SymbolPolyfill.toStringTag, {
            value: "ReadableStreamDefaultReader",
            configurable: true
          });
        }
        function IsReadableStreamDefaultReader(x) {
          if (!typeIsObject(x)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x, "_readRequests")) {
            return false;
          }
          return x instanceof ReadableStreamDefaultReader;
        }
        function ReadableStreamDefaultReaderRead(reader, readRequest) {
          const stream = reader._ownerReadableStream;
          stream._disturbed = true;
          if (stream._state === "closed") {
            readRequest._closeSteps();
          } else if (stream._state === "errored") {
            readRequest._errorSteps(stream._storedError);
          } else {
            stream._readableStreamController[PullSteps](readRequest);
          }
        }
        function defaultReaderBrandCheckException(name) {
          return new TypeError(`ReadableStreamDefaultReader.prototype.${name} can only be used on a ReadableStreamDefaultReader`);
        }
        const AsyncIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf(async function* () {
        }).prototype);
        class ReadableStreamAsyncIteratorImpl {
          constructor(reader, preventCancel) {
            this._ongoingPromise = void 0;
            this._isFinished = false;
            this._reader = reader;
            this._preventCancel = preventCancel;
          }
          next() {
            const nextSteps = () => this._nextSteps();
            this._ongoingPromise = this._ongoingPromise ? transformPromiseWith(this._ongoingPromise, nextSteps, nextSteps) : nextSteps();
            return this._ongoingPromise;
          }
          return(value) {
            const returnSteps = () => this._returnSteps(value);
            return this._ongoingPromise ? transformPromiseWith(this._ongoingPromise, returnSteps, returnSteps) : returnSteps();
          }
          _nextSteps() {
            if (this._isFinished) {
              return Promise.resolve({ value: void 0, done: true });
            }
            const reader = this._reader;
            if (reader._ownerReadableStream === void 0) {
              return promiseRejectedWith(readerLockException("iterate"));
            }
            let resolvePromise;
            let rejectPromise;
            const promise = newPromise((resolve2, reject) => {
              resolvePromise = resolve2;
              rejectPromise = reject;
            });
            const readRequest = {
              _chunkSteps: (chunk) => {
                this._ongoingPromise = void 0;
                queueMicrotask(() => resolvePromise({ value: chunk, done: false }));
              },
              _closeSteps: () => {
                this._ongoingPromise = void 0;
                this._isFinished = true;
                ReadableStreamReaderGenericRelease(reader);
                resolvePromise({ value: void 0, done: true });
              },
              _errorSteps: (reason) => {
                this._ongoingPromise = void 0;
                this._isFinished = true;
                ReadableStreamReaderGenericRelease(reader);
                rejectPromise(reason);
              }
            };
            ReadableStreamDefaultReaderRead(reader, readRequest);
            return promise;
          }
          _returnSteps(value) {
            if (this._isFinished) {
              return Promise.resolve({ value, done: true });
            }
            this._isFinished = true;
            const reader = this._reader;
            if (reader._ownerReadableStream === void 0) {
              return promiseRejectedWith(readerLockException("finish iterating"));
            }
            if (!this._preventCancel) {
              const result = ReadableStreamReaderGenericCancel(reader, value);
              ReadableStreamReaderGenericRelease(reader);
              return transformPromiseWith(result, () => ({ value, done: true }));
            }
            ReadableStreamReaderGenericRelease(reader);
            return promiseResolvedWith({ value, done: true });
          }
        }
        const ReadableStreamAsyncIteratorPrototype = {
          next() {
            if (!IsReadableStreamAsyncIterator(this)) {
              return promiseRejectedWith(streamAsyncIteratorBrandCheckException("next"));
            }
            return this._asyncIteratorImpl.next();
          },
          return(value) {
            if (!IsReadableStreamAsyncIterator(this)) {
              return promiseRejectedWith(streamAsyncIteratorBrandCheckException("return"));
            }
            return this._asyncIteratorImpl.return(value);
          }
        };
        if (AsyncIteratorPrototype !== void 0) {
          Object.setPrototypeOf(ReadableStreamAsyncIteratorPrototype, AsyncIteratorPrototype);
        }
        function AcquireReadableStreamAsyncIterator(stream, preventCancel) {
          const reader = AcquireReadableStreamDefaultReader(stream);
          const impl = new ReadableStreamAsyncIteratorImpl(reader, preventCancel);
          const iterator = Object.create(ReadableStreamAsyncIteratorPrototype);
          iterator._asyncIteratorImpl = impl;
          return iterator;
        }
        function IsReadableStreamAsyncIterator(x) {
          if (!typeIsObject(x)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x, "_asyncIteratorImpl")) {
            return false;
          }
          try {
            return x._asyncIteratorImpl instanceof ReadableStreamAsyncIteratorImpl;
          } catch (_a) {
            return false;
          }
        }
        function streamAsyncIteratorBrandCheckException(name) {
          return new TypeError(`ReadableStreamAsyncIterator.${name} can only be used on a ReadableSteamAsyncIterator`);
        }
        const NumberIsNaN = Number.isNaN || function(x) {
          return x !== x;
        };
        function CreateArrayFromList(elements) {
          return elements.slice();
        }
        function CopyDataBlockBytes(dest, destOffset, src2, srcOffset, n) {
          new Uint8Array(dest).set(new Uint8Array(src2, srcOffset, n), destOffset);
        }
        function TransferArrayBuffer(O) {
          return O;
        }
        function IsDetachedBuffer(O) {
          return false;
        }
        function ArrayBufferSlice(buffer, begin, end) {
          if (buffer.slice) {
            return buffer.slice(begin, end);
          }
          const length = end - begin;
          const slice = new ArrayBuffer(length);
          CopyDataBlockBytes(slice, 0, buffer, begin, length);
          return slice;
        }
        function IsNonNegativeNumber(v) {
          if (typeof v !== "number") {
            return false;
          }
          if (NumberIsNaN(v)) {
            return false;
          }
          if (v < 0) {
            return false;
          }
          return true;
        }
        function CloneAsUint8Array(O) {
          const buffer = ArrayBufferSlice(O.buffer, O.byteOffset, O.byteOffset + O.byteLength);
          return new Uint8Array(buffer);
        }
        function DequeueValue(container) {
          const pair = container._queue.shift();
          container._queueTotalSize -= pair.size;
          if (container._queueTotalSize < 0) {
            container._queueTotalSize = 0;
          }
          return pair.value;
        }
        function EnqueueValueWithSize(container, value, size) {
          if (!IsNonNegativeNumber(size) || size === Infinity) {
            throw new RangeError("Size must be a finite, non-NaN, non-negative number.");
          }
          container._queue.push({ value, size });
          container._queueTotalSize += size;
        }
        function PeekQueueValue(container) {
          const pair = container._queue.peek();
          return pair.value;
        }
        function ResetQueue(container) {
          container._queue = new SimpleQueue();
          container._queueTotalSize = 0;
        }
        class ReadableStreamBYOBRequest {
          constructor() {
            throw new TypeError("Illegal constructor");
          }
          get view() {
            if (!IsReadableStreamBYOBRequest(this)) {
              throw byobRequestBrandCheckException("view");
            }
            return this._view;
          }
          respond(bytesWritten) {
            if (!IsReadableStreamBYOBRequest(this)) {
              throw byobRequestBrandCheckException("respond");
            }
            assertRequiredArgument(bytesWritten, 1, "respond");
            bytesWritten = convertUnsignedLongLongWithEnforceRange(bytesWritten, "First parameter");
            if (this._associatedReadableByteStreamController === void 0) {
              throw new TypeError("This BYOB request has been invalidated");
            }
            if (IsDetachedBuffer(this._view.buffer))
              ;
            ReadableByteStreamControllerRespond(this._associatedReadableByteStreamController, bytesWritten);
          }
          respondWithNewView(view) {
            if (!IsReadableStreamBYOBRequest(this)) {
              throw byobRequestBrandCheckException("respondWithNewView");
            }
            assertRequiredArgument(view, 1, "respondWithNewView");
            if (!ArrayBuffer.isView(view)) {
              throw new TypeError("You can only respond with array buffer views");
            }
            if (this._associatedReadableByteStreamController === void 0) {
              throw new TypeError("This BYOB request has been invalidated");
            }
            if (IsDetachedBuffer(view.buffer))
              ;
            ReadableByteStreamControllerRespondWithNewView(this._associatedReadableByteStreamController, view);
          }
        }
        Object.defineProperties(ReadableStreamBYOBRequest.prototype, {
          respond: { enumerable: true },
          respondWithNewView: { enumerable: true },
          view: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(ReadableStreamBYOBRequest.prototype, SymbolPolyfill.toStringTag, {
            value: "ReadableStreamBYOBRequest",
            configurable: true
          });
        }
        class ReadableByteStreamController {
          constructor() {
            throw new TypeError("Illegal constructor");
          }
          get byobRequest() {
            if (!IsReadableByteStreamController(this)) {
              throw byteStreamControllerBrandCheckException("byobRequest");
            }
            return ReadableByteStreamControllerGetBYOBRequest(this);
          }
          get desiredSize() {
            if (!IsReadableByteStreamController(this)) {
              throw byteStreamControllerBrandCheckException("desiredSize");
            }
            return ReadableByteStreamControllerGetDesiredSize(this);
          }
          close() {
            if (!IsReadableByteStreamController(this)) {
              throw byteStreamControllerBrandCheckException("close");
            }
            if (this._closeRequested) {
              throw new TypeError("The stream has already been closed; do not close it again!");
            }
            const state = this._controlledReadableByteStream._state;
            if (state !== "readable") {
              throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be closed`);
            }
            ReadableByteStreamControllerClose(this);
          }
          enqueue(chunk) {
            if (!IsReadableByteStreamController(this)) {
              throw byteStreamControllerBrandCheckException("enqueue");
            }
            assertRequiredArgument(chunk, 1, "enqueue");
            if (!ArrayBuffer.isView(chunk)) {
              throw new TypeError("chunk must be an array buffer view");
            }
            if (chunk.byteLength === 0) {
              throw new TypeError("chunk must have non-zero byteLength");
            }
            if (chunk.buffer.byteLength === 0) {
              throw new TypeError(`chunk's buffer must have non-zero byteLength`);
            }
            if (this._closeRequested) {
              throw new TypeError("stream is closed or draining");
            }
            const state = this._controlledReadableByteStream._state;
            if (state !== "readable") {
              throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be enqueued to`);
            }
            ReadableByteStreamControllerEnqueue(this, chunk);
          }
          error(e = void 0) {
            if (!IsReadableByteStreamController(this)) {
              throw byteStreamControllerBrandCheckException("error");
            }
            ReadableByteStreamControllerError(this, e);
          }
          [CancelSteps](reason) {
            ReadableByteStreamControllerClearPendingPullIntos(this);
            ResetQueue(this);
            const result = this._cancelAlgorithm(reason);
            ReadableByteStreamControllerClearAlgorithms(this);
            return result;
          }
          [PullSteps](readRequest) {
            const stream = this._controlledReadableByteStream;
            if (this._queueTotalSize > 0) {
              const entry = this._queue.shift();
              this._queueTotalSize -= entry.byteLength;
              ReadableByteStreamControllerHandleQueueDrain(this);
              const view = new Uint8Array(entry.buffer, entry.byteOffset, entry.byteLength);
              readRequest._chunkSteps(view);
              return;
            }
            const autoAllocateChunkSize = this._autoAllocateChunkSize;
            if (autoAllocateChunkSize !== void 0) {
              let buffer;
              try {
                buffer = new ArrayBuffer(autoAllocateChunkSize);
              } catch (bufferE) {
                readRequest._errorSteps(bufferE);
                return;
              }
              const pullIntoDescriptor = {
                buffer,
                bufferByteLength: autoAllocateChunkSize,
                byteOffset: 0,
                byteLength: autoAllocateChunkSize,
                bytesFilled: 0,
                elementSize: 1,
                viewConstructor: Uint8Array,
                readerType: "default"
              };
              this._pendingPullIntos.push(pullIntoDescriptor);
            }
            ReadableStreamAddReadRequest(stream, readRequest);
            ReadableByteStreamControllerCallPullIfNeeded(this);
          }
        }
        Object.defineProperties(ReadableByteStreamController.prototype, {
          close: { enumerable: true },
          enqueue: { enumerable: true },
          error: { enumerable: true },
          byobRequest: { enumerable: true },
          desiredSize: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(ReadableByteStreamController.prototype, SymbolPolyfill.toStringTag, {
            value: "ReadableByteStreamController",
            configurable: true
          });
        }
        function IsReadableByteStreamController(x) {
          if (!typeIsObject(x)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x, "_controlledReadableByteStream")) {
            return false;
          }
          return x instanceof ReadableByteStreamController;
        }
        function IsReadableStreamBYOBRequest(x) {
          if (!typeIsObject(x)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x, "_associatedReadableByteStreamController")) {
            return false;
          }
          return x instanceof ReadableStreamBYOBRequest;
        }
        function ReadableByteStreamControllerCallPullIfNeeded(controller) {
          const shouldPull = ReadableByteStreamControllerShouldCallPull(controller);
          if (!shouldPull) {
            return;
          }
          if (controller._pulling) {
            controller._pullAgain = true;
            return;
          }
          controller._pulling = true;
          const pullPromise = controller._pullAlgorithm();
          uponPromise(pullPromise, () => {
            controller._pulling = false;
            if (controller._pullAgain) {
              controller._pullAgain = false;
              ReadableByteStreamControllerCallPullIfNeeded(controller);
            }
          }, (e) => {
            ReadableByteStreamControllerError(controller, e);
          });
        }
        function ReadableByteStreamControllerClearPendingPullIntos(controller) {
          ReadableByteStreamControllerInvalidateBYOBRequest(controller);
          controller._pendingPullIntos = new SimpleQueue();
        }
        function ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor) {
          let done = false;
          if (stream._state === "closed") {
            done = true;
          }
          const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);
          if (pullIntoDescriptor.readerType === "default") {
            ReadableStreamFulfillReadRequest(stream, filledView, done);
          } else {
            ReadableStreamFulfillReadIntoRequest(stream, filledView, done);
          }
        }
        function ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor) {
          const bytesFilled = pullIntoDescriptor.bytesFilled;
          const elementSize = pullIntoDescriptor.elementSize;
          return new pullIntoDescriptor.viewConstructor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, bytesFilled / elementSize);
        }
        function ReadableByteStreamControllerEnqueueChunkToQueue(controller, buffer, byteOffset, byteLength) {
          controller._queue.push({ buffer, byteOffset, byteLength });
          controller._queueTotalSize += byteLength;
        }
        function ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) {
          const elementSize = pullIntoDescriptor.elementSize;
          const currentAlignedBytes = pullIntoDescriptor.bytesFilled - pullIntoDescriptor.bytesFilled % elementSize;
          const maxBytesToCopy = Math.min(controller._queueTotalSize, pullIntoDescriptor.byteLength - pullIntoDescriptor.bytesFilled);
          const maxBytesFilled = pullIntoDescriptor.bytesFilled + maxBytesToCopy;
          const maxAlignedBytes = maxBytesFilled - maxBytesFilled % elementSize;
          let totalBytesToCopyRemaining = maxBytesToCopy;
          let ready = false;
          if (maxAlignedBytes > currentAlignedBytes) {
            totalBytesToCopyRemaining = maxAlignedBytes - pullIntoDescriptor.bytesFilled;
            ready = true;
          }
          const queue = controller._queue;
          while (totalBytesToCopyRemaining > 0) {
            const headOfQueue = queue.peek();
            const bytesToCopy = Math.min(totalBytesToCopyRemaining, headOfQueue.byteLength);
            const destStart = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;
            CopyDataBlockBytes(pullIntoDescriptor.buffer, destStart, headOfQueue.buffer, headOfQueue.byteOffset, bytesToCopy);
            if (headOfQueue.byteLength === bytesToCopy) {
              queue.shift();
            } else {
              headOfQueue.byteOffset += bytesToCopy;
              headOfQueue.byteLength -= bytesToCopy;
            }
            controller._queueTotalSize -= bytesToCopy;
            ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesToCopy, pullIntoDescriptor);
            totalBytesToCopyRemaining -= bytesToCopy;
          }
          return ready;
        }
        function ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, size, pullIntoDescriptor) {
          pullIntoDescriptor.bytesFilled += size;
        }
        function ReadableByteStreamControllerHandleQueueDrain(controller) {
          if (controller._queueTotalSize === 0 && controller._closeRequested) {
            ReadableByteStreamControllerClearAlgorithms(controller);
            ReadableStreamClose(controller._controlledReadableByteStream);
          } else {
            ReadableByteStreamControllerCallPullIfNeeded(controller);
          }
        }
        function ReadableByteStreamControllerInvalidateBYOBRequest(controller) {
          if (controller._byobRequest === null) {
            return;
          }
          controller._byobRequest._associatedReadableByteStreamController = void 0;
          controller._byobRequest._view = null;
          controller._byobRequest = null;
        }
        function ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller) {
          while (controller._pendingPullIntos.length > 0) {
            if (controller._queueTotalSize === 0) {
              return;
            }
            const pullIntoDescriptor = controller._pendingPullIntos.peek();
            if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {
              ReadableByteStreamControllerShiftPendingPullInto(controller);
              ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);
            }
          }
        }
        function ReadableByteStreamControllerPullInto(controller, view, readIntoRequest) {
          const stream = controller._controlledReadableByteStream;
          let elementSize = 1;
          if (view.constructor !== DataView) {
            elementSize = view.constructor.BYTES_PER_ELEMENT;
          }
          const ctor = view.constructor;
          const buffer = TransferArrayBuffer(view.buffer);
          const pullIntoDescriptor = {
            buffer,
            bufferByteLength: buffer.byteLength,
            byteOffset: view.byteOffset,
            byteLength: view.byteLength,
            bytesFilled: 0,
            elementSize,
            viewConstructor: ctor,
            readerType: "byob"
          };
          if (controller._pendingPullIntos.length > 0) {
            controller._pendingPullIntos.push(pullIntoDescriptor);
            ReadableStreamAddReadIntoRequest(stream, readIntoRequest);
            return;
          }
          if (stream._state === "closed") {
            const emptyView = new ctor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, 0);
            readIntoRequest._closeSteps(emptyView);
            return;
          }
          if (controller._queueTotalSize > 0) {
            if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {
              const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);
              ReadableByteStreamControllerHandleQueueDrain(controller);
              readIntoRequest._chunkSteps(filledView);
              return;
            }
            if (controller._closeRequested) {
              const e = new TypeError("Insufficient bytes to fill elements in the given buffer");
              ReadableByteStreamControllerError(controller, e);
              readIntoRequest._errorSteps(e);
              return;
            }
          }
          controller._pendingPullIntos.push(pullIntoDescriptor);
          ReadableStreamAddReadIntoRequest(stream, readIntoRequest);
          ReadableByteStreamControllerCallPullIfNeeded(controller);
        }
        function ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor) {
          const stream = controller._controlledReadableByteStream;
          if (ReadableStreamHasBYOBReader(stream)) {
            while (ReadableStreamGetNumReadIntoRequests(stream) > 0) {
              const pullIntoDescriptor = ReadableByteStreamControllerShiftPendingPullInto(controller);
              ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor);
            }
          }
        }
        function ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, pullIntoDescriptor) {
          ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesWritten, pullIntoDescriptor);
          if (pullIntoDescriptor.bytesFilled < pullIntoDescriptor.elementSize) {
            return;
          }
          ReadableByteStreamControllerShiftPendingPullInto(controller);
          const remainderSize = pullIntoDescriptor.bytesFilled % pullIntoDescriptor.elementSize;
          if (remainderSize > 0) {
            const end = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;
            const remainder = ArrayBufferSlice(pullIntoDescriptor.buffer, end - remainderSize, end);
            ReadableByteStreamControllerEnqueueChunkToQueue(controller, remainder, 0, remainder.byteLength);
          }
          pullIntoDescriptor.bytesFilled -= remainderSize;
          ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);
          ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);
        }
        function ReadableByteStreamControllerRespondInternal(controller, bytesWritten) {
          const firstDescriptor = controller._pendingPullIntos.peek();
          ReadableByteStreamControllerInvalidateBYOBRequest(controller);
          const state = controller._controlledReadableByteStream._state;
          if (state === "closed") {
            ReadableByteStreamControllerRespondInClosedState(controller);
          } else {
            ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, firstDescriptor);
          }
          ReadableByteStreamControllerCallPullIfNeeded(controller);
        }
        function ReadableByteStreamControllerShiftPendingPullInto(controller) {
          const descriptor = controller._pendingPullIntos.shift();
          return descriptor;
        }
        function ReadableByteStreamControllerShouldCallPull(controller) {
          const stream = controller._controlledReadableByteStream;
          if (stream._state !== "readable") {
            return false;
          }
          if (controller._closeRequested) {
            return false;
          }
          if (!controller._started) {
            return false;
          }
          if (ReadableStreamHasDefaultReader(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {
            return true;
          }
          if (ReadableStreamHasBYOBReader(stream) && ReadableStreamGetNumReadIntoRequests(stream) > 0) {
            return true;
          }
          const desiredSize = ReadableByteStreamControllerGetDesiredSize(controller);
          if (desiredSize > 0) {
            return true;
          }
          return false;
        }
        function ReadableByteStreamControllerClearAlgorithms(controller) {
          controller._pullAlgorithm = void 0;
          controller._cancelAlgorithm = void 0;
        }
        function ReadableByteStreamControllerClose(controller) {
          const stream = controller._controlledReadableByteStream;
          if (controller._closeRequested || stream._state !== "readable") {
            return;
          }
          if (controller._queueTotalSize > 0) {
            controller._closeRequested = true;
            return;
          }
          if (controller._pendingPullIntos.length > 0) {
            const firstPendingPullInto = controller._pendingPullIntos.peek();
            if (firstPendingPullInto.bytesFilled > 0) {
              const e = new TypeError("Insufficient bytes to fill elements in the given buffer");
              ReadableByteStreamControllerError(controller, e);
              throw e;
            }
          }
          ReadableByteStreamControllerClearAlgorithms(controller);
          ReadableStreamClose(stream);
        }
        function ReadableByteStreamControllerEnqueue(controller, chunk) {
          const stream = controller._controlledReadableByteStream;
          if (controller._closeRequested || stream._state !== "readable") {
            return;
          }
          const buffer = chunk.buffer;
          const byteOffset = chunk.byteOffset;
          const byteLength = chunk.byteLength;
          const transferredBuffer = TransferArrayBuffer(buffer);
          if (controller._pendingPullIntos.length > 0) {
            const firstPendingPullInto = controller._pendingPullIntos.peek();
            if (IsDetachedBuffer(firstPendingPullInto.buffer))
              ;
            firstPendingPullInto.buffer = TransferArrayBuffer(firstPendingPullInto.buffer);
          }
          ReadableByteStreamControllerInvalidateBYOBRequest(controller);
          if (ReadableStreamHasDefaultReader(stream)) {
            if (ReadableStreamGetNumReadRequests(stream) === 0) {
              ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
            } else {
              const transferredView = new Uint8Array(transferredBuffer, byteOffset, byteLength);
              ReadableStreamFulfillReadRequest(stream, transferredView, false);
            }
          } else if (ReadableStreamHasBYOBReader(stream)) {
            ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
            ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);
          } else {
            ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
          }
          ReadableByteStreamControllerCallPullIfNeeded(controller);
        }
        function ReadableByteStreamControllerError(controller, e) {
          const stream = controller._controlledReadableByteStream;
          if (stream._state !== "readable") {
            return;
          }
          ReadableByteStreamControllerClearPendingPullIntos(controller);
          ResetQueue(controller);
          ReadableByteStreamControllerClearAlgorithms(controller);
          ReadableStreamError(stream, e);
        }
        function ReadableByteStreamControllerGetBYOBRequest(controller) {
          if (controller._byobRequest === null && controller._pendingPullIntos.length > 0) {
            const firstDescriptor = controller._pendingPullIntos.peek();
            const view = new Uint8Array(firstDescriptor.buffer, firstDescriptor.byteOffset + firstDescriptor.bytesFilled, firstDescriptor.byteLength - firstDescriptor.bytesFilled);
            const byobRequest = Object.create(ReadableStreamBYOBRequest.prototype);
            SetUpReadableStreamBYOBRequest(byobRequest, controller, view);
            controller._byobRequest = byobRequest;
          }
          return controller._byobRequest;
        }
        function ReadableByteStreamControllerGetDesiredSize(controller) {
          const state = controller._controlledReadableByteStream._state;
          if (state === "errored") {
            return null;
          }
          if (state === "closed") {
            return 0;
          }
          return controller._strategyHWM - controller._queueTotalSize;
        }
        function ReadableByteStreamControllerRespond(controller, bytesWritten) {
          const firstDescriptor = controller._pendingPullIntos.peek();
          const state = controller._controlledReadableByteStream._state;
          if (state === "closed") {
            if (bytesWritten !== 0) {
              throw new TypeError("bytesWritten must be 0 when calling respond() on a closed stream");
            }
          } else {
            if (bytesWritten === 0) {
              throw new TypeError("bytesWritten must be greater than 0 when calling respond() on a readable stream");
            }
            if (firstDescriptor.bytesFilled + bytesWritten > firstDescriptor.byteLength) {
              throw new RangeError("bytesWritten out of range");
            }
          }
          firstDescriptor.buffer = TransferArrayBuffer(firstDescriptor.buffer);
          ReadableByteStreamControllerRespondInternal(controller, bytesWritten);
        }
        function ReadableByteStreamControllerRespondWithNewView(controller, view) {
          const firstDescriptor = controller._pendingPullIntos.peek();
          const state = controller._controlledReadableByteStream._state;
          if (state === "closed") {
            if (view.byteLength !== 0) {
              throw new TypeError("The view's length must be 0 when calling respondWithNewView() on a closed stream");
            }
          } else {
            if (view.byteLength === 0) {
              throw new TypeError("The view's length must be greater than 0 when calling respondWithNewView() on a readable stream");
            }
          }
          if (firstDescriptor.byteOffset + firstDescriptor.bytesFilled !== view.byteOffset) {
            throw new RangeError("The region specified by view does not match byobRequest");
          }
          if (firstDescriptor.bufferByteLength !== view.buffer.byteLength) {
            throw new RangeError("The buffer of view has different capacity than byobRequest");
          }
          if (firstDescriptor.bytesFilled + view.byteLength > firstDescriptor.byteLength) {
            throw new RangeError("The region specified by view is larger than byobRequest");
          }
          firstDescriptor.buffer = TransferArrayBuffer(view.buffer);
          ReadableByteStreamControllerRespondInternal(controller, view.byteLength);
        }
        function SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize) {
          controller._controlledReadableByteStream = stream;
          controller._pullAgain = false;
          controller._pulling = false;
          controller._byobRequest = null;
          controller._queue = controller._queueTotalSize = void 0;
          ResetQueue(controller);
          controller._closeRequested = false;
          controller._started = false;
          controller._strategyHWM = highWaterMark;
          controller._pullAlgorithm = pullAlgorithm;
          controller._cancelAlgorithm = cancelAlgorithm;
          controller._autoAllocateChunkSize = autoAllocateChunkSize;
          controller._pendingPullIntos = new SimpleQueue();
          stream._readableStreamController = controller;
          const startResult = startAlgorithm();
          uponPromise(promiseResolvedWith(startResult), () => {
            controller._started = true;
            ReadableByteStreamControllerCallPullIfNeeded(controller);
          }, (r) => {
            ReadableByteStreamControllerError(controller, r);
          });
        }
        function SetUpReadableByteStreamControllerFromUnderlyingSource(stream, underlyingByteSource, highWaterMark) {
          const controller = Object.create(ReadableByteStreamController.prototype);
          let startAlgorithm = () => void 0;
          let pullAlgorithm = () => promiseResolvedWith(void 0);
          let cancelAlgorithm = () => promiseResolvedWith(void 0);
          if (underlyingByteSource.start !== void 0) {
            startAlgorithm = () => underlyingByteSource.start(controller);
          }
          if (underlyingByteSource.pull !== void 0) {
            pullAlgorithm = () => underlyingByteSource.pull(controller);
          }
          if (underlyingByteSource.cancel !== void 0) {
            cancelAlgorithm = (reason) => underlyingByteSource.cancel(reason);
          }
          const autoAllocateChunkSize = underlyingByteSource.autoAllocateChunkSize;
          if (autoAllocateChunkSize === 0) {
            throw new TypeError("autoAllocateChunkSize must be greater than 0");
          }
          SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize);
        }
        function SetUpReadableStreamBYOBRequest(request, controller, view) {
          request._associatedReadableByteStreamController = controller;
          request._view = view;
        }
        function byobRequestBrandCheckException(name) {
          return new TypeError(`ReadableStreamBYOBRequest.prototype.${name} can only be used on a ReadableStreamBYOBRequest`);
        }
        function byteStreamControllerBrandCheckException(name) {
          return new TypeError(`ReadableByteStreamController.prototype.${name} can only be used on a ReadableByteStreamController`);
        }
        function AcquireReadableStreamBYOBReader(stream) {
          return new ReadableStreamBYOBReader(stream);
        }
        function ReadableStreamAddReadIntoRequest(stream, readIntoRequest) {
          stream._reader._readIntoRequests.push(readIntoRequest);
        }
        function ReadableStreamFulfillReadIntoRequest(stream, chunk, done) {
          const reader = stream._reader;
          const readIntoRequest = reader._readIntoRequests.shift();
          if (done) {
            readIntoRequest._closeSteps(chunk);
          } else {
            readIntoRequest._chunkSteps(chunk);
          }
        }
        function ReadableStreamGetNumReadIntoRequests(stream) {
          return stream._reader._readIntoRequests.length;
        }
        function ReadableStreamHasBYOBReader(stream) {
          const reader = stream._reader;
          if (reader === void 0) {
            return false;
          }
          if (!IsReadableStreamBYOBReader(reader)) {
            return false;
          }
          return true;
        }
        class ReadableStreamBYOBReader {
          constructor(stream) {
            assertRequiredArgument(stream, 1, "ReadableStreamBYOBReader");
            assertReadableStream(stream, "First parameter");
            if (IsReadableStreamLocked(stream)) {
              throw new TypeError("This stream has already been locked for exclusive reading by another reader");
            }
            if (!IsReadableByteStreamController(stream._readableStreamController)) {
              throw new TypeError("Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte source");
            }
            ReadableStreamReaderGenericInitialize(this, stream);
            this._readIntoRequests = new SimpleQueue();
          }
          get closed() {
            if (!IsReadableStreamBYOBReader(this)) {
              return promiseRejectedWith(byobReaderBrandCheckException("closed"));
            }
            return this._closedPromise;
          }
          cancel(reason = void 0) {
            if (!IsReadableStreamBYOBReader(this)) {
              return promiseRejectedWith(byobReaderBrandCheckException("cancel"));
            }
            if (this._ownerReadableStream === void 0) {
              return promiseRejectedWith(readerLockException("cancel"));
            }
            return ReadableStreamReaderGenericCancel(this, reason);
          }
          read(view) {
            if (!IsReadableStreamBYOBReader(this)) {
              return promiseRejectedWith(byobReaderBrandCheckException("read"));
            }
            if (!ArrayBuffer.isView(view)) {
              return promiseRejectedWith(new TypeError("view must be an array buffer view"));
            }
            if (view.byteLength === 0) {
              return promiseRejectedWith(new TypeError("view must have non-zero byteLength"));
            }
            if (view.buffer.byteLength === 0) {
              return promiseRejectedWith(new TypeError(`view's buffer must have non-zero byteLength`));
            }
            if (IsDetachedBuffer(view.buffer))
              ;
            if (this._ownerReadableStream === void 0) {
              return promiseRejectedWith(readerLockException("read from"));
            }
            let resolvePromise;
            let rejectPromise;
            const promise = newPromise((resolve2, reject) => {
              resolvePromise = resolve2;
              rejectPromise = reject;
            });
            const readIntoRequest = {
              _chunkSteps: (chunk) => resolvePromise({ value: chunk, done: false }),
              _closeSteps: (chunk) => resolvePromise({ value: chunk, done: true }),
              _errorSteps: (e) => rejectPromise(e)
            };
            ReadableStreamBYOBReaderRead(this, view, readIntoRequest);
            return promise;
          }
          releaseLock() {
            if (!IsReadableStreamBYOBReader(this)) {
              throw byobReaderBrandCheckException("releaseLock");
            }
            if (this._ownerReadableStream === void 0) {
              return;
            }
            if (this._readIntoRequests.length > 0) {
              throw new TypeError("Tried to release a reader lock when that reader has pending read() calls un-settled");
            }
            ReadableStreamReaderGenericRelease(this);
          }
        }
        Object.defineProperties(ReadableStreamBYOBReader.prototype, {
          cancel: { enumerable: true },
          read: { enumerable: true },
          releaseLock: { enumerable: true },
          closed: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(ReadableStreamBYOBReader.prototype, SymbolPolyfill.toStringTag, {
            value: "ReadableStreamBYOBReader",
            configurable: true
          });
        }
        function IsReadableStreamBYOBReader(x) {
          if (!typeIsObject(x)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x, "_readIntoRequests")) {
            return false;
          }
          return x instanceof ReadableStreamBYOBReader;
        }
        function ReadableStreamBYOBReaderRead(reader, view, readIntoRequest) {
          const stream = reader._ownerReadableStream;
          stream._disturbed = true;
          if (stream._state === "errored") {
            readIntoRequest._errorSteps(stream._storedError);
          } else {
            ReadableByteStreamControllerPullInto(stream._readableStreamController, view, readIntoRequest);
          }
        }
        function byobReaderBrandCheckException(name) {
          return new TypeError(`ReadableStreamBYOBReader.prototype.${name} can only be used on a ReadableStreamBYOBReader`);
        }
        function ExtractHighWaterMark(strategy, defaultHWM) {
          const { highWaterMark } = strategy;
          if (highWaterMark === void 0) {
            return defaultHWM;
          }
          if (NumberIsNaN(highWaterMark) || highWaterMark < 0) {
            throw new RangeError("Invalid highWaterMark");
          }
          return highWaterMark;
        }
        function ExtractSizeAlgorithm(strategy) {
          const { size } = strategy;
          if (!size) {
            return () => 1;
          }
          return size;
        }
        function convertQueuingStrategy(init2, context) {
          assertDictionary(init2, context);
          const highWaterMark = init2 === null || init2 === void 0 ? void 0 : init2.highWaterMark;
          const size = init2 === null || init2 === void 0 ? void 0 : init2.size;
          return {
            highWaterMark: highWaterMark === void 0 ? void 0 : convertUnrestrictedDouble(highWaterMark),
            size: size === void 0 ? void 0 : convertQueuingStrategySize(size, `${context} has member 'size' that`)
          };
        }
        function convertQueuingStrategySize(fn, context) {
          assertFunction(fn, context);
          return (chunk) => convertUnrestrictedDouble(fn(chunk));
        }
        function convertUnderlyingSink(original, context) {
          assertDictionary(original, context);
          const abort = original === null || original === void 0 ? void 0 : original.abort;
          const close = original === null || original === void 0 ? void 0 : original.close;
          const start = original === null || original === void 0 ? void 0 : original.start;
          const type = original === null || original === void 0 ? void 0 : original.type;
          const write = original === null || original === void 0 ? void 0 : original.write;
          return {
            abort: abort === void 0 ? void 0 : convertUnderlyingSinkAbortCallback(abort, original, `${context} has member 'abort' that`),
            close: close === void 0 ? void 0 : convertUnderlyingSinkCloseCallback(close, original, `${context} has member 'close' that`),
            start: start === void 0 ? void 0 : convertUnderlyingSinkStartCallback(start, original, `${context} has member 'start' that`),
            write: write === void 0 ? void 0 : convertUnderlyingSinkWriteCallback(write, original, `${context} has member 'write' that`),
            type
          };
        }
        function convertUnderlyingSinkAbortCallback(fn, original, context) {
          assertFunction(fn, context);
          return (reason) => promiseCall(fn, original, [reason]);
        }
        function convertUnderlyingSinkCloseCallback(fn, original, context) {
          assertFunction(fn, context);
          return () => promiseCall(fn, original, []);
        }
        function convertUnderlyingSinkStartCallback(fn, original, context) {
          assertFunction(fn, context);
          return (controller) => reflectCall(fn, original, [controller]);
        }
        function convertUnderlyingSinkWriteCallback(fn, original, context) {
          assertFunction(fn, context);
          return (chunk, controller) => promiseCall(fn, original, [chunk, controller]);
        }
        function assertWritableStream(x, context) {
          if (!IsWritableStream(x)) {
            throw new TypeError(`${context} is not a WritableStream.`);
          }
        }
        function isAbortSignal2(value) {
          if (typeof value !== "object" || value === null) {
            return false;
          }
          try {
            return typeof value.aborted === "boolean";
          } catch (_a) {
            return false;
          }
        }
        const supportsAbortController = typeof AbortController === "function";
        function createAbortController() {
          if (supportsAbortController) {
            return new AbortController();
          }
          return void 0;
        }
        class WritableStream {
          constructor(rawUnderlyingSink = {}, rawStrategy = {}) {
            if (rawUnderlyingSink === void 0) {
              rawUnderlyingSink = null;
            } else {
              assertObject(rawUnderlyingSink, "First parameter");
            }
            const strategy = convertQueuingStrategy(rawStrategy, "Second parameter");
            const underlyingSink = convertUnderlyingSink(rawUnderlyingSink, "First parameter");
            InitializeWritableStream(this);
            const type = underlyingSink.type;
            if (type !== void 0) {
              throw new RangeError("Invalid type is specified");
            }
            const sizeAlgorithm = ExtractSizeAlgorithm(strategy);
            const highWaterMark = ExtractHighWaterMark(strategy, 1);
            SetUpWritableStreamDefaultControllerFromUnderlyingSink(this, underlyingSink, highWaterMark, sizeAlgorithm);
          }
          get locked() {
            if (!IsWritableStream(this)) {
              throw streamBrandCheckException$2("locked");
            }
            return IsWritableStreamLocked(this);
          }
          abort(reason = void 0) {
            if (!IsWritableStream(this)) {
              return promiseRejectedWith(streamBrandCheckException$2("abort"));
            }
            if (IsWritableStreamLocked(this)) {
              return promiseRejectedWith(new TypeError("Cannot abort a stream that already has a writer"));
            }
            return WritableStreamAbort(this, reason);
          }
          close() {
            if (!IsWritableStream(this)) {
              return promiseRejectedWith(streamBrandCheckException$2("close"));
            }
            if (IsWritableStreamLocked(this)) {
              return promiseRejectedWith(new TypeError("Cannot close a stream that already has a writer"));
            }
            if (WritableStreamCloseQueuedOrInFlight(this)) {
              return promiseRejectedWith(new TypeError("Cannot close an already-closing stream"));
            }
            return WritableStreamClose(this);
          }
          getWriter() {
            if (!IsWritableStream(this)) {
              throw streamBrandCheckException$2("getWriter");
            }
            return AcquireWritableStreamDefaultWriter(this);
          }
        }
        Object.defineProperties(WritableStream.prototype, {
          abort: { enumerable: true },
          close: { enumerable: true },
          getWriter: { enumerable: true },
          locked: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(WritableStream.prototype, SymbolPolyfill.toStringTag, {
            value: "WritableStream",
            configurable: true
          });
        }
        function AcquireWritableStreamDefaultWriter(stream) {
          return new WritableStreamDefaultWriter(stream);
        }
        function CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark = 1, sizeAlgorithm = () => 1) {
          const stream = Object.create(WritableStream.prototype);
          InitializeWritableStream(stream);
          const controller = Object.create(WritableStreamDefaultController.prototype);
          SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);
          return stream;
        }
        function InitializeWritableStream(stream) {
          stream._state = "writable";
          stream._storedError = void 0;
          stream._writer = void 0;
          stream._writableStreamController = void 0;
          stream._writeRequests = new SimpleQueue();
          stream._inFlightWriteRequest = void 0;
          stream._closeRequest = void 0;
          stream._inFlightCloseRequest = void 0;
          stream._pendingAbortRequest = void 0;
          stream._backpressure = false;
        }
        function IsWritableStream(x) {
          if (!typeIsObject(x)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x, "_writableStreamController")) {
            return false;
          }
          return x instanceof WritableStream;
        }
        function IsWritableStreamLocked(stream) {
          if (stream._writer === void 0) {
            return false;
          }
          return true;
        }
        function WritableStreamAbort(stream, reason) {
          var _a;
          if (stream._state === "closed" || stream._state === "errored") {
            return promiseResolvedWith(void 0);
          }
          stream._writableStreamController._abortReason = reason;
          (_a = stream._writableStreamController._abortController) === null || _a === void 0 ? void 0 : _a.abort();
          const state = stream._state;
          if (state === "closed" || state === "errored") {
            return promiseResolvedWith(void 0);
          }
          if (stream._pendingAbortRequest !== void 0) {
            return stream._pendingAbortRequest._promise;
          }
          let wasAlreadyErroring = false;
          if (state === "erroring") {
            wasAlreadyErroring = true;
            reason = void 0;
          }
          const promise = newPromise((resolve2, reject) => {
            stream._pendingAbortRequest = {
              _promise: void 0,
              _resolve: resolve2,
              _reject: reject,
              _reason: reason,
              _wasAlreadyErroring: wasAlreadyErroring
            };
          });
          stream._pendingAbortRequest._promise = promise;
          if (!wasAlreadyErroring) {
            WritableStreamStartErroring(stream, reason);
          }
          return promise;
        }
        function WritableStreamClose(stream) {
          const state = stream._state;
          if (state === "closed" || state === "errored") {
            return promiseRejectedWith(new TypeError(`The stream (in ${state} state) is not in the writable state and cannot be closed`));
          }
          const promise = newPromise((resolve2, reject) => {
            const closeRequest = {
              _resolve: resolve2,
              _reject: reject
            };
            stream._closeRequest = closeRequest;
          });
          const writer = stream._writer;
          if (writer !== void 0 && stream._backpressure && state === "writable") {
            defaultWriterReadyPromiseResolve(writer);
          }
          WritableStreamDefaultControllerClose(stream._writableStreamController);
          return promise;
        }
        function WritableStreamAddWriteRequest(stream) {
          const promise = newPromise((resolve2, reject) => {
            const writeRequest = {
              _resolve: resolve2,
              _reject: reject
            };
            stream._writeRequests.push(writeRequest);
          });
          return promise;
        }
        function WritableStreamDealWithRejection(stream, error2) {
          const state = stream._state;
          if (state === "writable") {
            WritableStreamStartErroring(stream, error2);
            return;
          }
          WritableStreamFinishErroring(stream);
        }
        function WritableStreamStartErroring(stream, reason) {
          const controller = stream._writableStreamController;
          stream._state = "erroring";
          stream._storedError = reason;
          const writer = stream._writer;
          if (writer !== void 0) {
            WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, reason);
          }
          if (!WritableStreamHasOperationMarkedInFlight(stream) && controller._started) {
            WritableStreamFinishErroring(stream);
          }
        }
        function WritableStreamFinishErroring(stream) {
          stream._state = "errored";
          stream._writableStreamController[ErrorSteps]();
          const storedError = stream._storedError;
          stream._writeRequests.forEach((writeRequest) => {
            writeRequest._reject(storedError);
          });
          stream._writeRequests = new SimpleQueue();
          if (stream._pendingAbortRequest === void 0) {
            WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
            return;
          }
          const abortRequest = stream._pendingAbortRequest;
          stream._pendingAbortRequest = void 0;
          if (abortRequest._wasAlreadyErroring) {
            abortRequest._reject(storedError);
            WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
            return;
          }
          const promise = stream._writableStreamController[AbortSteps](abortRequest._reason);
          uponPromise(promise, () => {
            abortRequest._resolve();
            WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
          }, (reason) => {
            abortRequest._reject(reason);
            WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
          });
        }
        function WritableStreamFinishInFlightWrite(stream) {
          stream._inFlightWriteRequest._resolve(void 0);
          stream._inFlightWriteRequest = void 0;
        }
        function WritableStreamFinishInFlightWriteWithError(stream, error2) {
          stream._inFlightWriteRequest._reject(error2);
          stream._inFlightWriteRequest = void 0;
          WritableStreamDealWithRejection(stream, error2);
        }
        function WritableStreamFinishInFlightClose(stream) {
          stream._inFlightCloseRequest._resolve(void 0);
          stream._inFlightCloseRequest = void 0;
          const state = stream._state;
          if (state === "erroring") {
            stream._storedError = void 0;
            if (stream._pendingAbortRequest !== void 0) {
              stream._pendingAbortRequest._resolve();
              stream._pendingAbortRequest = void 0;
            }
          }
          stream._state = "closed";
          const writer = stream._writer;
          if (writer !== void 0) {
            defaultWriterClosedPromiseResolve(writer);
          }
        }
        function WritableStreamFinishInFlightCloseWithError(stream, error2) {
          stream._inFlightCloseRequest._reject(error2);
          stream._inFlightCloseRequest = void 0;
          if (stream._pendingAbortRequest !== void 0) {
            stream._pendingAbortRequest._reject(error2);
            stream._pendingAbortRequest = void 0;
          }
          WritableStreamDealWithRejection(stream, error2);
        }
        function WritableStreamCloseQueuedOrInFlight(stream) {
          if (stream._closeRequest === void 0 && stream._inFlightCloseRequest === void 0) {
            return false;
          }
          return true;
        }
        function WritableStreamHasOperationMarkedInFlight(stream) {
          if (stream._inFlightWriteRequest === void 0 && stream._inFlightCloseRequest === void 0) {
            return false;
          }
          return true;
        }
        function WritableStreamMarkCloseRequestInFlight(stream) {
          stream._inFlightCloseRequest = stream._closeRequest;
          stream._closeRequest = void 0;
        }
        function WritableStreamMarkFirstWriteRequestInFlight(stream) {
          stream._inFlightWriteRequest = stream._writeRequests.shift();
        }
        function WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream) {
          if (stream._closeRequest !== void 0) {
            stream._closeRequest._reject(stream._storedError);
            stream._closeRequest = void 0;
          }
          const writer = stream._writer;
          if (writer !== void 0) {
            defaultWriterClosedPromiseReject(writer, stream._storedError);
          }
        }
        function WritableStreamUpdateBackpressure(stream, backpressure) {
          const writer = stream._writer;
          if (writer !== void 0 && backpressure !== stream._backpressure) {
            if (backpressure) {
              defaultWriterReadyPromiseReset(writer);
            } else {
              defaultWriterReadyPromiseResolve(writer);
            }
          }
          stream._backpressure = backpressure;
        }
        class WritableStreamDefaultWriter {
          constructor(stream) {
            assertRequiredArgument(stream, 1, "WritableStreamDefaultWriter");
            assertWritableStream(stream, "First parameter");
            if (IsWritableStreamLocked(stream)) {
              throw new TypeError("This stream has already been locked for exclusive writing by another writer");
            }
            this._ownerWritableStream = stream;
            stream._writer = this;
            const state = stream._state;
            if (state === "writable") {
              if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._backpressure) {
                defaultWriterReadyPromiseInitialize(this);
              } else {
                defaultWriterReadyPromiseInitializeAsResolved(this);
              }
              defaultWriterClosedPromiseInitialize(this);
            } else if (state === "erroring") {
              defaultWriterReadyPromiseInitializeAsRejected(this, stream._storedError);
              defaultWriterClosedPromiseInitialize(this);
            } else if (state === "closed") {
              defaultWriterReadyPromiseInitializeAsResolved(this);
              defaultWriterClosedPromiseInitializeAsResolved(this);
            } else {
              const storedError = stream._storedError;
              defaultWriterReadyPromiseInitializeAsRejected(this, storedError);
              defaultWriterClosedPromiseInitializeAsRejected(this, storedError);
            }
          }
          get closed() {
            if (!IsWritableStreamDefaultWriter(this)) {
              return promiseRejectedWith(defaultWriterBrandCheckException("closed"));
            }
            return this._closedPromise;
          }
          get desiredSize() {
            if (!IsWritableStreamDefaultWriter(this)) {
              throw defaultWriterBrandCheckException("desiredSize");
            }
            if (this._ownerWritableStream === void 0) {
              throw defaultWriterLockException("desiredSize");
            }
            return WritableStreamDefaultWriterGetDesiredSize(this);
          }
          get ready() {
            if (!IsWritableStreamDefaultWriter(this)) {
              return promiseRejectedWith(defaultWriterBrandCheckException("ready"));
            }
            return this._readyPromise;
          }
          abort(reason = void 0) {
            if (!IsWritableStreamDefaultWriter(this)) {
              return promiseRejectedWith(defaultWriterBrandCheckException("abort"));
            }
            if (this._ownerWritableStream === void 0) {
              return promiseRejectedWith(defaultWriterLockException("abort"));
            }
            return WritableStreamDefaultWriterAbort(this, reason);
          }
          close() {
            if (!IsWritableStreamDefaultWriter(this)) {
              return promiseRejectedWith(defaultWriterBrandCheckException("close"));
            }
            const stream = this._ownerWritableStream;
            if (stream === void 0) {
              return promiseRejectedWith(defaultWriterLockException("close"));
            }
            if (WritableStreamCloseQueuedOrInFlight(stream)) {
              return promiseRejectedWith(new TypeError("Cannot close an already-closing stream"));
            }
            return WritableStreamDefaultWriterClose(this);
          }
          releaseLock() {
            if (!IsWritableStreamDefaultWriter(this)) {
              throw defaultWriterBrandCheckException("releaseLock");
            }
            const stream = this._ownerWritableStream;
            if (stream === void 0) {
              return;
            }
            WritableStreamDefaultWriterRelease(this);
          }
          write(chunk = void 0) {
            if (!IsWritableStreamDefaultWriter(this)) {
              return promiseRejectedWith(defaultWriterBrandCheckException("write"));
            }
            if (this._ownerWritableStream === void 0) {
              return promiseRejectedWith(defaultWriterLockException("write to"));
            }
            return WritableStreamDefaultWriterWrite(this, chunk);
          }
        }
        Object.defineProperties(WritableStreamDefaultWriter.prototype, {
          abort: { enumerable: true },
          close: { enumerable: true },
          releaseLock: { enumerable: true },
          write: { enumerable: true },
          closed: { enumerable: true },
          desiredSize: { enumerable: true },
          ready: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(WritableStreamDefaultWriter.prototype, SymbolPolyfill.toStringTag, {
            value: "WritableStreamDefaultWriter",
            configurable: true
          });
        }
        function IsWritableStreamDefaultWriter(x) {
          if (!typeIsObject(x)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x, "_ownerWritableStream")) {
            return false;
          }
          return x instanceof WritableStreamDefaultWriter;
        }
        function WritableStreamDefaultWriterAbort(writer, reason) {
          const stream = writer._ownerWritableStream;
          return WritableStreamAbort(stream, reason);
        }
        function WritableStreamDefaultWriterClose(writer) {
          const stream = writer._ownerWritableStream;
          return WritableStreamClose(stream);
        }
        function WritableStreamDefaultWriterCloseWithErrorPropagation(writer) {
          const stream = writer._ownerWritableStream;
          const state = stream._state;
          if (WritableStreamCloseQueuedOrInFlight(stream) || state === "closed") {
            return promiseResolvedWith(void 0);
          }
          if (state === "errored") {
            return promiseRejectedWith(stream._storedError);
          }
          return WritableStreamDefaultWriterClose(writer);
        }
        function WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, error2) {
          if (writer._closedPromiseState === "pending") {
            defaultWriterClosedPromiseReject(writer, error2);
          } else {
            defaultWriterClosedPromiseResetToRejected(writer, error2);
          }
        }
        function WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, error2) {
          if (writer._readyPromiseState === "pending") {
            defaultWriterReadyPromiseReject(writer, error2);
          } else {
            defaultWriterReadyPromiseResetToRejected(writer, error2);
          }
        }
        function WritableStreamDefaultWriterGetDesiredSize(writer) {
          const stream = writer._ownerWritableStream;
          const state = stream._state;
          if (state === "errored" || state === "erroring") {
            return null;
          }
          if (state === "closed") {
            return 0;
          }
          return WritableStreamDefaultControllerGetDesiredSize(stream._writableStreamController);
        }
        function WritableStreamDefaultWriterRelease(writer) {
          const stream = writer._ownerWritableStream;
          const releasedError = new TypeError(`Writer was released and can no longer be used to monitor the stream's closedness`);
          WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, releasedError);
          WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, releasedError);
          stream._writer = void 0;
          writer._ownerWritableStream = void 0;
        }
        function WritableStreamDefaultWriterWrite(writer, chunk) {
          const stream = writer._ownerWritableStream;
          const controller = stream._writableStreamController;
          const chunkSize = WritableStreamDefaultControllerGetChunkSize(controller, chunk);
          if (stream !== writer._ownerWritableStream) {
            return promiseRejectedWith(defaultWriterLockException("write to"));
          }
          const state = stream._state;
          if (state === "errored") {
            return promiseRejectedWith(stream._storedError);
          }
          if (WritableStreamCloseQueuedOrInFlight(stream) || state === "closed") {
            return promiseRejectedWith(new TypeError("The stream is closing or closed and cannot be written to"));
          }
          if (state === "erroring") {
            return promiseRejectedWith(stream._storedError);
          }
          const promise = WritableStreamAddWriteRequest(stream);
          WritableStreamDefaultControllerWrite(controller, chunk, chunkSize);
          return promise;
        }
        const closeSentinel = {};
        class WritableStreamDefaultController {
          constructor() {
            throw new TypeError("Illegal constructor");
          }
          get abortReason() {
            if (!IsWritableStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException$2("abortReason");
            }
            return this._abortReason;
          }
          get signal() {
            if (!IsWritableStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException$2("signal");
            }
            if (this._abortController === void 0) {
              throw new TypeError("WritableStreamDefaultController.prototype.signal is not supported");
            }
            return this._abortController.signal;
          }
          error(e = void 0) {
            if (!IsWritableStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException$2("error");
            }
            const state = this._controlledWritableStream._state;
            if (state !== "writable") {
              return;
            }
            WritableStreamDefaultControllerError(this, e);
          }
          [AbortSteps](reason) {
            const result = this._abortAlgorithm(reason);
            WritableStreamDefaultControllerClearAlgorithms(this);
            return result;
          }
          [ErrorSteps]() {
            ResetQueue(this);
          }
        }
        Object.defineProperties(WritableStreamDefaultController.prototype, {
          error: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(WritableStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {
            value: "WritableStreamDefaultController",
            configurable: true
          });
        }
        function IsWritableStreamDefaultController(x) {
          if (!typeIsObject(x)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x, "_controlledWritableStream")) {
            return false;
          }
          return x instanceof WritableStreamDefaultController;
        }
        function SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm) {
          controller._controlledWritableStream = stream;
          stream._writableStreamController = controller;
          controller._queue = void 0;
          controller._queueTotalSize = void 0;
          ResetQueue(controller);
          controller._abortReason = void 0;
          controller._abortController = createAbortController();
          controller._started = false;
          controller._strategySizeAlgorithm = sizeAlgorithm;
          controller._strategyHWM = highWaterMark;
          controller._writeAlgorithm = writeAlgorithm;
          controller._closeAlgorithm = closeAlgorithm;
          controller._abortAlgorithm = abortAlgorithm;
          const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
          WritableStreamUpdateBackpressure(stream, backpressure);
          const startResult = startAlgorithm();
          const startPromise = promiseResolvedWith(startResult);
          uponPromise(startPromise, () => {
            controller._started = true;
            WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
          }, (r) => {
            controller._started = true;
            WritableStreamDealWithRejection(stream, r);
          });
        }
        function SetUpWritableStreamDefaultControllerFromUnderlyingSink(stream, underlyingSink, highWaterMark, sizeAlgorithm) {
          const controller = Object.create(WritableStreamDefaultController.prototype);
          let startAlgorithm = () => void 0;
          let writeAlgorithm = () => promiseResolvedWith(void 0);
          let closeAlgorithm = () => promiseResolvedWith(void 0);
          let abortAlgorithm = () => promiseResolvedWith(void 0);
          if (underlyingSink.start !== void 0) {
            startAlgorithm = () => underlyingSink.start(controller);
          }
          if (underlyingSink.write !== void 0) {
            writeAlgorithm = (chunk) => underlyingSink.write(chunk, controller);
          }
          if (underlyingSink.close !== void 0) {
            closeAlgorithm = () => underlyingSink.close();
          }
          if (underlyingSink.abort !== void 0) {
            abortAlgorithm = (reason) => underlyingSink.abort(reason);
          }
          SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);
        }
        function WritableStreamDefaultControllerClearAlgorithms(controller) {
          controller._writeAlgorithm = void 0;
          controller._closeAlgorithm = void 0;
          controller._abortAlgorithm = void 0;
          controller._strategySizeAlgorithm = void 0;
        }
        function WritableStreamDefaultControllerClose(controller) {
          EnqueueValueWithSize(controller, closeSentinel, 0);
          WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
        }
        function WritableStreamDefaultControllerGetChunkSize(controller, chunk) {
          try {
            return controller._strategySizeAlgorithm(chunk);
          } catch (chunkSizeE) {
            WritableStreamDefaultControllerErrorIfNeeded(controller, chunkSizeE);
            return 1;
          }
        }
        function WritableStreamDefaultControllerGetDesiredSize(controller) {
          return controller._strategyHWM - controller._queueTotalSize;
        }
        function WritableStreamDefaultControllerWrite(controller, chunk, chunkSize) {
          try {
            EnqueueValueWithSize(controller, chunk, chunkSize);
          } catch (enqueueE) {
            WritableStreamDefaultControllerErrorIfNeeded(controller, enqueueE);
            return;
          }
          const stream = controller._controlledWritableStream;
          if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._state === "writable") {
            const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
            WritableStreamUpdateBackpressure(stream, backpressure);
          }
          WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
        }
        function WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller) {
          const stream = controller._controlledWritableStream;
          if (!controller._started) {
            return;
          }
          if (stream._inFlightWriteRequest !== void 0) {
            return;
          }
          const state = stream._state;
          if (state === "erroring") {
            WritableStreamFinishErroring(stream);
            return;
          }
          if (controller._queue.length === 0) {
            return;
          }
          const value = PeekQueueValue(controller);
          if (value === closeSentinel) {
            WritableStreamDefaultControllerProcessClose(controller);
          } else {
            WritableStreamDefaultControllerProcessWrite(controller, value);
          }
        }
        function WritableStreamDefaultControllerErrorIfNeeded(controller, error2) {
          if (controller._controlledWritableStream._state === "writable") {
            WritableStreamDefaultControllerError(controller, error2);
          }
        }
        function WritableStreamDefaultControllerProcessClose(controller) {
          const stream = controller._controlledWritableStream;
          WritableStreamMarkCloseRequestInFlight(stream);
          DequeueValue(controller);
          const sinkClosePromise = controller._closeAlgorithm();
          WritableStreamDefaultControllerClearAlgorithms(controller);
          uponPromise(sinkClosePromise, () => {
            WritableStreamFinishInFlightClose(stream);
          }, (reason) => {
            WritableStreamFinishInFlightCloseWithError(stream, reason);
          });
        }
        function WritableStreamDefaultControllerProcessWrite(controller, chunk) {
          const stream = controller._controlledWritableStream;
          WritableStreamMarkFirstWriteRequestInFlight(stream);
          const sinkWritePromise = controller._writeAlgorithm(chunk);
          uponPromise(sinkWritePromise, () => {
            WritableStreamFinishInFlightWrite(stream);
            const state = stream._state;
            DequeueValue(controller);
            if (!WritableStreamCloseQueuedOrInFlight(stream) && state === "writable") {
              const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
              WritableStreamUpdateBackpressure(stream, backpressure);
            }
            WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
          }, (reason) => {
            if (stream._state === "writable") {
              WritableStreamDefaultControllerClearAlgorithms(controller);
            }
            WritableStreamFinishInFlightWriteWithError(stream, reason);
          });
        }
        function WritableStreamDefaultControllerGetBackpressure(controller) {
          const desiredSize = WritableStreamDefaultControllerGetDesiredSize(controller);
          return desiredSize <= 0;
        }
        function WritableStreamDefaultControllerError(controller, error2) {
          const stream = controller._controlledWritableStream;
          WritableStreamDefaultControllerClearAlgorithms(controller);
          WritableStreamStartErroring(stream, error2);
        }
        function streamBrandCheckException$2(name) {
          return new TypeError(`WritableStream.prototype.${name} can only be used on a WritableStream`);
        }
        function defaultControllerBrandCheckException$2(name) {
          return new TypeError(`WritableStreamDefaultController.prototype.${name} can only be used on a WritableStreamDefaultController`);
        }
        function defaultWriterBrandCheckException(name) {
          return new TypeError(`WritableStreamDefaultWriter.prototype.${name} can only be used on a WritableStreamDefaultWriter`);
        }
        function defaultWriterLockException(name) {
          return new TypeError("Cannot " + name + " a stream using a released writer");
        }
        function defaultWriterClosedPromiseInitialize(writer) {
          writer._closedPromise = newPromise((resolve2, reject) => {
            writer._closedPromise_resolve = resolve2;
            writer._closedPromise_reject = reject;
            writer._closedPromiseState = "pending";
          });
        }
        function defaultWriterClosedPromiseInitializeAsRejected(writer, reason) {
          defaultWriterClosedPromiseInitialize(writer);
          defaultWriterClosedPromiseReject(writer, reason);
        }
        function defaultWriterClosedPromiseInitializeAsResolved(writer) {
          defaultWriterClosedPromiseInitialize(writer);
          defaultWriterClosedPromiseResolve(writer);
        }
        function defaultWriterClosedPromiseReject(writer, reason) {
          if (writer._closedPromise_reject === void 0) {
            return;
          }
          setPromiseIsHandledToTrue(writer._closedPromise);
          writer._closedPromise_reject(reason);
          writer._closedPromise_resolve = void 0;
          writer._closedPromise_reject = void 0;
          writer._closedPromiseState = "rejected";
        }
        function defaultWriterClosedPromiseResetToRejected(writer, reason) {
          defaultWriterClosedPromiseInitializeAsRejected(writer, reason);
        }
        function defaultWriterClosedPromiseResolve(writer) {
          if (writer._closedPromise_resolve === void 0) {
            return;
          }
          writer._closedPromise_resolve(void 0);
          writer._closedPromise_resolve = void 0;
          writer._closedPromise_reject = void 0;
          writer._closedPromiseState = "resolved";
        }
        function defaultWriterReadyPromiseInitialize(writer) {
          writer._readyPromise = newPromise((resolve2, reject) => {
            writer._readyPromise_resolve = resolve2;
            writer._readyPromise_reject = reject;
          });
          writer._readyPromiseState = "pending";
        }
        function defaultWriterReadyPromiseInitializeAsRejected(writer, reason) {
          defaultWriterReadyPromiseInitialize(writer);
          defaultWriterReadyPromiseReject(writer, reason);
        }
        function defaultWriterReadyPromiseInitializeAsResolved(writer) {
          defaultWriterReadyPromiseInitialize(writer);
          defaultWriterReadyPromiseResolve(writer);
        }
        function defaultWriterReadyPromiseReject(writer, reason) {
          if (writer._readyPromise_reject === void 0) {
            return;
          }
          setPromiseIsHandledToTrue(writer._readyPromise);
          writer._readyPromise_reject(reason);
          writer._readyPromise_resolve = void 0;
          writer._readyPromise_reject = void 0;
          writer._readyPromiseState = "rejected";
        }
        function defaultWriterReadyPromiseReset(writer) {
          defaultWriterReadyPromiseInitialize(writer);
        }
        function defaultWriterReadyPromiseResetToRejected(writer, reason) {
          defaultWriterReadyPromiseInitializeAsRejected(writer, reason);
        }
        function defaultWriterReadyPromiseResolve(writer) {
          if (writer._readyPromise_resolve === void 0) {
            return;
          }
          writer._readyPromise_resolve(void 0);
          writer._readyPromise_resolve = void 0;
          writer._readyPromise_reject = void 0;
          writer._readyPromiseState = "fulfilled";
        }
        const NativeDOMException = typeof DOMException !== "undefined" ? DOMException : void 0;
        function isDOMExceptionConstructor(ctor) {
          if (!(typeof ctor === "function" || typeof ctor === "object")) {
            return false;
          }
          try {
            new ctor();
            return true;
          } catch (_a) {
            return false;
          }
        }
        function createDOMExceptionPolyfill() {
          const ctor = function DOMException2(message, name) {
            this.message = message || "";
            this.name = name || "Error";
            if (Error.captureStackTrace) {
              Error.captureStackTrace(this, this.constructor);
            }
          };
          ctor.prototype = Object.create(Error.prototype);
          Object.defineProperty(ctor.prototype, "constructor", { value: ctor, writable: true, configurable: true });
          return ctor;
        }
        const DOMException$1 = isDOMExceptionConstructor(NativeDOMException) ? NativeDOMException : createDOMExceptionPolyfill();
        function ReadableStreamPipeTo(source, dest, preventClose, preventAbort, preventCancel, signal) {
          const reader = AcquireReadableStreamDefaultReader(source);
          const writer = AcquireWritableStreamDefaultWriter(dest);
          source._disturbed = true;
          let shuttingDown = false;
          let currentWrite = promiseResolvedWith(void 0);
          return newPromise((resolve2, reject) => {
            let abortAlgorithm;
            if (signal !== void 0) {
              abortAlgorithm = () => {
                const error2 = new DOMException$1("Aborted", "AbortError");
                const actions = [];
                if (!preventAbort) {
                  actions.push(() => {
                    if (dest._state === "writable") {
                      return WritableStreamAbort(dest, error2);
                    }
                    return promiseResolvedWith(void 0);
                  });
                }
                if (!preventCancel) {
                  actions.push(() => {
                    if (source._state === "readable") {
                      return ReadableStreamCancel(source, error2);
                    }
                    return promiseResolvedWith(void 0);
                  });
                }
                shutdownWithAction(() => Promise.all(actions.map((action) => action())), true, error2);
              };
              if (signal.aborted) {
                abortAlgorithm();
                return;
              }
              signal.addEventListener("abort", abortAlgorithm);
            }
            function pipeLoop() {
              return newPromise((resolveLoop, rejectLoop) => {
                function next(done) {
                  if (done) {
                    resolveLoop();
                  } else {
                    PerformPromiseThen(pipeStep(), next, rejectLoop);
                  }
                }
                next(false);
              });
            }
            function pipeStep() {
              if (shuttingDown) {
                return promiseResolvedWith(true);
              }
              return PerformPromiseThen(writer._readyPromise, () => {
                return newPromise((resolveRead, rejectRead) => {
                  ReadableStreamDefaultReaderRead(reader, {
                    _chunkSteps: (chunk) => {
                      currentWrite = PerformPromiseThen(WritableStreamDefaultWriterWrite(writer, chunk), void 0, noop2);
                      resolveRead(false);
                    },
                    _closeSteps: () => resolveRead(true),
                    _errorSteps: rejectRead
                  });
                });
              });
            }
            isOrBecomesErrored(source, reader._closedPromise, (storedError) => {
              if (!preventAbort) {
                shutdownWithAction(() => WritableStreamAbort(dest, storedError), true, storedError);
              } else {
                shutdown(true, storedError);
              }
            });
            isOrBecomesErrored(dest, writer._closedPromise, (storedError) => {
              if (!preventCancel) {
                shutdownWithAction(() => ReadableStreamCancel(source, storedError), true, storedError);
              } else {
                shutdown(true, storedError);
              }
            });
            isOrBecomesClosed(source, reader._closedPromise, () => {
              if (!preventClose) {
                shutdownWithAction(() => WritableStreamDefaultWriterCloseWithErrorPropagation(writer));
              } else {
                shutdown();
              }
            });
            if (WritableStreamCloseQueuedOrInFlight(dest) || dest._state === "closed") {
              const destClosed = new TypeError("the destination writable stream closed before all data could be piped to it");
              if (!preventCancel) {
                shutdownWithAction(() => ReadableStreamCancel(source, destClosed), true, destClosed);
              } else {
                shutdown(true, destClosed);
              }
            }
            setPromiseIsHandledToTrue(pipeLoop());
            function waitForWritesToFinish() {
              const oldCurrentWrite = currentWrite;
              return PerformPromiseThen(currentWrite, () => oldCurrentWrite !== currentWrite ? waitForWritesToFinish() : void 0);
            }
            function isOrBecomesErrored(stream, promise, action) {
              if (stream._state === "errored") {
                action(stream._storedError);
              } else {
                uponRejection(promise, action);
              }
            }
            function isOrBecomesClosed(stream, promise, action) {
              if (stream._state === "closed") {
                action();
              } else {
                uponFulfillment(promise, action);
              }
            }
            function shutdownWithAction(action, originalIsError, originalError) {
              if (shuttingDown) {
                return;
              }
              shuttingDown = true;
              if (dest._state === "writable" && !WritableStreamCloseQueuedOrInFlight(dest)) {
                uponFulfillment(waitForWritesToFinish(), doTheRest);
              } else {
                doTheRest();
              }
              function doTheRest() {
                uponPromise(action(), () => finalize(originalIsError, originalError), (newError) => finalize(true, newError));
              }
            }
            function shutdown(isError, error2) {
              if (shuttingDown) {
                return;
              }
              shuttingDown = true;
              if (dest._state === "writable" && !WritableStreamCloseQueuedOrInFlight(dest)) {
                uponFulfillment(waitForWritesToFinish(), () => finalize(isError, error2));
              } else {
                finalize(isError, error2);
              }
            }
            function finalize(isError, error2) {
              WritableStreamDefaultWriterRelease(writer);
              ReadableStreamReaderGenericRelease(reader);
              if (signal !== void 0) {
                signal.removeEventListener("abort", abortAlgorithm);
              }
              if (isError) {
                reject(error2);
              } else {
                resolve2(void 0);
              }
            }
          });
        }
        class ReadableStreamDefaultController {
          constructor() {
            throw new TypeError("Illegal constructor");
          }
          get desiredSize() {
            if (!IsReadableStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException$1("desiredSize");
            }
            return ReadableStreamDefaultControllerGetDesiredSize(this);
          }
          close() {
            if (!IsReadableStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException$1("close");
            }
            if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {
              throw new TypeError("The stream is not in a state that permits close");
            }
            ReadableStreamDefaultControllerClose(this);
          }
          enqueue(chunk = void 0) {
            if (!IsReadableStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException$1("enqueue");
            }
            if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {
              throw new TypeError("The stream is not in a state that permits enqueue");
            }
            return ReadableStreamDefaultControllerEnqueue(this, chunk);
          }
          error(e = void 0) {
            if (!IsReadableStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException$1("error");
            }
            ReadableStreamDefaultControllerError(this, e);
          }
          [CancelSteps](reason) {
            ResetQueue(this);
            const result = this._cancelAlgorithm(reason);
            ReadableStreamDefaultControllerClearAlgorithms(this);
            return result;
          }
          [PullSteps](readRequest) {
            const stream = this._controlledReadableStream;
            if (this._queue.length > 0) {
              const chunk = DequeueValue(this);
              if (this._closeRequested && this._queue.length === 0) {
                ReadableStreamDefaultControllerClearAlgorithms(this);
                ReadableStreamClose(stream);
              } else {
                ReadableStreamDefaultControllerCallPullIfNeeded(this);
              }
              readRequest._chunkSteps(chunk);
            } else {
              ReadableStreamAddReadRequest(stream, readRequest);
              ReadableStreamDefaultControllerCallPullIfNeeded(this);
            }
          }
        }
        Object.defineProperties(ReadableStreamDefaultController.prototype, {
          close: { enumerable: true },
          enqueue: { enumerable: true },
          error: { enumerable: true },
          desiredSize: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(ReadableStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {
            value: "ReadableStreamDefaultController",
            configurable: true
          });
        }
        function IsReadableStreamDefaultController(x) {
          if (!typeIsObject(x)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x, "_controlledReadableStream")) {
            return false;
          }
          return x instanceof ReadableStreamDefaultController;
        }
        function ReadableStreamDefaultControllerCallPullIfNeeded(controller) {
          const shouldPull = ReadableStreamDefaultControllerShouldCallPull(controller);
          if (!shouldPull) {
            return;
          }
          if (controller._pulling) {
            controller._pullAgain = true;
            return;
          }
          controller._pulling = true;
          const pullPromise = controller._pullAlgorithm();
          uponPromise(pullPromise, () => {
            controller._pulling = false;
            if (controller._pullAgain) {
              controller._pullAgain = false;
              ReadableStreamDefaultControllerCallPullIfNeeded(controller);
            }
          }, (e) => {
            ReadableStreamDefaultControllerError(controller, e);
          });
        }
        function ReadableStreamDefaultControllerShouldCallPull(controller) {
          const stream = controller._controlledReadableStream;
          if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
            return false;
          }
          if (!controller._started) {
            return false;
          }
          if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {
            return true;
          }
          const desiredSize = ReadableStreamDefaultControllerGetDesiredSize(controller);
          if (desiredSize > 0) {
            return true;
          }
          return false;
        }
        function ReadableStreamDefaultControllerClearAlgorithms(controller) {
          controller._pullAlgorithm = void 0;
          controller._cancelAlgorithm = void 0;
          controller._strategySizeAlgorithm = void 0;
        }
        function ReadableStreamDefaultControllerClose(controller) {
          if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
            return;
          }
          const stream = controller._controlledReadableStream;
          controller._closeRequested = true;
          if (controller._queue.length === 0) {
            ReadableStreamDefaultControllerClearAlgorithms(controller);
            ReadableStreamClose(stream);
          }
        }
        function ReadableStreamDefaultControllerEnqueue(controller, chunk) {
          if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
            return;
          }
          const stream = controller._controlledReadableStream;
          if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {
            ReadableStreamFulfillReadRequest(stream, chunk, false);
          } else {
            let chunkSize;
            try {
              chunkSize = controller._strategySizeAlgorithm(chunk);
            } catch (chunkSizeE) {
              ReadableStreamDefaultControllerError(controller, chunkSizeE);
              throw chunkSizeE;
            }
            try {
              EnqueueValueWithSize(controller, chunk, chunkSize);
            } catch (enqueueE) {
              ReadableStreamDefaultControllerError(controller, enqueueE);
              throw enqueueE;
            }
          }
          ReadableStreamDefaultControllerCallPullIfNeeded(controller);
        }
        function ReadableStreamDefaultControllerError(controller, e) {
          const stream = controller._controlledReadableStream;
          if (stream._state !== "readable") {
            return;
          }
          ResetQueue(controller);
          ReadableStreamDefaultControllerClearAlgorithms(controller);
          ReadableStreamError(stream, e);
        }
        function ReadableStreamDefaultControllerGetDesiredSize(controller) {
          const state = controller._controlledReadableStream._state;
          if (state === "errored") {
            return null;
          }
          if (state === "closed") {
            return 0;
          }
          return controller._strategyHWM - controller._queueTotalSize;
        }
        function ReadableStreamDefaultControllerHasBackpressure(controller) {
          if (ReadableStreamDefaultControllerShouldCallPull(controller)) {
            return false;
          }
          return true;
        }
        function ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) {
          const state = controller._controlledReadableStream._state;
          if (!controller._closeRequested && state === "readable") {
            return true;
          }
          return false;
        }
        function SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm) {
          controller._controlledReadableStream = stream;
          controller._queue = void 0;
          controller._queueTotalSize = void 0;
          ResetQueue(controller);
          controller._started = false;
          controller._closeRequested = false;
          controller._pullAgain = false;
          controller._pulling = false;
          controller._strategySizeAlgorithm = sizeAlgorithm;
          controller._strategyHWM = highWaterMark;
          controller._pullAlgorithm = pullAlgorithm;
          controller._cancelAlgorithm = cancelAlgorithm;
          stream._readableStreamController = controller;
          const startResult = startAlgorithm();
          uponPromise(promiseResolvedWith(startResult), () => {
            controller._started = true;
            ReadableStreamDefaultControllerCallPullIfNeeded(controller);
          }, (r) => {
            ReadableStreamDefaultControllerError(controller, r);
          });
        }
        function SetUpReadableStreamDefaultControllerFromUnderlyingSource(stream, underlyingSource, highWaterMark, sizeAlgorithm) {
          const controller = Object.create(ReadableStreamDefaultController.prototype);
          let startAlgorithm = () => void 0;
          let pullAlgorithm = () => promiseResolvedWith(void 0);
          let cancelAlgorithm = () => promiseResolvedWith(void 0);
          if (underlyingSource.start !== void 0) {
            startAlgorithm = () => underlyingSource.start(controller);
          }
          if (underlyingSource.pull !== void 0) {
            pullAlgorithm = () => underlyingSource.pull(controller);
          }
          if (underlyingSource.cancel !== void 0) {
            cancelAlgorithm = (reason) => underlyingSource.cancel(reason);
          }
          SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);
        }
        function defaultControllerBrandCheckException$1(name) {
          return new TypeError(`ReadableStreamDefaultController.prototype.${name} can only be used on a ReadableStreamDefaultController`);
        }
        function ReadableStreamTee(stream, cloneForBranch2) {
          if (IsReadableByteStreamController(stream._readableStreamController)) {
            return ReadableByteStreamTee(stream);
          }
          return ReadableStreamDefaultTee(stream);
        }
        function ReadableStreamDefaultTee(stream, cloneForBranch2) {
          const reader = AcquireReadableStreamDefaultReader(stream);
          let reading = false;
          let canceled1 = false;
          let canceled2 = false;
          let reason1;
          let reason2;
          let branch1;
          let branch2;
          let resolveCancelPromise;
          const cancelPromise = newPromise((resolve2) => {
            resolveCancelPromise = resolve2;
          });
          function pullAlgorithm() {
            if (reading) {
              return promiseResolvedWith(void 0);
            }
            reading = true;
            const readRequest = {
              _chunkSteps: (chunk) => {
                queueMicrotask(() => {
                  reading = false;
                  const chunk1 = chunk;
                  const chunk2 = chunk;
                  if (!canceled1) {
                    ReadableStreamDefaultControllerEnqueue(branch1._readableStreamController, chunk1);
                  }
                  if (!canceled2) {
                    ReadableStreamDefaultControllerEnqueue(branch2._readableStreamController, chunk2);
                  }
                });
              },
              _closeSteps: () => {
                reading = false;
                if (!canceled1) {
                  ReadableStreamDefaultControllerClose(branch1._readableStreamController);
                }
                if (!canceled2) {
                  ReadableStreamDefaultControllerClose(branch2._readableStreamController);
                }
                if (!canceled1 || !canceled2) {
                  resolveCancelPromise(void 0);
                }
              },
              _errorSteps: () => {
                reading = false;
              }
            };
            ReadableStreamDefaultReaderRead(reader, readRequest);
            return promiseResolvedWith(void 0);
          }
          function cancel1Algorithm(reason) {
            canceled1 = true;
            reason1 = reason;
            if (canceled2) {
              const compositeReason = CreateArrayFromList([reason1, reason2]);
              const cancelResult = ReadableStreamCancel(stream, compositeReason);
              resolveCancelPromise(cancelResult);
            }
            return cancelPromise;
          }
          function cancel2Algorithm(reason) {
            canceled2 = true;
            reason2 = reason;
            if (canceled1) {
              const compositeReason = CreateArrayFromList([reason1, reason2]);
              const cancelResult = ReadableStreamCancel(stream, compositeReason);
              resolveCancelPromise(cancelResult);
            }
            return cancelPromise;
          }
          function startAlgorithm() {
          }
          branch1 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel1Algorithm);
          branch2 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel2Algorithm);
          uponRejection(reader._closedPromise, (r) => {
            ReadableStreamDefaultControllerError(branch1._readableStreamController, r);
            ReadableStreamDefaultControllerError(branch2._readableStreamController, r);
            if (!canceled1 || !canceled2) {
              resolveCancelPromise(void 0);
            }
          });
          return [branch1, branch2];
        }
        function ReadableByteStreamTee(stream) {
          let reader = AcquireReadableStreamDefaultReader(stream);
          let reading = false;
          let canceled1 = false;
          let canceled2 = false;
          let reason1;
          let reason2;
          let branch1;
          let branch2;
          let resolveCancelPromise;
          const cancelPromise = newPromise((resolve2) => {
            resolveCancelPromise = resolve2;
          });
          function forwardReaderError(thisReader) {
            uponRejection(thisReader._closedPromise, (r) => {
              if (thisReader !== reader) {
                return;
              }
              ReadableByteStreamControllerError(branch1._readableStreamController, r);
              ReadableByteStreamControllerError(branch2._readableStreamController, r);
              if (!canceled1 || !canceled2) {
                resolveCancelPromise(void 0);
              }
            });
          }
          function pullWithDefaultReader() {
            if (IsReadableStreamBYOBReader(reader)) {
              ReadableStreamReaderGenericRelease(reader);
              reader = AcquireReadableStreamDefaultReader(stream);
              forwardReaderError(reader);
            }
            const readRequest = {
              _chunkSteps: (chunk) => {
                queueMicrotask(() => {
                  reading = false;
                  const chunk1 = chunk;
                  let chunk2 = chunk;
                  if (!canceled1 && !canceled2) {
                    try {
                      chunk2 = CloneAsUint8Array(chunk);
                    } catch (cloneE) {
                      ReadableByteStreamControllerError(branch1._readableStreamController, cloneE);
                      ReadableByteStreamControllerError(branch2._readableStreamController, cloneE);
                      resolveCancelPromise(ReadableStreamCancel(stream, cloneE));
                      return;
                    }
                  }
                  if (!canceled1) {
                    ReadableByteStreamControllerEnqueue(branch1._readableStreamController, chunk1);
                  }
                  if (!canceled2) {
                    ReadableByteStreamControllerEnqueue(branch2._readableStreamController, chunk2);
                  }
                });
              },
              _closeSteps: () => {
                reading = false;
                if (!canceled1) {
                  ReadableByteStreamControllerClose(branch1._readableStreamController);
                }
                if (!canceled2) {
                  ReadableByteStreamControllerClose(branch2._readableStreamController);
                }
                if (branch1._readableStreamController._pendingPullIntos.length > 0) {
                  ReadableByteStreamControllerRespond(branch1._readableStreamController, 0);
                }
                if (branch2._readableStreamController._pendingPullIntos.length > 0) {
                  ReadableByteStreamControllerRespond(branch2._readableStreamController, 0);
                }
                if (!canceled1 || !canceled2) {
                  resolveCancelPromise(void 0);
                }
              },
              _errorSteps: () => {
                reading = false;
              }
            };
            ReadableStreamDefaultReaderRead(reader, readRequest);
          }
          function pullWithBYOBReader(view, forBranch2) {
            if (IsReadableStreamDefaultReader(reader)) {
              ReadableStreamReaderGenericRelease(reader);
              reader = AcquireReadableStreamBYOBReader(stream);
              forwardReaderError(reader);
            }
            const byobBranch = forBranch2 ? branch2 : branch1;
            const otherBranch = forBranch2 ? branch1 : branch2;
            const readIntoRequest = {
              _chunkSteps: (chunk) => {
                queueMicrotask(() => {
                  reading = false;
                  const byobCanceled = forBranch2 ? canceled2 : canceled1;
                  const otherCanceled = forBranch2 ? canceled1 : canceled2;
                  if (!otherCanceled) {
                    let clonedChunk;
                    try {
                      clonedChunk = CloneAsUint8Array(chunk);
                    } catch (cloneE) {
                      ReadableByteStreamControllerError(byobBranch._readableStreamController, cloneE);
                      ReadableByteStreamControllerError(otherBranch._readableStreamController, cloneE);
                      resolveCancelPromise(ReadableStreamCancel(stream, cloneE));
                      return;
                    }
                    if (!byobCanceled) {
                      ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
                    }
                    ReadableByteStreamControllerEnqueue(otherBranch._readableStreamController, clonedChunk);
                  } else if (!byobCanceled) {
                    ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
                  }
                });
              },
              _closeSteps: (chunk) => {
                reading = false;
                const byobCanceled = forBranch2 ? canceled2 : canceled1;
                const otherCanceled = forBranch2 ? canceled1 : canceled2;
                if (!byobCanceled) {
                  ReadableByteStreamControllerClose(byobBranch._readableStreamController);
                }
                if (!otherCanceled) {
                  ReadableByteStreamControllerClose(otherBranch._readableStreamController);
                }
                if (chunk !== void 0) {
                  if (!byobCanceled) {
                    ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
                  }
                  if (!otherCanceled && otherBranch._readableStreamController._pendingPullIntos.length > 0) {
                    ReadableByteStreamControllerRespond(otherBranch._readableStreamController, 0);
                  }
                }
                if (!byobCanceled || !otherCanceled) {
                  resolveCancelPromise(void 0);
                }
              },
              _errorSteps: () => {
                reading = false;
              }
            };
            ReadableStreamBYOBReaderRead(reader, view, readIntoRequest);
          }
          function pull1Algorithm() {
            if (reading) {
              return promiseResolvedWith(void 0);
            }
            reading = true;
            const byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch1._readableStreamController);
            if (byobRequest === null) {
              pullWithDefaultReader();
            } else {
              pullWithBYOBReader(byobRequest._view, false);
            }
            return promiseResolvedWith(void 0);
          }
          function pull2Algorithm() {
            if (reading) {
              return promiseResolvedWith(void 0);
            }
            reading = true;
            const byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch2._readableStreamController);
            if (byobRequest === null) {
              pullWithDefaultReader();
            } else {
              pullWithBYOBReader(byobRequest._view, true);
            }
            return promiseResolvedWith(void 0);
          }
          function cancel1Algorithm(reason) {
            canceled1 = true;
            reason1 = reason;
            if (canceled2) {
              const compositeReason = CreateArrayFromList([reason1, reason2]);
              const cancelResult = ReadableStreamCancel(stream, compositeReason);
              resolveCancelPromise(cancelResult);
            }
            return cancelPromise;
          }
          function cancel2Algorithm(reason) {
            canceled2 = true;
            reason2 = reason;
            if (canceled1) {
              const compositeReason = CreateArrayFromList([reason1, reason2]);
              const cancelResult = ReadableStreamCancel(stream, compositeReason);
              resolveCancelPromise(cancelResult);
            }
            return cancelPromise;
          }
          function startAlgorithm() {
            return;
          }
          branch1 = CreateReadableByteStream(startAlgorithm, pull1Algorithm, cancel1Algorithm);
          branch2 = CreateReadableByteStream(startAlgorithm, pull2Algorithm, cancel2Algorithm);
          forwardReaderError(reader);
          return [branch1, branch2];
        }
        function convertUnderlyingDefaultOrByteSource(source, context) {
          assertDictionary(source, context);
          const original = source;
          const autoAllocateChunkSize = original === null || original === void 0 ? void 0 : original.autoAllocateChunkSize;
          const cancel = original === null || original === void 0 ? void 0 : original.cancel;
          const pull = original === null || original === void 0 ? void 0 : original.pull;
          const start = original === null || original === void 0 ? void 0 : original.start;
          const type = original === null || original === void 0 ? void 0 : original.type;
          return {
            autoAllocateChunkSize: autoAllocateChunkSize === void 0 ? void 0 : convertUnsignedLongLongWithEnforceRange(autoAllocateChunkSize, `${context} has member 'autoAllocateChunkSize' that`),
            cancel: cancel === void 0 ? void 0 : convertUnderlyingSourceCancelCallback(cancel, original, `${context} has member 'cancel' that`),
            pull: pull === void 0 ? void 0 : convertUnderlyingSourcePullCallback(pull, original, `${context} has member 'pull' that`),
            start: start === void 0 ? void 0 : convertUnderlyingSourceStartCallback(start, original, `${context} has member 'start' that`),
            type: type === void 0 ? void 0 : convertReadableStreamType(type, `${context} has member 'type' that`)
          };
        }
        function convertUnderlyingSourceCancelCallback(fn, original, context) {
          assertFunction(fn, context);
          return (reason) => promiseCall(fn, original, [reason]);
        }
        function convertUnderlyingSourcePullCallback(fn, original, context) {
          assertFunction(fn, context);
          return (controller) => promiseCall(fn, original, [controller]);
        }
        function convertUnderlyingSourceStartCallback(fn, original, context) {
          assertFunction(fn, context);
          return (controller) => reflectCall(fn, original, [controller]);
        }
        function convertReadableStreamType(type, context) {
          type = `${type}`;
          if (type !== "bytes") {
            throw new TypeError(`${context} '${type}' is not a valid enumeration value for ReadableStreamType`);
          }
          return type;
        }
        function convertReaderOptions(options2, context) {
          assertDictionary(options2, context);
          const mode = options2 === null || options2 === void 0 ? void 0 : options2.mode;
          return {
            mode: mode === void 0 ? void 0 : convertReadableStreamReaderMode(mode, `${context} has member 'mode' that`)
          };
        }
        function convertReadableStreamReaderMode(mode, context) {
          mode = `${mode}`;
          if (mode !== "byob") {
            throw new TypeError(`${context} '${mode}' is not a valid enumeration value for ReadableStreamReaderMode`);
          }
          return mode;
        }
        function convertIteratorOptions(options2, context) {
          assertDictionary(options2, context);
          const preventCancel = options2 === null || options2 === void 0 ? void 0 : options2.preventCancel;
          return { preventCancel: Boolean(preventCancel) };
        }
        function convertPipeOptions(options2, context) {
          assertDictionary(options2, context);
          const preventAbort = options2 === null || options2 === void 0 ? void 0 : options2.preventAbort;
          const preventCancel = options2 === null || options2 === void 0 ? void 0 : options2.preventCancel;
          const preventClose = options2 === null || options2 === void 0 ? void 0 : options2.preventClose;
          const signal = options2 === null || options2 === void 0 ? void 0 : options2.signal;
          if (signal !== void 0) {
            assertAbortSignal(signal, `${context} has member 'signal' that`);
          }
          return {
            preventAbort: Boolean(preventAbort),
            preventCancel: Boolean(preventCancel),
            preventClose: Boolean(preventClose),
            signal
          };
        }
        function assertAbortSignal(signal, context) {
          if (!isAbortSignal2(signal)) {
            throw new TypeError(`${context} is not an AbortSignal.`);
          }
        }
        function convertReadableWritablePair(pair, context) {
          assertDictionary(pair, context);
          const readable = pair === null || pair === void 0 ? void 0 : pair.readable;
          assertRequiredField(readable, "readable", "ReadableWritablePair");
          assertReadableStream(readable, `${context} has member 'readable' that`);
          const writable2 = pair === null || pair === void 0 ? void 0 : pair.writable;
          assertRequiredField(writable2, "writable", "ReadableWritablePair");
          assertWritableStream(writable2, `${context} has member 'writable' that`);
          return { readable, writable: writable2 };
        }
        class ReadableStream2 {
          constructor(rawUnderlyingSource = {}, rawStrategy = {}) {
            if (rawUnderlyingSource === void 0) {
              rawUnderlyingSource = null;
            } else {
              assertObject(rawUnderlyingSource, "First parameter");
            }
            const strategy = convertQueuingStrategy(rawStrategy, "Second parameter");
            const underlyingSource = convertUnderlyingDefaultOrByteSource(rawUnderlyingSource, "First parameter");
            InitializeReadableStream(this);
            if (underlyingSource.type === "bytes") {
              if (strategy.size !== void 0) {
                throw new RangeError("The strategy for a byte stream cannot have a size function");
              }
              const highWaterMark = ExtractHighWaterMark(strategy, 0);
              SetUpReadableByteStreamControllerFromUnderlyingSource(this, underlyingSource, highWaterMark);
            } else {
              const sizeAlgorithm = ExtractSizeAlgorithm(strategy);
              const highWaterMark = ExtractHighWaterMark(strategy, 1);
              SetUpReadableStreamDefaultControllerFromUnderlyingSource(this, underlyingSource, highWaterMark, sizeAlgorithm);
            }
          }
          get locked() {
            if (!IsReadableStream(this)) {
              throw streamBrandCheckException$1("locked");
            }
            return IsReadableStreamLocked(this);
          }
          cancel(reason = void 0) {
            if (!IsReadableStream(this)) {
              return promiseRejectedWith(streamBrandCheckException$1("cancel"));
            }
            if (IsReadableStreamLocked(this)) {
              return promiseRejectedWith(new TypeError("Cannot cancel a stream that already has a reader"));
            }
            return ReadableStreamCancel(this, reason);
          }
          getReader(rawOptions = void 0) {
            if (!IsReadableStream(this)) {
              throw streamBrandCheckException$1("getReader");
            }
            const options2 = convertReaderOptions(rawOptions, "First parameter");
            if (options2.mode === void 0) {
              return AcquireReadableStreamDefaultReader(this);
            }
            return AcquireReadableStreamBYOBReader(this);
          }
          pipeThrough(rawTransform, rawOptions = {}) {
            if (!IsReadableStream(this)) {
              throw streamBrandCheckException$1("pipeThrough");
            }
            assertRequiredArgument(rawTransform, 1, "pipeThrough");
            const transform = convertReadableWritablePair(rawTransform, "First parameter");
            const options2 = convertPipeOptions(rawOptions, "Second parameter");
            if (IsReadableStreamLocked(this)) {
              throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream");
            }
            if (IsWritableStreamLocked(transform.writable)) {
              throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream");
            }
            const promise = ReadableStreamPipeTo(this, transform.writable, options2.preventClose, options2.preventAbort, options2.preventCancel, options2.signal);
            setPromiseIsHandledToTrue(promise);
            return transform.readable;
          }
          pipeTo(destination, rawOptions = {}) {
            if (!IsReadableStream(this)) {
              return promiseRejectedWith(streamBrandCheckException$1("pipeTo"));
            }
            if (destination === void 0) {
              return promiseRejectedWith(`Parameter 1 is required in 'pipeTo'.`);
            }
            if (!IsWritableStream(destination)) {
              return promiseRejectedWith(new TypeError(`ReadableStream.prototype.pipeTo's first argument must be a WritableStream`));
            }
            let options2;
            try {
              options2 = convertPipeOptions(rawOptions, "Second parameter");
            } catch (e) {
              return promiseRejectedWith(e);
            }
            if (IsReadableStreamLocked(this)) {
              return promiseRejectedWith(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream"));
            }
            if (IsWritableStreamLocked(destination)) {
              return promiseRejectedWith(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream"));
            }
            return ReadableStreamPipeTo(this, destination, options2.preventClose, options2.preventAbort, options2.preventCancel, options2.signal);
          }
          tee() {
            if (!IsReadableStream(this)) {
              throw streamBrandCheckException$1("tee");
            }
            const branches = ReadableStreamTee(this);
            return CreateArrayFromList(branches);
          }
          values(rawOptions = void 0) {
            if (!IsReadableStream(this)) {
              throw streamBrandCheckException$1("values");
            }
            const options2 = convertIteratorOptions(rawOptions, "First parameter");
            return AcquireReadableStreamAsyncIterator(this, options2.preventCancel);
          }
        }
        Object.defineProperties(ReadableStream2.prototype, {
          cancel: { enumerable: true },
          getReader: { enumerable: true },
          pipeThrough: { enumerable: true },
          pipeTo: { enumerable: true },
          tee: { enumerable: true },
          values: { enumerable: true },
          locked: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(ReadableStream2.prototype, SymbolPolyfill.toStringTag, {
            value: "ReadableStream",
            configurable: true
          });
        }
        if (typeof SymbolPolyfill.asyncIterator === "symbol") {
          Object.defineProperty(ReadableStream2.prototype, SymbolPolyfill.asyncIterator, {
            value: ReadableStream2.prototype.values,
            writable: true,
            configurable: true
          });
        }
        function CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark = 1, sizeAlgorithm = () => 1) {
          const stream = Object.create(ReadableStream2.prototype);
          InitializeReadableStream(stream);
          const controller = Object.create(ReadableStreamDefaultController.prototype);
          SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);
          return stream;
        }
        function CreateReadableByteStream(startAlgorithm, pullAlgorithm, cancelAlgorithm) {
          const stream = Object.create(ReadableStream2.prototype);
          InitializeReadableStream(stream);
          const controller = Object.create(ReadableByteStreamController.prototype);
          SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, 0, void 0);
          return stream;
        }
        function InitializeReadableStream(stream) {
          stream._state = "readable";
          stream._reader = void 0;
          stream._storedError = void 0;
          stream._disturbed = false;
        }
        function IsReadableStream(x) {
          if (!typeIsObject(x)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x, "_readableStreamController")) {
            return false;
          }
          return x instanceof ReadableStream2;
        }
        function IsReadableStreamLocked(stream) {
          if (stream._reader === void 0) {
            return false;
          }
          return true;
        }
        function ReadableStreamCancel(stream, reason) {
          stream._disturbed = true;
          if (stream._state === "closed") {
            return promiseResolvedWith(void 0);
          }
          if (stream._state === "errored") {
            return promiseRejectedWith(stream._storedError);
          }
          ReadableStreamClose(stream);
          const reader = stream._reader;
          if (reader !== void 0 && IsReadableStreamBYOBReader(reader)) {
            reader._readIntoRequests.forEach((readIntoRequest) => {
              readIntoRequest._closeSteps(void 0);
            });
            reader._readIntoRequests = new SimpleQueue();
          }
          const sourceCancelPromise = stream._readableStreamController[CancelSteps](reason);
          return transformPromiseWith(sourceCancelPromise, noop2);
        }
        function ReadableStreamClose(stream) {
          stream._state = "closed";
          const reader = stream._reader;
          if (reader === void 0) {
            return;
          }
          defaultReaderClosedPromiseResolve(reader);
          if (IsReadableStreamDefaultReader(reader)) {
            reader._readRequests.forEach((readRequest) => {
              readRequest._closeSteps();
            });
            reader._readRequests = new SimpleQueue();
          }
        }
        function ReadableStreamError(stream, e) {
          stream._state = "errored";
          stream._storedError = e;
          const reader = stream._reader;
          if (reader === void 0) {
            return;
          }
          defaultReaderClosedPromiseReject(reader, e);
          if (IsReadableStreamDefaultReader(reader)) {
            reader._readRequests.forEach((readRequest) => {
              readRequest._errorSteps(e);
            });
            reader._readRequests = new SimpleQueue();
          } else {
            reader._readIntoRequests.forEach((readIntoRequest) => {
              readIntoRequest._errorSteps(e);
            });
            reader._readIntoRequests = new SimpleQueue();
          }
        }
        function streamBrandCheckException$1(name) {
          return new TypeError(`ReadableStream.prototype.${name} can only be used on a ReadableStream`);
        }
        function convertQueuingStrategyInit(init2, context) {
          assertDictionary(init2, context);
          const highWaterMark = init2 === null || init2 === void 0 ? void 0 : init2.highWaterMark;
          assertRequiredField(highWaterMark, "highWaterMark", "QueuingStrategyInit");
          return {
            highWaterMark: convertUnrestrictedDouble(highWaterMark)
          };
        }
        const byteLengthSizeFunction = (chunk) => {
          return chunk.byteLength;
        };
        Object.defineProperty(byteLengthSizeFunction, "name", {
          value: "size",
          configurable: true
        });
        class ByteLengthQueuingStrategy {
          constructor(options2) {
            assertRequiredArgument(options2, 1, "ByteLengthQueuingStrategy");
            options2 = convertQueuingStrategyInit(options2, "First parameter");
            this._byteLengthQueuingStrategyHighWaterMark = options2.highWaterMark;
          }
          get highWaterMark() {
            if (!IsByteLengthQueuingStrategy(this)) {
              throw byteLengthBrandCheckException("highWaterMark");
            }
            return this._byteLengthQueuingStrategyHighWaterMark;
          }
          get size() {
            if (!IsByteLengthQueuingStrategy(this)) {
              throw byteLengthBrandCheckException("size");
            }
            return byteLengthSizeFunction;
          }
        }
        Object.defineProperties(ByteLengthQueuingStrategy.prototype, {
          highWaterMark: { enumerable: true },
          size: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(ByteLengthQueuingStrategy.prototype, SymbolPolyfill.toStringTag, {
            value: "ByteLengthQueuingStrategy",
            configurable: true
          });
        }
        function byteLengthBrandCheckException(name) {
          return new TypeError(`ByteLengthQueuingStrategy.prototype.${name} can only be used on a ByteLengthQueuingStrategy`);
        }
        function IsByteLengthQueuingStrategy(x) {
          if (!typeIsObject(x)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x, "_byteLengthQueuingStrategyHighWaterMark")) {
            return false;
          }
          return x instanceof ByteLengthQueuingStrategy;
        }
        const countSizeFunction = () => {
          return 1;
        };
        Object.defineProperty(countSizeFunction, "name", {
          value: "size",
          configurable: true
        });
        class CountQueuingStrategy {
          constructor(options2) {
            assertRequiredArgument(options2, 1, "CountQueuingStrategy");
            options2 = convertQueuingStrategyInit(options2, "First parameter");
            this._countQueuingStrategyHighWaterMark = options2.highWaterMark;
          }
          get highWaterMark() {
            if (!IsCountQueuingStrategy(this)) {
              throw countBrandCheckException("highWaterMark");
            }
            return this._countQueuingStrategyHighWaterMark;
          }
          get size() {
            if (!IsCountQueuingStrategy(this)) {
              throw countBrandCheckException("size");
            }
            return countSizeFunction;
          }
        }
        Object.defineProperties(CountQueuingStrategy.prototype, {
          highWaterMark: { enumerable: true },
          size: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(CountQueuingStrategy.prototype, SymbolPolyfill.toStringTag, {
            value: "CountQueuingStrategy",
            configurable: true
          });
        }
        function countBrandCheckException(name) {
          return new TypeError(`CountQueuingStrategy.prototype.${name} can only be used on a CountQueuingStrategy`);
        }
        function IsCountQueuingStrategy(x) {
          if (!typeIsObject(x)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x, "_countQueuingStrategyHighWaterMark")) {
            return false;
          }
          return x instanceof CountQueuingStrategy;
        }
        function convertTransformer(original, context) {
          assertDictionary(original, context);
          const flush = original === null || original === void 0 ? void 0 : original.flush;
          const readableType = original === null || original === void 0 ? void 0 : original.readableType;
          const start = original === null || original === void 0 ? void 0 : original.start;
          const transform = original === null || original === void 0 ? void 0 : original.transform;
          const writableType = original === null || original === void 0 ? void 0 : original.writableType;
          return {
            flush: flush === void 0 ? void 0 : convertTransformerFlushCallback(flush, original, `${context} has member 'flush' that`),
            readableType,
            start: start === void 0 ? void 0 : convertTransformerStartCallback(start, original, `${context} has member 'start' that`),
            transform: transform === void 0 ? void 0 : convertTransformerTransformCallback(transform, original, `${context} has member 'transform' that`),
            writableType
          };
        }
        function convertTransformerFlushCallback(fn, original, context) {
          assertFunction(fn, context);
          return (controller) => promiseCall(fn, original, [controller]);
        }
        function convertTransformerStartCallback(fn, original, context) {
          assertFunction(fn, context);
          return (controller) => reflectCall(fn, original, [controller]);
        }
        function convertTransformerTransformCallback(fn, original, context) {
          assertFunction(fn, context);
          return (chunk, controller) => promiseCall(fn, original, [chunk, controller]);
        }
        class TransformStream {
          constructor(rawTransformer = {}, rawWritableStrategy = {}, rawReadableStrategy = {}) {
            if (rawTransformer === void 0) {
              rawTransformer = null;
            }
            const writableStrategy = convertQueuingStrategy(rawWritableStrategy, "Second parameter");
            const readableStrategy = convertQueuingStrategy(rawReadableStrategy, "Third parameter");
            const transformer = convertTransformer(rawTransformer, "First parameter");
            if (transformer.readableType !== void 0) {
              throw new RangeError("Invalid readableType specified");
            }
            if (transformer.writableType !== void 0) {
              throw new RangeError("Invalid writableType specified");
            }
            const readableHighWaterMark = ExtractHighWaterMark(readableStrategy, 0);
            const readableSizeAlgorithm = ExtractSizeAlgorithm(readableStrategy);
            const writableHighWaterMark = ExtractHighWaterMark(writableStrategy, 1);
            const writableSizeAlgorithm = ExtractSizeAlgorithm(writableStrategy);
            let startPromise_resolve;
            const startPromise = newPromise((resolve2) => {
              startPromise_resolve = resolve2;
            });
            InitializeTransformStream(this, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm);
            SetUpTransformStreamDefaultControllerFromTransformer(this, transformer);
            if (transformer.start !== void 0) {
              startPromise_resolve(transformer.start(this._transformStreamController));
            } else {
              startPromise_resolve(void 0);
            }
          }
          get readable() {
            if (!IsTransformStream(this)) {
              throw streamBrandCheckException("readable");
            }
            return this._readable;
          }
          get writable() {
            if (!IsTransformStream(this)) {
              throw streamBrandCheckException("writable");
            }
            return this._writable;
          }
        }
        Object.defineProperties(TransformStream.prototype, {
          readable: { enumerable: true },
          writable: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(TransformStream.prototype, SymbolPolyfill.toStringTag, {
            value: "TransformStream",
            configurable: true
          });
        }
        function InitializeTransformStream(stream, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm) {
          function startAlgorithm() {
            return startPromise;
          }
          function writeAlgorithm(chunk) {
            return TransformStreamDefaultSinkWriteAlgorithm(stream, chunk);
          }
          function abortAlgorithm(reason) {
            return TransformStreamDefaultSinkAbortAlgorithm(stream, reason);
          }
          function closeAlgorithm() {
            return TransformStreamDefaultSinkCloseAlgorithm(stream);
          }
          stream._writable = CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, writableHighWaterMark, writableSizeAlgorithm);
          function pullAlgorithm() {
            return TransformStreamDefaultSourcePullAlgorithm(stream);
          }
          function cancelAlgorithm(reason) {
            TransformStreamErrorWritableAndUnblockWrite(stream, reason);
            return promiseResolvedWith(void 0);
          }
          stream._readable = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, readableHighWaterMark, readableSizeAlgorithm);
          stream._backpressure = void 0;
          stream._backpressureChangePromise = void 0;
          stream._backpressureChangePromise_resolve = void 0;
          TransformStreamSetBackpressure(stream, true);
          stream._transformStreamController = void 0;
        }
        function IsTransformStream(x) {
          if (!typeIsObject(x)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x, "_transformStreamController")) {
            return false;
          }
          return x instanceof TransformStream;
        }
        function TransformStreamError(stream, e) {
          ReadableStreamDefaultControllerError(stream._readable._readableStreamController, e);
          TransformStreamErrorWritableAndUnblockWrite(stream, e);
        }
        function TransformStreamErrorWritableAndUnblockWrite(stream, e) {
          TransformStreamDefaultControllerClearAlgorithms(stream._transformStreamController);
          WritableStreamDefaultControllerErrorIfNeeded(stream._writable._writableStreamController, e);
          if (stream._backpressure) {
            TransformStreamSetBackpressure(stream, false);
          }
        }
        function TransformStreamSetBackpressure(stream, backpressure) {
          if (stream._backpressureChangePromise !== void 0) {
            stream._backpressureChangePromise_resolve();
          }
          stream._backpressureChangePromise = newPromise((resolve2) => {
            stream._backpressureChangePromise_resolve = resolve2;
          });
          stream._backpressure = backpressure;
        }
        class TransformStreamDefaultController {
          constructor() {
            throw new TypeError("Illegal constructor");
          }
          get desiredSize() {
            if (!IsTransformStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException("desiredSize");
            }
            const readableController = this._controlledTransformStream._readable._readableStreamController;
            return ReadableStreamDefaultControllerGetDesiredSize(readableController);
          }
          enqueue(chunk = void 0) {
            if (!IsTransformStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException("enqueue");
            }
            TransformStreamDefaultControllerEnqueue(this, chunk);
          }
          error(reason = void 0) {
            if (!IsTransformStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException("error");
            }
            TransformStreamDefaultControllerError(this, reason);
          }
          terminate() {
            if (!IsTransformStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException("terminate");
            }
            TransformStreamDefaultControllerTerminate(this);
          }
        }
        Object.defineProperties(TransformStreamDefaultController.prototype, {
          enqueue: { enumerable: true },
          error: { enumerable: true },
          terminate: { enumerable: true },
          desiredSize: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(TransformStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {
            value: "TransformStreamDefaultController",
            configurable: true
          });
        }
        function IsTransformStreamDefaultController(x) {
          if (!typeIsObject(x)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x, "_controlledTransformStream")) {
            return false;
          }
          return x instanceof TransformStreamDefaultController;
        }
        function SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm) {
          controller._controlledTransformStream = stream;
          stream._transformStreamController = controller;
          controller._transformAlgorithm = transformAlgorithm;
          controller._flushAlgorithm = flushAlgorithm;
        }
        function SetUpTransformStreamDefaultControllerFromTransformer(stream, transformer) {
          const controller = Object.create(TransformStreamDefaultController.prototype);
          let transformAlgorithm = (chunk) => {
            try {
              TransformStreamDefaultControllerEnqueue(controller, chunk);
              return promiseResolvedWith(void 0);
            } catch (transformResultE) {
              return promiseRejectedWith(transformResultE);
            }
          };
          let flushAlgorithm = () => promiseResolvedWith(void 0);
          if (transformer.transform !== void 0) {
            transformAlgorithm = (chunk) => transformer.transform(chunk, controller);
          }
          if (transformer.flush !== void 0) {
            flushAlgorithm = () => transformer.flush(controller);
          }
          SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm);
        }
        function TransformStreamDefaultControllerClearAlgorithms(controller) {
          controller._transformAlgorithm = void 0;
          controller._flushAlgorithm = void 0;
        }
        function TransformStreamDefaultControllerEnqueue(controller, chunk) {
          const stream = controller._controlledTransformStream;
          const readableController = stream._readable._readableStreamController;
          if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController)) {
            throw new TypeError("Readable side is not in a state that permits enqueue");
          }
          try {
            ReadableStreamDefaultControllerEnqueue(readableController, chunk);
          } catch (e) {
            TransformStreamErrorWritableAndUnblockWrite(stream, e);
            throw stream._readable._storedError;
          }
          const backpressure = ReadableStreamDefaultControllerHasBackpressure(readableController);
          if (backpressure !== stream._backpressure) {
            TransformStreamSetBackpressure(stream, true);
          }
        }
        function TransformStreamDefaultControllerError(controller, e) {
          TransformStreamError(controller._controlledTransformStream, e);
        }
        function TransformStreamDefaultControllerPerformTransform(controller, chunk) {
          const transformPromise = controller._transformAlgorithm(chunk);
          return transformPromiseWith(transformPromise, void 0, (r) => {
            TransformStreamError(controller._controlledTransformStream, r);
            throw r;
          });
        }
        function TransformStreamDefaultControllerTerminate(controller) {
          const stream = controller._controlledTransformStream;
          const readableController = stream._readable._readableStreamController;
          ReadableStreamDefaultControllerClose(readableController);
          const error2 = new TypeError("TransformStream terminated");
          TransformStreamErrorWritableAndUnblockWrite(stream, error2);
        }
        function TransformStreamDefaultSinkWriteAlgorithm(stream, chunk) {
          const controller = stream._transformStreamController;
          if (stream._backpressure) {
            const backpressureChangePromise = stream._backpressureChangePromise;
            return transformPromiseWith(backpressureChangePromise, () => {
              const writable2 = stream._writable;
              const state = writable2._state;
              if (state === "erroring") {
                throw writable2._storedError;
              }
              return TransformStreamDefaultControllerPerformTransform(controller, chunk);
            });
          }
          return TransformStreamDefaultControllerPerformTransform(controller, chunk);
        }
        function TransformStreamDefaultSinkAbortAlgorithm(stream, reason) {
          TransformStreamError(stream, reason);
          return promiseResolvedWith(void 0);
        }
        function TransformStreamDefaultSinkCloseAlgorithm(stream) {
          const readable = stream._readable;
          const controller = stream._transformStreamController;
          const flushPromise = controller._flushAlgorithm();
          TransformStreamDefaultControllerClearAlgorithms(controller);
          return transformPromiseWith(flushPromise, () => {
            if (readable._state === "errored") {
              throw readable._storedError;
            }
            ReadableStreamDefaultControllerClose(readable._readableStreamController);
          }, (r) => {
            TransformStreamError(stream, r);
            throw readable._storedError;
          });
        }
        function TransformStreamDefaultSourcePullAlgorithm(stream) {
          TransformStreamSetBackpressure(stream, false);
          return stream._backpressureChangePromise;
        }
        function defaultControllerBrandCheckException(name) {
          return new TypeError(`TransformStreamDefaultController.prototype.${name} can only be used on a TransformStreamDefaultController`);
        }
        function streamBrandCheckException(name) {
          return new TypeError(`TransformStream.prototype.${name} can only be used on a TransformStream`);
        }
        exports2.ByteLengthQueuingStrategy = ByteLengthQueuingStrategy;
        exports2.CountQueuingStrategy = CountQueuingStrategy;
        exports2.ReadableByteStreamController = ReadableByteStreamController;
        exports2.ReadableStream = ReadableStream2;
        exports2.ReadableStreamBYOBReader = ReadableStreamBYOBReader;
        exports2.ReadableStreamBYOBRequest = ReadableStreamBYOBRequest;
        exports2.ReadableStreamDefaultController = ReadableStreamDefaultController;
        exports2.ReadableStreamDefaultReader = ReadableStreamDefaultReader;
        exports2.TransformStream = TransformStream;
        exports2.TransformStreamDefaultController = TransformStreamDefaultController;
        exports2.WritableStream = WritableStream;
        exports2.WritableStreamDefaultController = WritableStreamDefaultController;
        exports2.WritableStreamDefaultWriter = WritableStreamDefaultWriter;
        Object.defineProperty(exports2, "__esModule", { value: true });
      });
    })(ponyfill_es2018, ponyfill_es2018.exports);
    POOL_SIZE$1 = 65536;
    if (!globalThis.ReadableStream) {
      try {
        Object.assign(globalThis, require("stream/web"));
      } catch (error2) {
        Object.assign(globalThis, ponyfill_es2018.exports);
      }
    }
    try {
      const { Blob: Blob3 } = require("buffer");
      if (Blob3 && !Blob3.prototype.stream) {
        Blob3.prototype.stream = function name(params) {
          let position = 0;
          const blob = this;
          return new ReadableStream({
            type: "bytes",
            async pull(ctrl) {
              const chunk = blob.slice(position, Math.min(blob.size, position + POOL_SIZE$1));
              const buffer = await chunk.arrayBuffer();
              position += buffer.byteLength;
              ctrl.enqueue(new Uint8Array(buffer));
              if (position === blob.size) {
                ctrl.close();
              }
            }
          });
        };
      }
    } catch (error2) {
    }
    POOL_SIZE = 65536;
    _Blob = class Blob {
      #parts = [];
      #type = "";
      #size = 0;
      constructor(blobParts = [], options2 = {}) {
        let size = 0;
        const parts = blobParts.map((element) => {
          let part;
          if (ArrayBuffer.isView(element)) {
            part = new Uint8Array(element.buffer.slice(element.byteOffset, element.byteOffset + element.byteLength));
          } else if (element instanceof ArrayBuffer) {
            part = new Uint8Array(element.slice(0));
          } else if (element instanceof Blob) {
            part = element;
          } else {
            part = new TextEncoder().encode(element);
          }
          size += ArrayBuffer.isView(part) ? part.byteLength : part.size;
          return part;
        });
        const type = options2.type === void 0 ? "" : String(options2.type);
        this.#type = /[^\u0020-\u007E]/.test(type) ? "" : type;
        this.#size = size;
        this.#parts = parts;
      }
      get size() {
        return this.#size;
      }
      get type() {
        return this.#type;
      }
      async text() {
        const decoder = new TextDecoder();
        let str = "";
        for await (let part of toIterator(this.#parts, false)) {
          str += decoder.decode(part, { stream: true });
        }
        str += decoder.decode();
        return str;
      }
      async arrayBuffer() {
        const data2 = new Uint8Array(this.size);
        let offset2 = 0;
        for await (const chunk of toIterator(this.#parts, false)) {
          data2.set(chunk, offset2);
          offset2 += chunk.length;
        }
        return data2.buffer;
      }
      stream() {
        const it = toIterator(this.#parts, true);
        return new ReadableStream({
          type: "bytes",
          async pull(ctrl) {
            const chunk = await it.next();
            chunk.done ? ctrl.close() : ctrl.enqueue(chunk.value);
          }
        });
      }
      slice(start = 0, end = this.size, type = "") {
        const { size } = this;
        let relativeStart = start < 0 ? Math.max(size + start, 0) : Math.min(start, size);
        let relativeEnd = end < 0 ? Math.max(size + end, 0) : Math.min(end, size);
        const span = Math.max(relativeEnd - relativeStart, 0);
        const parts = this.#parts;
        const blobParts = [];
        let added = 0;
        for (const part of parts) {
          if (added >= span) {
            break;
          }
          const size2 = ArrayBuffer.isView(part) ? part.byteLength : part.size;
          if (relativeStart && size2 <= relativeStart) {
            relativeStart -= size2;
            relativeEnd -= size2;
          } else {
            let chunk;
            if (ArrayBuffer.isView(part)) {
              chunk = part.subarray(relativeStart, Math.min(size2, relativeEnd));
              added += chunk.byteLength;
            } else {
              chunk = part.slice(relativeStart, Math.min(size2, relativeEnd));
              added += chunk.size;
            }
            blobParts.push(chunk);
            relativeStart = 0;
          }
        }
        const blob = new Blob([], { type: String(type).toLowerCase() });
        blob.#size = span;
        blob.#parts = blobParts;
        return blob;
      }
      get [Symbol.toStringTag]() {
        return "Blob";
      }
      static [Symbol.hasInstance](object) {
        return object && typeof object === "object" && typeof object.constructor === "function" && (typeof object.stream === "function" || typeof object.arrayBuffer === "function") && /^(Blob|File)$/.test(object[Symbol.toStringTag]);
      }
    };
    Object.defineProperties(_Blob.prototype, {
      size: { enumerable: true },
      type: { enumerable: true },
      slice: { enumerable: true }
    });
    Blob2 = _Blob;
    Blob$1 = Blob2;
    FetchBaseError = class extends Error {
      constructor(message, type) {
        super(message);
        Error.captureStackTrace(this, this.constructor);
        this.type = type;
      }
      get name() {
        return this.constructor.name;
      }
      get [Symbol.toStringTag]() {
        return this.constructor.name;
      }
    };
    FetchError = class extends FetchBaseError {
      constructor(message, type, systemError) {
        super(message, type);
        if (systemError) {
          this.code = this.errno = systemError.code;
          this.erroredSysCall = systemError.syscall;
        }
      }
    };
    NAME = Symbol.toStringTag;
    isURLSearchParameters = (object) => {
      return typeof object === "object" && typeof object.append === "function" && typeof object.delete === "function" && typeof object.get === "function" && typeof object.getAll === "function" && typeof object.has === "function" && typeof object.set === "function" && typeof object.sort === "function" && object[NAME] === "URLSearchParams";
    };
    isBlob = (object) => {
      return typeof object === "object" && typeof object.arrayBuffer === "function" && typeof object.type === "string" && typeof object.stream === "function" && typeof object.constructor === "function" && /^(Blob|File)$/.test(object[NAME]);
    };
    isAbortSignal = (object) => {
      return typeof object === "object" && (object[NAME] === "AbortSignal" || object[NAME] === "EventTarget");
    };
    carriage = "\r\n";
    dashes = "-".repeat(2);
    carriageLength = Buffer.byteLength(carriage);
    getFooter = (boundary) => `${dashes}${boundary}${dashes}${carriage.repeat(2)}`;
    getBoundary = () => (0, import_crypto.randomBytes)(8).toString("hex");
    INTERNALS$2 = Symbol("Body internals");
    Body = class {
      constructor(body, {
        size = 0
      } = {}) {
        let boundary = null;
        if (body === null) {
          body = null;
        } else if (isURLSearchParameters(body)) {
          body = Buffer.from(body.toString());
        } else if (isBlob(body))
          ;
        else if (Buffer.isBuffer(body))
          ;
        else if (import_util.types.isAnyArrayBuffer(body)) {
          body = Buffer.from(body);
        } else if (ArrayBuffer.isView(body)) {
          body = Buffer.from(body.buffer, body.byteOffset, body.byteLength);
        } else if (body instanceof import_stream.default)
          ;
        else if (isFormData(body)) {
          boundary = `NodeFetchFormDataBoundary${getBoundary()}`;
          body = import_stream.default.Readable.from(formDataIterator(body, boundary));
        } else {
          body = Buffer.from(String(body));
        }
        this[INTERNALS$2] = {
          body,
          boundary,
          disturbed: false,
          error: null
        };
        this.size = size;
        if (body instanceof import_stream.default) {
          body.on("error", (error_) => {
            const error2 = error_ instanceof FetchBaseError ? error_ : new FetchError(`Invalid response body while trying to fetch ${this.url}: ${error_.message}`, "system", error_);
            this[INTERNALS$2].error = error2;
          });
        }
      }
      get body() {
        return this[INTERNALS$2].body;
      }
      get bodyUsed() {
        return this[INTERNALS$2].disturbed;
      }
      async arrayBuffer() {
        const { buffer, byteOffset, byteLength } = await consumeBody(this);
        return buffer.slice(byteOffset, byteOffset + byteLength);
      }
      async blob() {
        const ct = this.headers && this.headers.get("content-type") || this[INTERNALS$2].body && this[INTERNALS$2].body.type || "";
        const buf = await this.buffer();
        return new Blob$1([buf], {
          type: ct
        });
      }
      async json() {
        const buffer = await consumeBody(this);
        return JSON.parse(buffer.toString());
      }
      async text() {
        const buffer = await consumeBody(this);
        return buffer.toString();
      }
      buffer() {
        return consumeBody(this);
      }
    };
    Object.defineProperties(Body.prototype, {
      body: { enumerable: true },
      bodyUsed: { enumerable: true },
      arrayBuffer: { enumerable: true },
      blob: { enumerable: true },
      json: { enumerable: true },
      text: { enumerable: true }
    });
    clone = (instance, highWaterMark) => {
      let p1;
      let p2;
      let { body } = instance;
      if (instance.bodyUsed) {
        throw new Error("cannot clone body after it is used");
      }
      if (body instanceof import_stream.default && typeof body.getBoundary !== "function") {
        p1 = new import_stream.PassThrough({ highWaterMark });
        p2 = new import_stream.PassThrough({ highWaterMark });
        body.pipe(p1);
        body.pipe(p2);
        instance[INTERNALS$2].body = p1;
        body = p2;
      }
      return body;
    };
    extractContentType = (body, request) => {
      if (body === null) {
        return null;
      }
      if (typeof body === "string") {
        return "text/plain;charset=UTF-8";
      }
      if (isURLSearchParameters(body)) {
        return "application/x-www-form-urlencoded;charset=UTF-8";
      }
      if (isBlob(body)) {
        return body.type || null;
      }
      if (Buffer.isBuffer(body) || import_util.types.isAnyArrayBuffer(body) || ArrayBuffer.isView(body)) {
        return null;
      }
      if (body && typeof body.getBoundary === "function") {
        return `multipart/form-data;boundary=${body.getBoundary()}`;
      }
      if (isFormData(body)) {
        return `multipart/form-data; boundary=${request[INTERNALS$2].boundary}`;
      }
      if (body instanceof import_stream.default) {
        return null;
      }
      return "text/plain;charset=UTF-8";
    };
    getTotalBytes = (request) => {
      const { body } = request;
      if (body === null) {
        return 0;
      }
      if (isBlob(body)) {
        return body.size;
      }
      if (Buffer.isBuffer(body)) {
        return body.length;
      }
      if (body && typeof body.getLengthSync === "function") {
        return body.hasKnownLength && body.hasKnownLength() ? body.getLengthSync() : null;
      }
      if (isFormData(body)) {
        return getFormDataLength(request[INTERNALS$2].boundary);
      }
      return null;
    };
    writeToStream = (dest, { body }) => {
      if (body === null) {
        dest.end();
      } else if (isBlob(body)) {
        import_stream.default.Readable.from(body.stream()).pipe(dest);
      } else if (Buffer.isBuffer(body)) {
        dest.write(body);
        dest.end();
      } else {
        body.pipe(dest);
      }
    };
    validateHeaderName = typeof import_http.default.validateHeaderName === "function" ? import_http.default.validateHeaderName : (name) => {
      if (!/^[\^`\-\w!#$%&'*+.|~]+$/.test(name)) {
        const error2 = new TypeError(`Header name must be a valid HTTP token [${name}]`);
        Object.defineProperty(error2, "code", { value: "ERR_INVALID_HTTP_TOKEN" });
        throw error2;
      }
    };
    validateHeaderValue = typeof import_http.default.validateHeaderValue === "function" ? import_http.default.validateHeaderValue : (name, value) => {
      if (/[^\t\u0020-\u007E\u0080-\u00FF]/.test(value)) {
        const error2 = new TypeError(`Invalid character in header content ["${name}"]`);
        Object.defineProperty(error2, "code", { value: "ERR_INVALID_CHAR" });
        throw error2;
      }
    };
    Headers = class extends URLSearchParams {
      constructor(init2) {
        let result = [];
        if (init2 instanceof Headers) {
          const raw = init2.raw();
          for (const [name, values] of Object.entries(raw)) {
            result.push(...values.map((value) => [name, value]));
          }
        } else if (init2 == null)
          ;
        else if (typeof init2 === "object" && !import_util.types.isBoxedPrimitive(init2)) {
          const method = init2[Symbol.iterator];
          if (method == null) {
            result.push(...Object.entries(init2));
          } else {
            if (typeof method !== "function") {
              throw new TypeError("Header pairs must be iterable");
            }
            result = [...init2].map((pair) => {
              if (typeof pair !== "object" || import_util.types.isBoxedPrimitive(pair)) {
                throw new TypeError("Each header pair must be an iterable object");
              }
              return [...pair];
            }).map((pair) => {
              if (pair.length !== 2) {
                throw new TypeError("Each header pair must be a name/value tuple");
              }
              return [...pair];
            });
          }
        } else {
          throw new TypeError("Failed to construct 'Headers': The provided value is not of type '(sequence<sequence<ByteString>> or record<ByteString, ByteString>)");
        }
        result = result.length > 0 ? result.map(([name, value]) => {
          validateHeaderName(name);
          validateHeaderValue(name, String(value));
          return [String(name).toLowerCase(), String(value)];
        }) : void 0;
        super(result);
        return new Proxy(this, {
          get(target, p, receiver) {
            switch (p) {
              case "append":
              case "set":
                return (name, value) => {
                  validateHeaderName(name);
                  validateHeaderValue(name, String(value));
                  return URLSearchParams.prototype[p].call(target, String(name).toLowerCase(), String(value));
                };
              case "delete":
              case "has":
              case "getAll":
                return (name) => {
                  validateHeaderName(name);
                  return URLSearchParams.prototype[p].call(target, String(name).toLowerCase());
                };
              case "keys":
                return () => {
                  target.sort();
                  return new Set(URLSearchParams.prototype.keys.call(target)).keys();
                };
              default:
                return Reflect.get(target, p, receiver);
            }
          }
        });
      }
      get [Symbol.toStringTag]() {
        return this.constructor.name;
      }
      toString() {
        return Object.prototype.toString.call(this);
      }
      get(name) {
        const values = this.getAll(name);
        if (values.length === 0) {
          return null;
        }
        let value = values.join(", ");
        if (/^content-encoding$/i.test(name)) {
          value = value.toLowerCase();
        }
        return value;
      }
      forEach(callback, thisArg = void 0) {
        for (const name of this.keys()) {
          Reflect.apply(callback, thisArg, [this.get(name), name, this]);
        }
      }
      *values() {
        for (const name of this.keys()) {
          yield this.get(name);
        }
      }
      *entries() {
        for (const name of this.keys()) {
          yield [name, this.get(name)];
        }
      }
      [Symbol.iterator]() {
        return this.entries();
      }
      raw() {
        return [...this.keys()].reduce((result, key) => {
          result[key] = this.getAll(key);
          return result;
        }, {});
      }
      [Symbol.for("nodejs.util.inspect.custom")]() {
        return [...this.keys()].reduce((result, key) => {
          const values = this.getAll(key);
          if (key === "host") {
            result[key] = values[0];
          } else {
            result[key] = values.length > 1 ? values : values[0];
          }
          return result;
        }, {});
      }
    };
    Object.defineProperties(Headers.prototype, ["get", "entries", "forEach", "values"].reduce((result, property) => {
      result[property] = { enumerable: true };
      return result;
    }, {}));
    redirectStatus = new Set([301, 302, 303, 307, 308]);
    isRedirect = (code) => {
      return redirectStatus.has(code);
    };
    INTERNALS$1 = Symbol("Response internals");
    Response = class extends Body {
      constructor(body = null, options2 = {}) {
        super(body, options2);
        const status = options2.status != null ? options2.status : 200;
        const headers = new Headers(options2.headers);
        if (body !== null && !headers.has("Content-Type")) {
          const contentType = extractContentType(body);
          if (contentType) {
            headers.append("Content-Type", contentType);
          }
        }
        this[INTERNALS$1] = {
          type: "default",
          url: options2.url,
          status,
          statusText: options2.statusText || "",
          headers,
          counter: options2.counter,
          highWaterMark: options2.highWaterMark
        };
      }
      get type() {
        return this[INTERNALS$1].type;
      }
      get url() {
        return this[INTERNALS$1].url || "";
      }
      get status() {
        return this[INTERNALS$1].status;
      }
      get ok() {
        return this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300;
      }
      get redirected() {
        return this[INTERNALS$1].counter > 0;
      }
      get statusText() {
        return this[INTERNALS$1].statusText;
      }
      get headers() {
        return this[INTERNALS$1].headers;
      }
      get highWaterMark() {
        return this[INTERNALS$1].highWaterMark;
      }
      clone() {
        return new Response(clone(this, this.highWaterMark), {
          type: this.type,
          url: this.url,
          status: this.status,
          statusText: this.statusText,
          headers: this.headers,
          ok: this.ok,
          redirected: this.redirected,
          size: this.size
        });
      }
      static redirect(url, status = 302) {
        if (!isRedirect(status)) {
          throw new RangeError('Failed to execute "redirect" on "response": Invalid status code');
        }
        return new Response(null, {
          headers: {
            location: new URL(url).toString()
          },
          status
        });
      }
      static error() {
        const response = new Response(null, { status: 0, statusText: "" });
        response[INTERNALS$1].type = "error";
        return response;
      }
      get [Symbol.toStringTag]() {
        return "Response";
      }
    };
    Object.defineProperties(Response.prototype, {
      type: { enumerable: true },
      url: { enumerable: true },
      status: { enumerable: true },
      ok: { enumerable: true },
      redirected: { enumerable: true },
      statusText: { enumerable: true },
      headers: { enumerable: true },
      clone: { enumerable: true }
    });
    getSearch = (parsedURL) => {
      if (parsedURL.search) {
        return parsedURL.search;
      }
      const lastOffset = parsedURL.href.length - 1;
      const hash2 = parsedURL.hash || (parsedURL.href[lastOffset] === "#" ? "#" : "");
      return parsedURL.href[lastOffset - hash2.length] === "?" ? "?" : "";
    };
    INTERNALS = Symbol("Request internals");
    isRequest = (object) => {
      return typeof object === "object" && typeof object[INTERNALS] === "object";
    };
    Request = class extends Body {
      constructor(input, init2 = {}) {
        let parsedURL;
        if (isRequest(input)) {
          parsedURL = new URL(input.url);
        } else {
          parsedURL = new URL(input);
          input = {};
        }
        let method = init2.method || input.method || "GET";
        method = method.toUpperCase();
        if ((init2.body != null || isRequest(input)) && input.body !== null && (method === "GET" || method === "HEAD")) {
          throw new TypeError("Request with GET/HEAD method cannot have body");
        }
        const inputBody = init2.body ? init2.body : isRequest(input) && input.body !== null ? clone(input) : null;
        super(inputBody, {
          size: init2.size || input.size || 0
        });
        const headers = new Headers(init2.headers || input.headers || {});
        if (inputBody !== null && !headers.has("Content-Type")) {
          const contentType = extractContentType(inputBody, this);
          if (contentType) {
            headers.append("Content-Type", contentType);
          }
        }
        let signal = isRequest(input) ? input.signal : null;
        if ("signal" in init2) {
          signal = init2.signal;
        }
        if (signal != null && !isAbortSignal(signal)) {
          throw new TypeError("Expected signal to be an instanceof AbortSignal or EventTarget");
        }
        this[INTERNALS] = {
          method,
          redirect: init2.redirect || input.redirect || "follow",
          headers,
          parsedURL,
          signal
        };
        this.follow = init2.follow === void 0 ? input.follow === void 0 ? 20 : input.follow : init2.follow;
        this.compress = init2.compress === void 0 ? input.compress === void 0 ? true : input.compress : init2.compress;
        this.counter = init2.counter || input.counter || 0;
        this.agent = init2.agent || input.agent;
        this.highWaterMark = init2.highWaterMark || input.highWaterMark || 16384;
        this.insecureHTTPParser = init2.insecureHTTPParser || input.insecureHTTPParser || false;
      }
      get method() {
        return this[INTERNALS].method;
      }
      get url() {
        return (0, import_url.format)(this[INTERNALS].parsedURL);
      }
      get headers() {
        return this[INTERNALS].headers;
      }
      get redirect() {
        return this[INTERNALS].redirect;
      }
      get signal() {
        return this[INTERNALS].signal;
      }
      clone() {
        return new Request(this);
      }
      get [Symbol.toStringTag]() {
        return "Request";
      }
    };
    Object.defineProperties(Request.prototype, {
      method: { enumerable: true },
      url: { enumerable: true },
      headers: { enumerable: true },
      redirect: { enumerable: true },
      clone: { enumerable: true },
      signal: { enumerable: true }
    });
    getNodeRequestOptions = (request) => {
      const { parsedURL } = request[INTERNALS];
      const headers = new Headers(request[INTERNALS].headers);
      if (!headers.has("Accept")) {
        headers.set("Accept", "*/*");
      }
      let contentLengthValue = null;
      if (request.body === null && /^(post|put)$/i.test(request.method)) {
        contentLengthValue = "0";
      }
      if (request.body !== null) {
        const totalBytes = getTotalBytes(request);
        if (typeof totalBytes === "number" && !Number.isNaN(totalBytes)) {
          contentLengthValue = String(totalBytes);
        }
      }
      if (contentLengthValue) {
        headers.set("Content-Length", contentLengthValue);
      }
      if (!headers.has("User-Agent")) {
        headers.set("User-Agent", "node-fetch");
      }
      if (request.compress && !headers.has("Accept-Encoding")) {
        headers.set("Accept-Encoding", "gzip,deflate,br");
      }
      let { agent } = request;
      if (typeof agent === "function") {
        agent = agent(parsedURL);
      }
      if (!headers.has("Connection") && !agent) {
        headers.set("Connection", "close");
      }
      const search = getSearch(parsedURL);
      const requestOptions = {
        path: parsedURL.pathname + search,
        pathname: parsedURL.pathname,
        hostname: parsedURL.hostname,
        protocol: parsedURL.protocol,
        port: parsedURL.port,
        hash: parsedURL.hash,
        search: parsedURL.search,
        query: parsedURL.query,
        href: parsedURL.href,
        method: request.method,
        headers: headers[Symbol.for("nodejs.util.inspect.custom")](),
        insecureHTTPParser: request.insecureHTTPParser,
        agent
      };
      return requestOptions;
    };
    AbortError = class extends FetchBaseError {
      constructor(message, type = "aborted") {
        super(message, type);
      }
    };
    supportedSchemas = new Set(["data:", "http:", "https:"]);
  }
});

// node_modules/@sveltejs/adapter-vercel/files/shims.js
var init_shims = __esm({
  "node_modules/@sveltejs/adapter-vercel/files/shims.js"() {
    init_install_fetch();
  }
});

// node_modules/fast-xml-parser/src/util.js
var require_util = __commonJS({
  "node_modules/fast-xml-parser/src/util.js"(exports) {
    init_shims();
    "use strict";
    var nameStartChar = ":A-Za-z_\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";
    var nameChar = nameStartChar + "\\-.\\d\\u00B7\\u0300-\\u036F\\u203F-\\u2040";
    var nameRegexp = "[" + nameStartChar + "][" + nameChar + "]*";
    var regexName = new RegExp("^" + nameRegexp + "$");
    var getAllMatches = function(string, regex) {
      const matches2 = [];
      let match2 = regex.exec(string);
      while (match2) {
        const allmatches = [];
        const len = match2.length;
        for (let index2 = 0; index2 < len; index2++) {
          allmatches.push(match2[index2]);
        }
        matches2.push(allmatches);
        match2 = regex.exec(string);
      }
      return matches2;
    };
    var isName = function(string) {
      const match2 = regexName.exec(string);
      return !(match2 === null || typeof match2 === "undefined");
    };
    exports.isExist = function(v) {
      return typeof v !== "undefined";
    };
    exports.isEmptyObject = function(obj) {
      return Object.keys(obj).length === 0;
    };
    exports.merge = function(target, a, arrayMode) {
      if (a) {
        const keys = Object.keys(a);
        const len = keys.length;
        for (let i = 0; i < len; i++) {
          if (arrayMode === "strict") {
            target[keys[i]] = [a[keys[i]]];
          } else {
            target[keys[i]] = a[keys[i]];
          }
        }
      }
    };
    exports.getValue = function(v) {
      if (exports.isExist(v)) {
        return v;
      } else {
        return "";
      }
    };
    exports.buildOptions = function(options2, defaultOptions, props) {
      var newOptions = {};
      if (!options2) {
        return defaultOptions;
      }
      for (let i = 0; i < props.length; i++) {
        if (options2[props[i]] !== void 0) {
          newOptions[props[i]] = options2[props[i]];
        } else {
          newOptions[props[i]] = defaultOptions[props[i]];
        }
      }
      return newOptions;
    };
    exports.isTagNameInArrayMode = function(tagName, arrayMode, parentTagName) {
      if (arrayMode === false) {
        return false;
      } else if (arrayMode instanceof RegExp) {
        return arrayMode.test(tagName);
      } else if (typeof arrayMode === "function") {
        return !!arrayMode(tagName, parentTagName);
      }
      return arrayMode === "strict";
    };
    exports.isName = isName;
    exports.getAllMatches = getAllMatches;
    exports.nameRegexp = nameRegexp;
  }
});

// node_modules/fast-xml-parser/src/node2json.js
var require_node2json = __commonJS({
  "node_modules/fast-xml-parser/src/node2json.js"(exports) {
    init_shims();
    "use strict";
    var util = require_util();
    var convertToJson = function(node, options2, parentTagName) {
      const jObj = {};
      if ((!node.child || util.isEmptyObject(node.child)) && (!node.attrsMap || util.isEmptyObject(node.attrsMap))) {
        return util.isExist(node.val) ? node.val : "";
      }
      if (util.isExist(node.val) && !(typeof node.val === "string" && (node.val === "" || node.val === options2.cdataPositionChar))) {
        const asArray = util.isTagNameInArrayMode(node.tagname, options2.arrayMode, parentTagName);
        jObj[options2.textNodeName] = asArray ? [node.val] : node.val;
      }
      util.merge(jObj, node.attrsMap, options2.arrayMode);
      const keys = Object.keys(node.child);
      for (let index2 = 0; index2 < keys.length; index2++) {
        const tagName = keys[index2];
        if (node.child[tagName] && node.child[tagName].length > 1) {
          jObj[tagName] = [];
          for (let tag in node.child[tagName]) {
            if (node.child[tagName].hasOwnProperty(tag)) {
              jObj[tagName].push(convertToJson(node.child[tagName][tag], options2, tagName));
            }
          }
        } else {
          const result = convertToJson(node.child[tagName][0], options2, tagName);
          const asArray = options2.arrayMode === true && typeof result === "object" || util.isTagNameInArrayMode(tagName, options2.arrayMode, parentTagName);
          jObj[tagName] = asArray ? [result] : result;
        }
      }
      return jObj;
    };
    exports.convertToJson = convertToJson;
  }
});

// node_modules/fast-xml-parser/src/xmlNode.js
var require_xmlNode = __commonJS({
  "node_modules/fast-xml-parser/src/xmlNode.js"(exports, module2) {
    init_shims();
    "use strict";
    module2.exports = function(tagname, parent, val) {
      this.tagname = tagname;
      this.parent = parent;
      this.child = {};
      this.attrsMap = {};
      this.val = val;
      this.addChild = function(child) {
        if (Array.isArray(this.child[child.tagname])) {
          this.child[child.tagname].push(child);
        } else {
          this.child[child.tagname] = [child];
        }
      };
    };
  }
});

// node_modules/fast-xml-parser/src/xmlstr2xmlnode.js
var require_xmlstr2xmlnode = __commonJS({
  "node_modules/fast-xml-parser/src/xmlstr2xmlnode.js"(exports) {
    init_shims();
    "use strict";
    var util = require_util();
    var buildOptions = require_util().buildOptions;
    var xmlNode = require_xmlNode();
    var regx = "<((!\\[CDATA\\[([\\s\\S]*?)(]]>))|((NAME:)?(NAME))([^>]*)>|((\\/)(NAME)\\s*>))([^<]*)".replace(/NAME/g, util.nameRegexp);
    if (!Number.parseInt && window.parseInt) {
      Number.parseInt = window.parseInt;
    }
    if (!Number.parseFloat && window.parseFloat) {
      Number.parseFloat = window.parseFloat;
    }
    var defaultOptions = {
      attributeNamePrefix: "@_",
      attrNodeName: false,
      textNodeName: "#text",
      ignoreAttributes: true,
      ignoreNameSpace: false,
      allowBooleanAttributes: false,
      parseNodeValue: true,
      parseAttributeValue: false,
      arrayMode: false,
      trimValues: true,
      cdataTagName: false,
      cdataPositionChar: "\\c",
      tagValueProcessor: function(a, tagName) {
        return a;
      },
      attrValueProcessor: function(a, attrName) {
        return a;
      },
      stopNodes: []
    };
    exports.defaultOptions = defaultOptions;
    var props = [
      "attributeNamePrefix",
      "attrNodeName",
      "textNodeName",
      "ignoreAttributes",
      "ignoreNameSpace",
      "allowBooleanAttributes",
      "parseNodeValue",
      "parseAttributeValue",
      "arrayMode",
      "trimValues",
      "cdataTagName",
      "cdataPositionChar",
      "tagValueProcessor",
      "attrValueProcessor",
      "parseTrueNumberOnly",
      "stopNodes"
    ];
    exports.props = props;
    function processTagValue(tagName, val, options2) {
      if (val) {
        if (options2.trimValues) {
          val = val.trim();
        }
        val = options2.tagValueProcessor(val, tagName);
        val = parseValue(val, options2.parseNodeValue, options2.parseTrueNumberOnly);
      }
      return val;
    }
    function resolveNameSpace(tagname, options2) {
      if (options2.ignoreNameSpace) {
        const tags = tagname.split(":");
        const prefix = tagname.charAt(0) === "/" ? "/" : "";
        if (tags[0] === "xmlns") {
          return "";
        }
        if (tags.length === 2) {
          tagname = prefix + tags[1];
        }
      }
      return tagname;
    }
    function parseValue(val, shouldParse, parseTrueNumberOnly) {
      if (shouldParse && typeof val === "string") {
        let parsed;
        if (val.trim() === "" || isNaN(val)) {
          parsed = val === "true" ? true : val === "false" ? false : val;
        } else {
          if (val.indexOf("0x") !== -1) {
            parsed = Number.parseInt(val, 16);
          } else if (val.indexOf(".") !== -1) {
            parsed = Number.parseFloat(val);
            val = val.replace(/\.?0+$/, "");
          } else {
            parsed = Number.parseInt(val, 10);
          }
          if (parseTrueNumberOnly) {
            parsed = String(parsed) === val ? parsed : val;
          }
        }
        return parsed;
      } else {
        if (util.isExist(val)) {
          return val;
        } else {
          return "";
        }
      }
    }
    var attrsRegx = new RegExp(`([^\\s=]+)\\s*(=\\s*(['"])(.*?)\\3)?`, "g");
    function buildAttributesMap(attrStr, options2) {
      if (!options2.ignoreAttributes && typeof attrStr === "string") {
        attrStr = attrStr.replace(/\r?\n/g, " ");
        const matches2 = util.getAllMatches(attrStr, attrsRegx);
        const len = matches2.length;
        const attrs = {};
        for (let i = 0; i < len; i++) {
          const attrName = resolveNameSpace(matches2[i][1], options2);
          if (attrName.length) {
            if (matches2[i][4] !== void 0) {
              if (options2.trimValues) {
                matches2[i][4] = matches2[i][4].trim();
              }
              matches2[i][4] = options2.attrValueProcessor(matches2[i][4], attrName);
              attrs[options2.attributeNamePrefix + attrName] = parseValue(matches2[i][4], options2.parseAttributeValue, options2.parseTrueNumberOnly);
            } else if (options2.allowBooleanAttributes) {
              attrs[options2.attributeNamePrefix + attrName] = true;
            }
          }
        }
        if (!Object.keys(attrs).length) {
          return;
        }
        if (options2.attrNodeName) {
          const attrCollection = {};
          attrCollection[options2.attrNodeName] = attrs;
          return attrCollection;
        }
        return attrs;
      }
    }
    var getTraversalObj = function(xmlData, options2) {
      xmlData = xmlData.replace(/\r\n?/g, "\n");
      options2 = buildOptions(options2, defaultOptions, props);
      const xmlObj = new xmlNode("!xml");
      let currentNode = xmlObj;
      let textData = "";
      for (let i = 0; i < xmlData.length; i++) {
        const ch = xmlData[i];
        if (ch === "<") {
          if (xmlData[i + 1] === "/") {
            const closeIndex = findClosingIndex(xmlData, ">", i, "Closing Tag is not closed.");
            let tagName = xmlData.substring(i + 2, closeIndex).trim();
            if (options2.ignoreNameSpace) {
              const colonIndex = tagName.indexOf(":");
              if (colonIndex !== -1) {
                tagName = tagName.substr(colonIndex + 1);
              }
            }
            if (currentNode) {
              if (currentNode.val) {
                currentNode.val = util.getValue(currentNode.val) + "" + processTagValue(tagName, textData, options2);
              } else {
                currentNode.val = processTagValue(tagName, textData, options2);
              }
            }
            if (options2.stopNodes.length && options2.stopNodes.includes(currentNode.tagname)) {
              currentNode.child = [];
              if (currentNode.attrsMap == void 0) {
                currentNode.attrsMap = {};
              }
              currentNode.val = xmlData.substr(currentNode.startIndex + 1, i - currentNode.startIndex - 1);
            }
            currentNode = currentNode.parent;
            textData = "";
            i = closeIndex;
          } else if (xmlData[i + 1] === "?") {
            i = findClosingIndex(xmlData, "?>", i, "Pi Tag is not closed.");
          } else if (xmlData.substr(i + 1, 3) === "!--") {
            i = findClosingIndex(xmlData, "-->", i, "Comment is not closed.");
          } else if (xmlData.substr(i + 1, 2) === "!D") {
            const closeIndex = findClosingIndex(xmlData, ">", i, "DOCTYPE is not closed.");
            const tagExp = xmlData.substring(i, closeIndex);
            if (tagExp.indexOf("[") >= 0) {
              i = xmlData.indexOf("]>", i) + 1;
            } else {
              i = closeIndex;
            }
          } else if (xmlData.substr(i + 1, 2) === "![") {
            const closeIndex = findClosingIndex(xmlData, "]]>", i, "CDATA is not closed.") - 2;
            const tagExp = xmlData.substring(i + 9, closeIndex);
            if (textData) {
              currentNode.val = util.getValue(currentNode.val) + "" + processTagValue(currentNode.tagname, textData, options2);
              textData = "";
            }
            if (options2.cdataTagName) {
              const childNode = new xmlNode(options2.cdataTagName, currentNode, tagExp);
              currentNode.addChild(childNode);
              currentNode.val = util.getValue(currentNode.val) + options2.cdataPositionChar;
              if (tagExp) {
                childNode.val = tagExp;
              }
            } else {
              currentNode.val = (currentNode.val || "") + (tagExp || "");
            }
            i = closeIndex + 2;
          } else {
            const result = closingIndexForOpeningTag(xmlData, i + 1);
            let tagExp = result.data;
            const closeIndex = result.index;
            const separatorIndex = tagExp.indexOf(" ");
            let tagName = tagExp;
            let shouldBuildAttributesMap = true;
            if (separatorIndex !== -1) {
              tagName = tagExp.substr(0, separatorIndex).replace(/\s\s*$/, "");
              tagExp = tagExp.substr(separatorIndex + 1);
            }
            if (options2.ignoreNameSpace) {
              const colonIndex = tagName.indexOf(":");
              if (colonIndex !== -1) {
                tagName = tagName.substr(colonIndex + 1);
                shouldBuildAttributesMap = tagName !== result.data.substr(colonIndex + 1);
              }
            }
            if (currentNode && textData) {
              if (currentNode.tagname !== "!xml") {
                currentNode.val = util.getValue(currentNode.val) + "" + processTagValue(currentNode.tagname, textData, options2);
              }
            }
            if (tagExp.length > 0 && tagExp.lastIndexOf("/") === tagExp.length - 1) {
              if (tagName[tagName.length - 1] === "/") {
                tagName = tagName.substr(0, tagName.length - 1);
                tagExp = tagName;
              } else {
                tagExp = tagExp.substr(0, tagExp.length - 1);
              }
              const childNode = new xmlNode(tagName, currentNode, "");
              if (tagName !== tagExp) {
                childNode.attrsMap = buildAttributesMap(tagExp, options2);
              }
              currentNode.addChild(childNode);
            } else {
              const childNode = new xmlNode(tagName, currentNode);
              if (options2.stopNodes.length && options2.stopNodes.includes(childNode.tagname)) {
                childNode.startIndex = closeIndex;
              }
              if (tagName !== tagExp && shouldBuildAttributesMap) {
                childNode.attrsMap = buildAttributesMap(tagExp, options2);
              }
              currentNode.addChild(childNode);
              currentNode = childNode;
            }
            textData = "";
            i = closeIndex;
          }
        } else {
          textData += xmlData[i];
        }
      }
      return xmlObj;
    };
    function closingIndexForOpeningTag(data2, i) {
      let attrBoundary;
      let tagExp = "";
      for (let index2 = i; index2 < data2.length; index2++) {
        let ch = data2[index2];
        if (attrBoundary) {
          if (ch === attrBoundary)
            attrBoundary = "";
        } else if (ch === '"' || ch === "'") {
          attrBoundary = ch;
        } else if (ch === ">") {
          return {
            data: tagExp,
            index: index2
          };
        } else if (ch === "	") {
          ch = " ";
        }
        tagExp += ch;
      }
    }
    function findClosingIndex(xmlData, str, i, errMsg) {
      const closingIndex = xmlData.indexOf(str, i);
      if (closingIndex === -1) {
        throw new Error(errMsg);
      } else {
        return closingIndex + str.length - 1;
      }
    }
    exports.getTraversalObj = getTraversalObj;
  }
});

// node_modules/fast-xml-parser/src/validator.js
var require_validator = __commonJS({
  "node_modules/fast-xml-parser/src/validator.js"(exports) {
    init_shims();
    "use strict";
    var util = require_util();
    var defaultOptions = {
      allowBooleanAttributes: false
    };
    var props = ["allowBooleanAttributes"];
    exports.validate = function(xmlData, options2) {
      options2 = util.buildOptions(options2, defaultOptions, props);
      const tags = [];
      let tagFound = false;
      let reachedRoot = false;
      if (xmlData[0] === "\uFEFF") {
        xmlData = xmlData.substr(1);
      }
      for (let i = 0; i < xmlData.length; i++) {
        if (xmlData[i] === "<" && xmlData[i + 1] === "?") {
          i += 2;
          i = readPI(xmlData, i);
          if (i.err)
            return i;
        } else if (xmlData[i] === "<") {
          i++;
          if (xmlData[i] === "!") {
            i = readCommentAndCDATA(xmlData, i);
            continue;
          } else {
            let closingTag = false;
            if (xmlData[i] === "/") {
              closingTag = true;
              i++;
            }
            let tagName = "";
            for (; i < xmlData.length && xmlData[i] !== ">" && xmlData[i] !== " " && xmlData[i] !== "	" && xmlData[i] !== "\n" && xmlData[i] !== "\r"; i++) {
              tagName += xmlData[i];
            }
            tagName = tagName.trim();
            if (tagName[tagName.length - 1] === "/") {
              tagName = tagName.substring(0, tagName.length - 1);
              i--;
            }
            if (!validateTagName(tagName)) {
              let msg;
              if (tagName.trim().length === 0) {
                msg = "There is an unnecessary space between tag name and backward slash '</ ..'.";
              } else {
                msg = "Tag '" + tagName + "' is an invalid name.";
              }
              return getErrorObject("InvalidTag", msg, getLineNumberForPosition(xmlData, i));
            }
            const result = readAttributeStr(xmlData, i);
            if (result === false) {
              return getErrorObject("InvalidAttr", "Attributes for '" + tagName + "' have open quote.", getLineNumberForPosition(xmlData, i));
            }
            let attrStr = result.value;
            i = result.index;
            if (attrStr[attrStr.length - 1] === "/") {
              attrStr = attrStr.substring(0, attrStr.length - 1);
              const isValid = validateAttributeString(attrStr, options2);
              if (isValid === true) {
                tagFound = true;
              } else {
                return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, i - attrStr.length + isValid.err.line));
              }
            } else if (closingTag) {
              if (!result.tagClosed) {
                return getErrorObject("InvalidTag", "Closing tag '" + tagName + "' doesn't have proper closing.", getLineNumberForPosition(xmlData, i));
              } else if (attrStr.trim().length > 0) {
                return getErrorObject("InvalidTag", "Closing tag '" + tagName + "' can't have attributes or invalid starting.", getLineNumberForPosition(xmlData, i));
              } else {
                const otg = tags.pop();
                if (tagName !== otg) {
                  return getErrorObject("InvalidTag", "Closing tag '" + otg + "' is expected inplace of '" + tagName + "'.", getLineNumberForPosition(xmlData, i));
                }
                if (tags.length == 0) {
                  reachedRoot = true;
                }
              }
            } else {
              const isValid = validateAttributeString(attrStr, options2);
              if (isValid !== true) {
                return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, i - attrStr.length + isValid.err.line));
              }
              if (reachedRoot === true) {
                return getErrorObject("InvalidXml", "Multiple possible root nodes found.", getLineNumberForPosition(xmlData, i));
              } else {
                tags.push(tagName);
              }
              tagFound = true;
            }
            for (i++; i < xmlData.length; i++) {
              if (xmlData[i] === "<") {
                if (xmlData[i + 1] === "!") {
                  i++;
                  i = readCommentAndCDATA(xmlData, i);
                  continue;
                } else if (xmlData[i + 1] === "?") {
                  i = readPI(xmlData, ++i);
                  if (i.err)
                    return i;
                } else {
                  break;
                }
              } else if (xmlData[i] === "&") {
                const afterAmp = validateAmpersand(xmlData, i);
                if (afterAmp == -1)
                  return getErrorObject("InvalidChar", "char '&' is not expected.", getLineNumberForPosition(xmlData, i));
                i = afterAmp;
              }
            }
            if (xmlData[i] === "<") {
              i--;
            }
          }
        } else {
          if (xmlData[i] === " " || xmlData[i] === "	" || xmlData[i] === "\n" || xmlData[i] === "\r") {
            continue;
          }
          return getErrorObject("InvalidChar", "char '" + xmlData[i] + "' is not expected.", getLineNumberForPosition(xmlData, i));
        }
      }
      if (!tagFound) {
        return getErrorObject("InvalidXml", "Start tag expected.", 1);
      } else if (tags.length > 0) {
        return getErrorObject("InvalidXml", "Invalid '" + JSON.stringify(tags, null, 4).replace(/\r?\n/g, "") + "' found.", 1);
      }
      return true;
    };
    function readPI(xmlData, i) {
      var start = i;
      for (; i < xmlData.length; i++) {
        if (xmlData[i] == "?" || xmlData[i] == " ") {
          var tagname = xmlData.substr(start, i - start);
          if (i > 5 && tagname === "xml") {
            return getErrorObject("InvalidXml", "XML declaration allowed only at the start of the document.", getLineNumberForPosition(xmlData, i));
          } else if (xmlData[i] == "?" && xmlData[i + 1] == ">") {
            i++;
            break;
          } else {
            continue;
          }
        }
      }
      return i;
    }
    function readCommentAndCDATA(xmlData, i) {
      if (xmlData.length > i + 5 && xmlData[i + 1] === "-" && xmlData[i + 2] === "-") {
        for (i += 3; i < xmlData.length; i++) {
          if (xmlData[i] === "-" && xmlData[i + 1] === "-" && xmlData[i + 2] === ">") {
            i += 2;
            break;
          }
        }
      } else if (xmlData.length > i + 8 && xmlData[i + 1] === "D" && xmlData[i + 2] === "O" && xmlData[i + 3] === "C" && xmlData[i + 4] === "T" && xmlData[i + 5] === "Y" && xmlData[i + 6] === "P" && xmlData[i + 7] === "E") {
        let angleBracketsCount = 1;
        for (i += 8; i < xmlData.length; i++) {
          if (xmlData[i] === "<") {
            angleBracketsCount++;
          } else if (xmlData[i] === ">") {
            angleBracketsCount--;
            if (angleBracketsCount === 0) {
              break;
            }
          }
        }
      } else if (xmlData.length > i + 9 && xmlData[i + 1] === "[" && xmlData[i + 2] === "C" && xmlData[i + 3] === "D" && xmlData[i + 4] === "A" && xmlData[i + 5] === "T" && xmlData[i + 6] === "A" && xmlData[i + 7] === "[") {
        for (i += 8; i < xmlData.length; i++) {
          if (xmlData[i] === "]" && xmlData[i + 1] === "]" && xmlData[i + 2] === ">") {
            i += 2;
            break;
          }
        }
      }
      return i;
    }
    var doubleQuote = '"';
    var singleQuote = "'";
    function readAttributeStr(xmlData, i) {
      let attrStr = "";
      let startChar = "";
      let tagClosed = false;
      for (; i < xmlData.length; i++) {
        if (xmlData[i] === doubleQuote || xmlData[i] === singleQuote) {
          if (startChar === "") {
            startChar = xmlData[i];
          } else if (startChar !== xmlData[i]) {
            continue;
          } else {
            startChar = "";
          }
        } else if (xmlData[i] === ">") {
          if (startChar === "") {
            tagClosed = true;
            break;
          }
        }
        attrStr += xmlData[i];
      }
      if (startChar !== "") {
        return false;
      }
      return {
        value: attrStr,
        index: i,
        tagClosed
      };
    }
    var validAttrStrRegxp = new RegExp(`(\\s*)([^\\s=]+)(\\s*=)?(\\s*(['"])(([\\s\\S])*?)\\5)?`, "g");
    function validateAttributeString(attrStr, options2) {
      const matches2 = util.getAllMatches(attrStr, validAttrStrRegxp);
      const attrNames = {};
      for (let i = 0; i < matches2.length; i++) {
        if (matches2[i][1].length === 0) {
          return getErrorObject("InvalidAttr", "Attribute '" + matches2[i][2] + "' has no space in starting.", getPositionFromMatch(attrStr, matches2[i][0]));
        } else if (matches2[i][3] === void 0 && !options2.allowBooleanAttributes) {
          return getErrorObject("InvalidAttr", "boolean attribute '" + matches2[i][2] + "' is not allowed.", getPositionFromMatch(attrStr, matches2[i][0]));
        }
        const attrName = matches2[i][2];
        if (!validateAttrName(attrName)) {
          return getErrorObject("InvalidAttr", "Attribute '" + attrName + "' is an invalid name.", getPositionFromMatch(attrStr, matches2[i][0]));
        }
        if (!attrNames.hasOwnProperty(attrName)) {
          attrNames[attrName] = 1;
        } else {
          return getErrorObject("InvalidAttr", "Attribute '" + attrName + "' is repeated.", getPositionFromMatch(attrStr, matches2[i][0]));
        }
      }
      return true;
    }
    function validateNumberAmpersand(xmlData, i) {
      let re = /\d/;
      if (xmlData[i] === "x") {
        i++;
        re = /[\da-fA-F]/;
      }
      for (; i < xmlData.length; i++) {
        if (xmlData[i] === ";")
          return i;
        if (!xmlData[i].match(re))
          break;
      }
      return -1;
    }
    function validateAmpersand(xmlData, i) {
      i++;
      if (xmlData[i] === ";")
        return -1;
      if (xmlData[i] === "#") {
        i++;
        return validateNumberAmpersand(xmlData, i);
      }
      let count = 0;
      for (; i < xmlData.length; i++, count++) {
        if (xmlData[i].match(/\w/) && count < 20)
          continue;
        if (xmlData[i] === ";")
          break;
        return -1;
      }
      return i;
    }
    function getErrorObject(code, message, lineNumber) {
      return {
        err: {
          code,
          msg: message,
          line: lineNumber
        }
      };
    }
    function validateAttrName(attrName) {
      return util.isName(attrName);
    }
    function validateTagName(tagname) {
      return util.isName(tagname);
    }
    function getLineNumberForPosition(xmlData, index2) {
      var lines = xmlData.substring(0, index2).split(/\r?\n/);
      return lines.length;
    }
    function getPositionFromMatch(attrStr, match2) {
      return attrStr.indexOf(match2) + match2.length;
    }
  }
});

// node_modules/fast-xml-parser/src/nimndata.js
var require_nimndata = __commonJS({
  "node_modules/fast-xml-parser/src/nimndata.js"(exports) {
    init_shims();
    "use strict";
    var char = function(a) {
      return String.fromCharCode(a);
    };
    var chars2 = {
      nilChar: char(176),
      missingChar: char(201),
      nilPremitive: char(175),
      missingPremitive: char(200),
      emptyChar: char(178),
      emptyValue: char(177),
      boundryChar: char(179),
      objStart: char(198),
      arrStart: char(204),
      arrayEnd: char(185)
    };
    var charsArr = [
      chars2.nilChar,
      chars2.nilPremitive,
      chars2.missingChar,
      chars2.missingPremitive,
      chars2.boundryChar,
      chars2.emptyChar,
      chars2.emptyValue,
      chars2.arrayEnd,
      chars2.objStart,
      chars2.arrStart
    ];
    var _e = function(node, e_schema, options2) {
      if (typeof e_schema === "string") {
        if (node && node[0] && node[0].val !== void 0) {
          return getValue(node[0].val, e_schema);
        } else {
          return getValue(node, e_schema);
        }
      } else {
        const hasValidData = hasData(node);
        if (hasValidData === true) {
          let str = "";
          if (Array.isArray(e_schema)) {
            str += chars2.arrStart;
            const itemSchema = e_schema[0];
            const arr_len = node.length;
            if (typeof itemSchema === "string") {
              for (let arr_i = 0; arr_i < arr_len; arr_i++) {
                const r = getValue(node[arr_i].val, itemSchema);
                str = processValue(str, r);
              }
            } else {
              for (let arr_i = 0; arr_i < arr_len; arr_i++) {
                const r = _e(node[arr_i], itemSchema, options2);
                str = processValue(str, r);
              }
            }
            str += chars2.arrayEnd;
          } else {
            str += chars2.objStart;
            const keys = Object.keys(e_schema);
            if (Array.isArray(node)) {
              node = node[0];
            }
            for (let i in keys) {
              const key = keys[i];
              let r;
              if (!options2.ignoreAttributes && node.attrsMap && node.attrsMap[key]) {
                r = _e(node.attrsMap[key], e_schema[key], options2);
              } else if (key === options2.textNodeName) {
                r = _e(node.val, e_schema[key], options2);
              } else {
                r = _e(node.child[key], e_schema[key], options2);
              }
              str = processValue(str, r);
            }
          }
          return str;
        } else {
          return hasValidData;
        }
      }
    };
    var getValue = function(a) {
      switch (a) {
        case void 0:
          return chars2.missingPremitive;
        case null:
          return chars2.nilPremitive;
        case "":
          return chars2.emptyValue;
        default:
          return a;
      }
    };
    var processValue = function(str, r) {
      if (!isAppChar(r[0]) && !isAppChar(str[str.length - 1])) {
        str += chars2.boundryChar;
      }
      return str + r;
    };
    var isAppChar = function(ch) {
      return charsArr.indexOf(ch) !== -1;
    };
    function hasData(jObj) {
      if (jObj === void 0) {
        return chars2.missingChar;
      } else if (jObj === null) {
        return chars2.nilChar;
      } else if (jObj.child && Object.keys(jObj.child).length === 0 && (!jObj.attrsMap || Object.keys(jObj.attrsMap).length === 0)) {
        return chars2.emptyChar;
      } else {
        return true;
      }
    }
    var x2j = require_xmlstr2xmlnode();
    var buildOptions = require_util().buildOptions;
    var convert2nimn = function(node, e_schema, options2) {
      options2 = buildOptions(options2, x2j.defaultOptions, x2j.props);
      return _e(node, e_schema, options2);
    };
    exports.convert2nimn = convert2nimn;
  }
});

// node_modules/fast-xml-parser/src/node2json_str.js
var require_node2json_str = __commonJS({
  "node_modules/fast-xml-parser/src/node2json_str.js"(exports) {
    init_shims();
    "use strict";
    var util = require_util();
    var buildOptions = require_util().buildOptions;
    var x2j = require_xmlstr2xmlnode();
    var convertToJsonString = function(node, options2) {
      options2 = buildOptions(options2, x2j.defaultOptions, x2j.props);
      options2.indentBy = options2.indentBy || "";
      return _cToJsonStr(node, options2, 0);
    };
    var _cToJsonStr = function(node, options2, level) {
      let jObj = "{";
      const keys = Object.keys(node.child);
      for (let index2 = 0; index2 < keys.length; index2++) {
        var tagname = keys[index2];
        if (node.child[tagname] && node.child[tagname].length > 1) {
          jObj += '"' + tagname + '" : [ ';
          for (var tag in node.child[tagname]) {
            jObj += _cToJsonStr(node.child[tagname][tag], options2) + " , ";
          }
          jObj = jObj.substr(0, jObj.length - 1) + " ] ";
        } else {
          jObj += '"' + tagname + '" : ' + _cToJsonStr(node.child[tagname][0], options2) + " ,";
        }
      }
      util.merge(jObj, node.attrsMap);
      if (util.isEmptyObject(jObj)) {
        return util.isExist(node.val) ? node.val : "";
      } else {
        if (util.isExist(node.val)) {
          if (!(typeof node.val === "string" && (node.val === "" || node.val === options2.cdataPositionChar))) {
            jObj += '"' + options2.textNodeName + '" : ' + stringval(node.val);
          }
        }
      }
      if (jObj[jObj.length - 1] === ",") {
        jObj = jObj.substr(0, jObj.length - 2);
      }
      return jObj + "}";
    };
    function stringval(v) {
      if (v === true || v === false || !isNaN(v)) {
        return v;
      } else {
        return '"' + v + '"';
      }
    }
    exports.convertToJsonString = convertToJsonString;
  }
});

// node_modules/fast-xml-parser/src/json2xml.js
var require_json2xml = __commonJS({
  "node_modules/fast-xml-parser/src/json2xml.js"(exports, module2) {
    init_shims();
    "use strict";
    var buildOptions = require_util().buildOptions;
    var defaultOptions = {
      attributeNamePrefix: "@_",
      attrNodeName: false,
      textNodeName: "#text",
      ignoreAttributes: true,
      cdataTagName: false,
      cdataPositionChar: "\\c",
      format: false,
      indentBy: "  ",
      supressEmptyNode: false,
      tagValueProcessor: function(a) {
        return a;
      },
      attrValueProcessor: function(a) {
        return a;
      }
    };
    var props = [
      "attributeNamePrefix",
      "attrNodeName",
      "textNodeName",
      "ignoreAttributes",
      "cdataTagName",
      "cdataPositionChar",
      "format",
      "indentBy",
      "supressEmptyNode",
      "tagValueProcessor",
      "attrValueProcessor"
    ];
    function Parser(options2) {
      this.options = buildOptions(options2, defaultOptions, props);
      if (this.options.ignoreAttributes || this.options.attrNodeName) {
        this.isAttribute = function() {
          return false;
        };
      } else {
        this.attrPrefixLen = this.options.attributeNamePrefix.length;
        this.isAttribute = isAttribute;
      }
      if (this.options.cdataTagName) {
        this.isCDATA = isCDATA;
      } else {
        this.isCDATA = function() {
          return false;
        };
      }
      this.replaceCDATAstr = replaceCDATAstr;
      this.replaceCDATAarr = replaceCDATAarr;
      if (this.options.format) {
        this.indentate = indentate;
        this.tagEndChar = ">\n";
        this.newLine = "\n";
      } else {
        this.indentate = function() {
          return "";
        };
        this.tagEndChar = ">";
        this.newLine = "";
      }
      if (this.options.supressEmptyNode) {
        this.buildTextNode = buildEmptyTextNode;
        this.buildObjNode = buildEmptyObjNode;
      } else {
        this.buildTextNode = buildTextValNode;
        this.buildObjNode = buildObjectNode;
      }
      this.buildTextValNode = buildTextValNode;
      this.buildObjectNode = buildObjectNode;
    }
    Parser.prototype.parse = function(jObj) {
      return this.j2x(jObj, 0).val;
    };
    Parser.prototype.j2x = function(jObj, level) {
      let attrStr = "";
      let val = "";
      const keys = Object.keys(jObj);
      const len = keys.length;
      for (let i = 0; i < len; i++) {
        const key = keys[i];
        if (typeof jObj[key] === "undefined") {
        } else if (jObj[key] === null) {
          val += this.indentate(level) + "<" + key + "/" + this.tagEndChar;
        } else if (jObj[key] instanceof Date) {
          val += this.buildTextNode(jObj[key], key, "", level);
        } else if (typeof jObj[key] !== "object") {
          const attr = this.isAttribute(key);
          if (attr) {
            attrStr += " " + attr + '="' + this.options.attrValueProcessor("" + jObj[key]) + '"';
          } else if (this.isCDATA(key)) {
            if (jObj[this.options.textNodeName]) {
              val += this.replaceCDATAstr(jObj[this.options.textNodeName], jObj[key]);
            } else {
              val += this.replaceCDATAstr("", jObj[key]);
            }
          } else {
            if (key === this.options.textNodeName) {
              if (jObj[this.options.cdataTagName]) {
              } else {
                val += this.options.tagValueProcessor("" + jObj[key]);
              }
            } else {
              val += this.buildTextNode(jObj[key], key, "", level);
            }
          }
        } else if (Array.isArray(jObj[key])) {
          if (this.isCDATA(key)) {
            val += this.indentate(level);
            if (jObj[this.options.textNodeName]) {
              val += this.replaceCDATAarr(jObj[this.options.textNodeName], jObj[key]);
            } else {
              val += this.replaceCDATAarr("", jObj[key]);
            }
          } else {
            const arrLen = jObj[key].length;
            for (let j = 0; j < arrLen; j++) {
              const item = jObj[key][j];
              if (typeof item === "undefined") {
              } else if (item === null) {
                val += this.indentate(level) + "<" + key + "/" + this.tagEndChar;
              } else if (typeof item === "object") {
                const result = this.j2x(item, level + 1);
                val += this.buildObjNode(result.val, key, result.attrStr, level);
              } else {
                val += this.buildTextNode(item, key, "", level);
              }
            }
          }
        } else {
          if (this.options.attrNodeName && key === this.options.attrNodeName) {
            const Ks = Object.keys(jObj[key]);
            const L = Ks.length;
            for (let j = 0; j < L; j++) {
              attrStr += " " + Ks[j] + '="' + this.options.attrValueProcessor("" + jObj[key][Ks[j]]) + '"';
            }
          } else {
            const result = this.j2x(jObj[key], level + 1);
            val += this.buildObjNode(result.val, key, result.attrStr, level);
          }
        }
      }
      return { attrStr, val };
    };
    function replaceCDATAstr(str, cdata) {
      str = this.options.tagValueProcessor("" + str);
      if (this.options.cdataPositionChar === "" || str === "") {
        return str + "<![CDATA[" + cdata + "]]" + this.tagEndChar;
      } else {
        return str.replace(this.options.cdataPositionChar, "<![CDATA[" + cdata + "]]" + this.tagEndChar);
      }
    }
    function replaceCDATAarr(str, cdata) {
      str = this.options.tagValueProcessor("" + str);
      if (this.options.cdataPositionChar === "" || str === "") {
        return str + "<![CDATA[" + cdata.join("]]><![CDATA[") + "]]" + this.tagEndChar;
      } else {
        for (let v in cdata) {
          str = str.replace(this.options.cdataPositionChar, "<![CDATA[" + cdata[v] + "]]>");
        }
        return str + this.newLine;
      }
    }
    function buildObjectNode(val, key, attrStr, level) {
      if (attrStr && !val.includes("<")) {
        return this.indentate(level) + "<" + key + attrStr + ">" + val + "</" + key + this.tagEndChar;
      } else {
        return this.indentate(level) + "<" + key + attrStr + this.tagEndChar + val + this.indentate(level) + "</" + key + this.tagEndChar;
      }
    }
    function buildEmptyObjNode(val, key, attrStr, level) {
      if (val !== "") {
        return this.buildObjectNode(val, key, attrStr, level);
      } else {
        return this.indentate(level) + "<" + key + attrStr + "/" + this.tagEndChar;
      }
    }
    function buildTextValNode(val, key, attrStr, level) {
      return this.indentate(level) + "<" + key + attrStr + ">" + this.options.tagValueProcessor(val) + "</" + key + this.tagEndChar;
    }
    function buildEmptyTextNode(val, key, attrStr, level) {
      if (val !== "") {
        return this.buildTextValNode(val, key, attrStr, level);
      } else {
        return this.indentate(level) + "<" + key + attrStr + "/" + this.tagEndChar;
      }
    }
    function indentate(level) {
      return this.options.indentBy.repeat(level);
    }
    function isAttribute(name) {
      if (name.startsWith(this.options.attributeNamePrefix)) {
        return name.substr(this.attrPrefixLen);
      } else {
        return false;
      }
    }
    function isCDATA(name) {
      return name === this.options.cdataTagName;
    }
    module2.exports = Parser;
  }
});

// node_modules/fast-xml-parser/src/parser.js
var require_parser = __commonJS({
  "node_modules/fast-xml-parser/src/parser.js"(exports) {
    init_shims();
    "use strict";
    var nodeToJson = require_node2json();
    var xmlToNodeobj = require_xmlstr2xmlnode();
    var x2xmlnode = require_xmlstr2xmlnode();
    var buildOptions = require_util().buildOptions;
    var validator = require_validator();
    exports.parse = function(xmlData, options2, validationOption) {
      if (validationOption) {
        if (validationOption === true)
          validationOption = {};
        const result = validator.validate(xmlData, validationOption);
        if (result !== true) {
          throw Error(result.err.msg);
        }
      }
      options2 = buildOptions(options2, x2xmlnode.defaultOptions, x2xmlnode.props);
      const traversableObj = xmlToNodeobj.getTraversalObj(xmlData, options2);
      return nodeToJson.convertToJson(traversableObj, options2);
    };
    exports.convertTonimn = require_nimndata().convert2nimn;
    exports.getTraversalObj = xmlToNodeobj.getTraversalObj;
    exports.convertToJson = nodeToJson.convertToJson;
    exports.convertToJsonString = require_node2json_str().convertToJsonString;
    exports.validate = validator.validate;
    exports.j2xParser = require_json2xml();
    exports.parseToNimn = function(xmlData, schema, options2) {
      return exports.convertTonimn(exports.getTraversalObj(xmlData, options2), schema, options2);
    };
  }
});

// node_modules/fuzzyjs/build/cjs/index.js
var require_cjs = __commonJS({
  "node_modules/fuzzyjs/build/cjs/index.js"(exports) {
    init_shims();
    var __defProp2 = Object.defineProperty;
    var __markAsModule2 = (target) => __defProp2(target, "__esModule", { value: true });
    var __export2 = (target, all) => {
      __markAsModule2(target);
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    __export2(exports, {
      filter: () => filter,
      match: () => match2,
      sort: () => sort,
      surround: () => surround,
      test: () => test
    });
    function reshapeInput(query, source, opts) {
      if (typeof query !== "string") {
        throw new TypeError("Expecting query to be a string");
      }
      if (typeof source !== "string") {
        throw new TypeError("Expecting source to be a string");
      }
      let reshapedQuery = query.normalize("NFD").replace(/[\u0300-\u036f]/g, "");
      let reshapedSource = source.normalize("NFD").replace(/[\u0300-\u036f]/g, "");
      if (!opts.caseSensitive) {
        reshapedQuery = reshapedQuery.toLowerCase();
        reshapedSource = reshapedSource.toLowerCase();
      }
      return [reshapedQuery, reshapedSource];
    }
    function test(query, source, opts = {}) {
      const [reshapedQuery, reshapedSource] = reshapeInput(query, source, opts);
      if (!reshapedSource.length) {
        return !query.length;
      }
      if (!reshapedQuery.length) {
        return true;
      }
      if (reshapedQuery.length > reshapedSource.length) {
        return false;
      }
      let queryPos = 0;
      let sourcePos = 0;
      while (sourcePos < source.length) {
        const actualSourceCharacter = reshapedSource[sourcePos];
        const queryCharacterWaitingForMatch = reshapedQuery[queryPos];
        if (actualSourceCharacter === queryCharacterWaitingForMatch) {
          queryPos += 1;
        }
        sourcePos += 1;
      }
      return queryPos === reshapedQuery.length;
    }
    function pushRange(ranges, sourcePos) {
      const lastRange = ranges[ranges.length - 1];
      if (lastRange && lastRange.stop === sourcePos) {
        return [
          ...ranges.slice(0, -1),
          {
            start: lastRange.start,
            stop: sourcePos + 1
          }
        ];
      } else {
        return [...ranges, { start: sourcePos, stop: sourcePos + 1 }];
      }
    }
    function pushScore(previousContext, context) {
      if (!context) {
        throw new TypeError("Expecting context to be defined");
      }
      if (!context.match) {
        return context.currentScore - 1;
      }
      let increment = 0;
      if (previousContext && previousContext.match) {
        increment += 5;
      }
      if (context.leading) {
        increment += 10;
      }
      return context.currentScore + increment;
    }
    function toLatin(str) {
      return str.normalize("NFD").replace(/[\u0300-\u036f]/g, "");
    }
    function isLeading(prevChar, char) {
      const precededBySeparator = prevChar === "-" || prevChar === "_" || prevChar === " " || prevChar === "." || prevChar === "/" || prevChar === "\\";
      const isCharLeading = char.toUpperCase() === char && /\w/.test(toLatin(char));
      return precededBySeparator || isCharLeading;
    }
    function match2(query, source, opts = { withScore: true }) {
      const [reshapedQuery, reshapedSource] = reshapeInput(query, source, opts);
      const withScore = !(opts?.withScore === false);
      if (reshapedSource.length === 0 || reshapedQuery.length === 0) {
        return {
          match: query.length === 0,
          ranges: query.length === 0 ? [{ start: 0, stop: reshapedSource.length }] : [],
          score: withScore ? query.length === 0 ? 1 : 0 : void 0
        };
      }
      if (reshapedQuery.length > reshapedSource.length) {
        return { match: false, ranges: [], score: withScore ? 0 : void 0 };
      }
      let queryPos = 0;
      let sourcePos = 0;
      let score = 0;
      let lastContext;
      let ranges = [];
      while (sourcePos < source.length) {
        const actualSourceCharacter = reshapedSource[sourcePos];
        const queryCharacterWaitingForMatch = reshapedQuery[queryPos];
        const match22 = actualSourceCharacter === queryCharacterWaitingForMatch;
        if (withScore) {
          const previousCharacter = sourcePos > 0 ? source[sourcePos - 1] : "";
          const newContext = {
            currentScore: score,
            character: source[sourcePos],
            match: match22,
            leading: isLeading(previousCharacter, source[sourcePos])
          };
          score = pushScore(lastContext, newContext);
          lastContext = newContext;
        }
        if (match22) {
          ranges = pushRange(ranges, sourcePos);
          queryPos += 1;
        }
        sourcePos += 1;
      }
      if (queryPos === reshapedQuery.length) {
        return {
          match: true,
          ranges,
          score: withScore ? score : void 0
        };
      }
      return {
        match: false,
        ranges: [],
        score: withScore ? 0 : void 0
      };
    }
    function filter(query, options2) {
      return function(item) {
        const source = options2.iterator(item);
        return test(query, source, options2);
      };
    }
    function sort(query, options2) {
      const cacheMap = new Map();
      return (leftItem, rightItem) => {
        const leftSource = options2.iterator(leftItem);
        const rightSource = options2.iterator(rightItem);
        const cachedLeftMatch = cacheMap.get(leftSource);
        const cachedRightMatch = cacheMap.get(rightSource);
        const leftScore = cachedLeftMatch ? cachedLeftMatch : match2(query, leftSource, {
          withScore: true,
          caseSensitive: options2.caseSensitive
        }).score;
        const rightScore = cachedRightMatch ? cachedRightMatch : match2(query, rightSource, {
          withScore: true,
          caseSensitive: options2.caseSensitive
        }).score;
        if (!cacheMap.has(leftSource)) {
          cacheMap.set(leftSource, leftScore);
        }
        if (!cacheMap.has(rightSource)) {
          cacheMap.set(rightSource, rightScore);
        }
        if (rightScore === leftScore) {
          return 0;
        }
        return rightScore > leftScore ? 1 : -1;
      };
    }
    function surround(source, options2) {
      if (typeof source !== "string") {
        throw new TypeError("Expecting source to be a string");
      }
      if (source.length === 0) {
        return "";
      }
      if (!options2?.result?.ranges?.length) {
        return source;
      }
      let result = source;
      let accumulator = 0;
      for (const range of options2.result.ranges) {
        result = insertAt(result, range.start + accumulator, options2.prefix);
        accumulator += (options2.prefix ?? "").length;
        result = insertAt(result, range.stop + accumulator, options2.suffix);
        accumulator += (options2.suffix ?? "").length;
      }
      return result;
    }
    function insertAt(input, index2, patch = "") {
      return input.slice(0, index2) + patch + input.slice(index2);
    }
  }
});

// .svelte-kit/vercel/entry.js
__export(exports, {
  default: () => entry_default
});
init_shims();

// node_modules/@sveltejs/kit/dist/node.js
init_shims();
function getRawBody(req) {
  return new Promise((fulfil, reject) => {
    const h = req.headers;
    if (!h["content-type"]) {
      return fulfil(null);
    }
    req.on("error", reject);
    const length = Number(h["content-length"]);
    if (isNaN(length) && h["transfer-encoding"] == null) {
      return fulfil(null);
    }
    let data2 = new Uint8Array(length || 0);
    if (length > 0) {
      let offset2 = 0;
      req.on("data", (chunk) => {
        const new_len = offset2 + Buffer.byteLength(chunk);
        if (new_len > length) {
          return reject({
            status: 413,
            reason: 'Exceeded "Content-Length" limit'
          });
        }
        data2.set(chunk, offset2);
        offset2 = new_len;
      });
    } else {
      req.on("data", (chunk) => {
        const new_data = new Uint8Array(data2.length + chunk.length);
        new_data.set(data2, 0);
        new_data.set(chunk, data2.length);
        data2 = new_data;
      });
    }
    req.on("end", () => {
      fulfil(data2);
    });
  });
}

// .svelte-kit/output/server/app.js
init_shims();
var import_fast_xml_parser = __toModule(require_parser());
var import_fuzzyjs = __toModule(require_cjs());
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var _map;
function get_single_valued_header(headers, key) {
  const value = headers[key];
  if (Array.isArray(value)) {
    if (value.length === 0) {
      return void 0;
    }
    if (value.length > 1) {
      throw new Error(`Multiple headers provided for ${key}. Multiple may be provided only for set-cookie`);
    }
    return value[0];
  }
  return value;
}
function coalesce_to_error(err) {
  return err instanceof Error || err && err.name && err.message ? err : new Error(JSON.stringify(err));
}
function lowercase_keys(obj) {
  const clone2 = {};
  for (const key in obj) {
    clone2[key.toLowerCase()] = obj[key];
  }
  return clone2;
}
function error(body) {
  return {
    status: 500,
    body,
    headers: {}
  };
}
function is_string(s2) {
  return typeof s2 === "string" || s2 instanceof String;
}
function is_content_type_textual(content_type) {
  if (!content_type)
    return true;
  const [type] = content_type.split(";");
  return type === "text/plain" || type === "application/json" || type === "application/x-www-form-urlencoded" || type === "multipart/form-data";
}
async function render_endpoint(request, route, match2) {
  const mod = await route.load();
  const handler = mod[request.method.toLowerCase().replace("delete", "del")];
  if (!handler) {
    return;
  }
  const params = route.params(match2);
  const response = await handler({ ...request, params });
  const preface = `Invalid response from route ${request.path}`;
  if (!response) {
    return;
  }
  if (typeof response !== "object") {
    return error(`${preface}: expected an object, got ${typeof response}`);
  }
  let { status = 200, body, headers = {} } = response;
  headers = lowercase_keys(headers);
  const type = get_single_valued_header(headers, "content-type");
  const is_type_textual = is_content_type_textual(type);
  if (!is_type_textual && !(body instanceof Uint8Array || is_string(body))) {
    return error(`${preface}: body must be an instance of string or Uint8Array if content-type is not a supported textual content-type`);
  }
  let normalized_body;
  if ((typeof body === "object" || typeof body === "undefined") && !(body instanceof Uint8Array) && (!type || type.startsWith("application/json"))) {
    headers = { ...headers, "content-type": "application/json; charset=utf-8" };
    normalized_body = JSON.stringify(typeof body === "undefined" ? {} : body);
  } else {
    normalized_body = body;
  }
  return { status, body: normalized_body, headers };
}
var chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_$";
var unsafeChars = /[<>\b\f\n\r\t\0\u2028\u2029]/g;
var reserved = /^(?:do|if|in|for|int|let|new|try|var|byte|case|char|else|enum|goto|long|this|void|with|await|break|catch|class|const|final|float|short|super|throw|while|yield|delete|double|export|import|native|return|switch|throws|typeof|boolean|default|extends|finally|package|private|abstract|continue|debugger|function|volatile|interface|protected|transient|implements|instanceof|synchronized)$/;
var escaped$1 = {
  "<": "\\u003C",
  ">": "\\u003E",
  "/": "\\u002F",
  "\\": "\\\\",
  "\b": "\\b",
  "\f": "\\f",
  "\n": "\\n",
  "\r": "\\r",
  "	": "\\t",
  "\0": "\\0",
  "\u2028": "\\u2028",
  "\u2029": "\\u2029"
};
var objectProtoOwnPropertyNames = Object.getOwnPropertyNames(Object.prototype).sort().join("\0");
function devalue(value) {
  var counts = new Map();
  function walk(thing) {
    if (typeof thing === "function") {
      throw new Error("Cannot stringify a function");
    }
    if (counts.has(thing)) {
      counts.set(thing, counts.get(thing) + 1);
      return;
    }
    counts.set(thing, 1);
    if (!isPrimitive(thing)) {
      var type = getType(thing);
      switch (type) {
        case "Number":
        case "String":
        case "Boolean":
        case "Date":
        case "RegExp":
          return;
        case "Array":
          thing.forEach(walk);
          break;
        case "Set":
        case "Map":
          Array.from(thing).forEach(walk);
          break;
        default:
          var proto = Object.getPrototypeOf(thing);
          if (proto !== Object.prototype && proto !== null && Object.getOwnPropertyNames(proto).sort().join("\0") !== objectProtoOwnPropertyNames) {
            throw new Error("Cannot stringify arbitrary non-POJOs");
          }
          if (Object.getOwnPropertySymbols(thing).length > 0) {
            throw new Error("Cannot stringify POJOs with symbolic keys");
          }
          Object.keys(thing).forEach(function(key) {
            return walk(thing[key]);
          });
      }
    }
  }
  walk(value);
  var names = new Map();
  Array.from(counts).filter(function(entry) {
    return entry[1] > 1;
  }).sort(function(a, b) {
    return b[1] - a[1];
  }).forEach(function(entry, i) {
    names.set(entry[0], getName(i));
  });
  function stringify(thing) {
    if (names.has(thing)) {
      return names.get(thing);
    }
    if (isPrimitive(thing)) {
      return stringifyPrimitive(thing);
    }
    var type = getType(thing);
    switch (type) {
      case "Number":
      case "String":
      case "Boolean":
        return "Object(" + stringify(thing.valueOf()) + ")";
      case "RegExp":
        return "new RegExp(" + stringifyString(thing.source) + ', "' + thing.flags + '")';
      case "Date":
        return "new Date(" + thing.getTime() + ")";
      case "Array":
        var members = thing.map(function(v, i) {
          return i in thing ? stringify(v) : "";
        });
        var tail = thing.length === 0 || thing.length - 1 in thing ? "" : ",";
        return "[" + members.join(",") + tail + "]";
      case "Set":
      case "Map":
        return "new " + type + "([" + Array.from(thing).map(stringify).join(",") + "])";
      default:
        var obj = "{" + Object.keys(thing).map(function(key) {
          return safeKey(key) + ":" + stringify(thing[key]);
        }).join(",") + "}";
        var proto = Object.getPrototypeOf(thing);
        if (proto === null) {
          return Object.keys(thing).length > 0 ? "Object.assign(Object.create(null)," + obj + ")" : "Object.create(null)";
        }
        return obj;
    }
  }
  var str = stringify(value);
  if (names.size) {
    var params_1 = [];
    var statements_1 = [];
    var values_1 = [];
    names.forEach(function(name, thing) {
      params_1.push(name);
      if (isPrimitive(thing)) {
        values_1.push(stringifyPrimitive(thing));
        return;
      }
      var type = getType(thing);
      switch (type) {
        case "Number":
        case "String":
        case "Boolean":
          values_1.push("Object(" + stringify(thing.valueOf()) + ")");
          break;
        case "RegExp":
          values_1.push(thing.toString());
          break;
        case "Date":
          values_1.push("new Date(" + thing.getTime() + ")");
          break;
        case "Array":
          values_1.push("Array(" + thing.length + ")");
          thing.forEach(function(v, i) {
            statements_1.push(name + "[" + i + "]=" + stringify(v));
          });
          break;
        case "Set":
          values_1.push("new Set");
          statements_1.push(name + "." + Array.from(thing).map(function(v) {
            return "add(" + stringify(v) + ")";
          }).join("."));
          break;
        case "Map":
          values_1.push("new Map");
          statements_1.push(name + "." + Array.from(thing).map(function(_a) {
            var k = _a[0], v = _a[1];
            return "set(" + stringify(k) + ", " + stringify(v) + ")";
          }).join("."));
          break;
        default:
          values_1.push(Object.getPrototypeOf(thing) === null ? "Object.create(null)" : "{}");
          Object.keys(thing).forEach(function(key) {
            statements_1.push("" + name + safeProp(key) + "=" + stringify(thing[key]));
          });
      }
    });
    statements_1.push("return " + str);
    return "(function(" + params_1.join(",") + "){" + statements_1.join(";") + "}(" + values_1.join(",") + "))";
  } else {
    return str;
  }
}
function getName(num) {
  var name = "";
  do {
    name = chars[num % chars.length] + name;
    num = ~~(num / chars.length) - 1;
  } while (num >= 0);
  return reserved.test(name) ? name + "_" : name;
}
function isPrimitive(thing) {
  return Object(thing) !== thing;
}
function stringifyPrimitive(thing) {
  if (typeof thing === "string")
    return stringifyString(thing);
  if (thing === void 0)
    return "void 0";
  if (thing === 0 && 1 / thing < 0)
    return "-0";
  var str = String(thing);
  if (typeof thing === "number")
    return str.replace(/^(-)?0\./, "$1.");
  return str;
}
function getType(thing) {
  return Object.prototype.toString.call(thing).slice(8, -1);
}
function escapeUnsafeChar(c) {
  return escaped$1[c] || c;
}
function escapeUnsafeChars(str) {
  return str.replace(unsafeChars, escapeUnsafeChar);
}
function safeKey(key) {
  return /^[_$a-zA-Z][_$a-zA-Z0-9]*$/.test(key) ? key : escapeUnsafeChars(JSON.stringify(key));
}
function safeProp(key) {
  return /^[_$a-zA-Z][_$a-zA-Z0-9]*$/.test(key) ? "." + key : "[" + escapeUnsafeChars(JSON.stringify(key)) + "]";
}
function stringifyString(str) {
  var result = '"';
  for (var i = 0; i < str.length; i += 1) {
    var char = str.charAt(i);
    var code = char.charCodeAt(0);
    if (char === '"') {
      result += '\\"';
    } else if (char in escaped$1) {
      result += escaped$1[char];
    } else if (code >= 55296 && code <= 57343) {
      var next = str.charCodeAt(i + 1);
      if (code <= 56319 && (next >= 56320 && next <= 57343)) {
        result += char + str[++i];
      } else {
        result += "\\u" + code.toString(16).toUpperCase();
      }
    } else {
      result += char;
    }
  }
  result += '"';
  return result;
}
function noop$1() {
}
function safe_not_equal$1(a, b) {
  return a != a ? b == b : a !== b || (a && typeof a === "object" || typeof a === "function");
}
Promise.resolve();
var subscriber_queue$1 = [];
function writable$1(value, start = noop$1) {
  let stop;
  const subscribers = new Set();
  function set(new_value) {
    if (safe_not_equal$1(value, new_value)) {
      value = new_value;
      if (stop) {
        const run_queue = !subscriber_queue$1.length;
        for (const subscriber of subscribers) {
          subscriber[1]();
          subscriber_queue$1.push(subscriber, value);
        }
        if (run_queue) {
          for (let i = 0; i < subscriber_queue$1.length; i += 2) {
            subscriber_queue$1[i][0](subscriber_queue$1[i + 1]);
          }
          subscriber_queue$1.length = 0;
        }
      }
    }
  }
  function update(fn) {
    set(fn(value));
  }
  function subscribe2(run2, invalidate = noop$1) {
    const subscriber = [run2, invalidate];
    subscribers.add(subscriber);
    if (subscribers.size === 1) {
      stop = start(set) || noop$1;
    }
    run2(value);
    return () => {
      subscribers.delete(subscriber);
      if (subscribers.size === 0) {
        stop();
        stop = null;
      }
    };
  }
  return { set, update, subscribe: subscribe2 };
}
function hash(value) {
  let hash2 = 5381;
  let i = value.length;
  if (typeof value === "string") {
    while (i)
      hash2 = hash2 * 33 ^ value.charCodeAt(--i);
  } else {
    while (i)
      hash2 = hash2 * 33 ^ value[--i];
  }
  return (hash2 >>> 0).toString(36);
}
var escape_json_string_in_html_dict = {
  '"': '\\"',
  "<": "\\u003C",
  ">": "\\u003E",
  "/": "\\u002F",
  "\\": "\\\\",
  "\b": "\\b",
  "\f": "\\f",
  "\n": "\\n",
  "\r": "\\r",
  "	": "\\t",
  "\0": "\\0",
  "\u2028": "\\u2028",
  "\u2029": "\\u2029"
};
function escape_json_string_in_html(str) {
  return escape$1(str, escape_json_string_in_html_dict, (code) => `\\u${code.toString(16).toUpperCase()}`);
}
var escape_html_attr_dict = {
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;"
};
function escape_html_attr(str) {
  return '"' + escape$1(str, escape_html_attr_dict, (code) => `&#${code};`) + '"';
}
function escape$1(str, dict, unicode_encoder) {
  let result = "";
  for (let i = 0; i < str.length; i += 1) {
    const char = str.charAt(i);
    const code = char.charCodeAt(0);
    if (char in dict) {
      result += dict[char];
    } else if (code >= 55296 && code <= 57343) {
      const next = str.charCodeAt(i + 1);
      if (code <= 56319 && next >= 56320 && next <= 57343) {
        result += char + str[++i];
      } else {
        result += unicode_encoder(code);
      }
    } else {
      result += char;
    }
  }
  return result;
}
var s$1 = JSON.stringify;
async function render_response({
  branch,
  options: options2,
  $session,
  page_config,
  status,
  error: error2,
  page
}) {
  const css2 = new Set(options2.entry.css);
  const js = new Set(options2.entry.js);
  const styles = new Set();
  const serialized_data = [];
  let rendered;
  let is_private = false;
  let maxage;
  if (error2) {
    error2.stack = options2.get_stack(error2);
  }
  if (page_config.ssr) {
    branch.forEach(({ node, loaded, fetched, uses_credentials }) => {
      if (node.css)
        node.css.forEach((url) => css2.add(url));
      if (node.js)
        node.js.forEach((url) => js.add(url));
      if (node.styles)
        node.styles.forEach((content) => styles.add(content));
      if (fetched && page_config.hydrate)
        serialized_data.push(...fetched);
      if (uses_credentials)
        is_private = true;
      maxage = loaded.maxage;
    });
    const session = writable$1($session);
    const props = {
      stores: {
        page: writable$1(null),
        navigating: writable$1(null),
        session
      },
      page,
      components: branch.map(({ node }) => node.module.default)
    };
    for (let i = 0; i < branch.length; i += 1) {
      props[`props_${i}`] = await branch[i].loaded.props;
    }
    let session_tracking_active = false;
    const unsubscribe = session.subscribe(() => {
      if (session_tracking_active)
        is_private = true;
    });
    session_tracking_active = true;
    try {
      rendered = options2.root.render(props);
    } finally {
      unsubscribe();
    }
  } else {
    rendered = { head: "", html: "", css: { code: "", map: null } };
  }
  const include_js = page_config.router || page_config.hydrate;
  if (!include_js)
    js.clear();
  const links = options2.amp ? styles.size > 0 || rendered.css.code.length > 0 ? `<style amp-custom>${Array.from(styles).concat(rendered.css.code).join("\n")}</style>` : "" : [
    ...Array.from(js).map((dep) => `<link rel="modulepreload" href="${dep}">`),
    ...Array.from(css2).map((dep) => `<link rel="stylesheet" href="${dep}">`)
  ].join("\n		");
  let init2 = "";
  if (options2.amp) {
    init2 = `
		<style amp-boilerplate>body{-webkit-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-moz-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-ms-animation:-amp-start 8s steps(1,end) 0s 1 normal both;animation:-amp-start 8s steps(1,end) 0s 1 normal both}@-webkit-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-moz-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-ms-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-o-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}</style>
		<noscript><style amp-boilerplate>body{-webkit-animation:none;-moz-animation:none;-ms-animation:none;animation:none}</style></noscript>
		<script async src="https://cdn.ampproject.org/v0.js"><\/script>`;
  } else if (include_js) {
    init2 = `<script type="module">
			import { start } from ${s$1(options2.entry.file)};
			start({
				target: ${options2.target ? `document.querySelector(${s$1(options2.target)})` : "document.body"},
				paths: ${s$1(options2.paths)},
				session: ${try_serialize($session, (error3) => {
      throw new Error(`Failed to serialize session data: ${error3.message}`);
    })},
				host: ${page && page.host ? s$1(page.host) : "location.host"},
				route: ${!!page_config.router},
				spa: ${!page_config.ssr},
				trailing_slash: ${s$1(options2.trailing_slash)},
				hydrate: ${page_config.ssr && page_config.hydrate ? `{
					status: ${status},
					error: ${serialize_error(error2)},
					nodes: [
						${(branch || []).map(({ node }) => `import(${s$1(node.entry)})`).join(",\n						")}
					],
					page: {
						host: ${page && page.host ? s$1(page.host) : "location.host"}, // TODO this is redundant
						path: ${s$1(page && page.path)},
						query: new URLSearchParams(${page ? s$1(page.query.toString()) : ""}),
						params: ${page && s$1(page.params)}
					}
				}` : "null"}
			});
		<\/script>`;
  }
  if (options2.service_worker) {
    init2 += `<script>
			if ('serviceWorker' in navigator) {
				navigator.serviceWorker.register('${options2.service_worker}');
			}
		<\/script>`;
  }
  const head = [
    rendered.head,
    styles.size && !options2.amp ? `<style data-svelte>${Array.from(styles).join("\n")}</style>` : "",
    links,
    init2
  ].join("\n\n		");
  const body = options2.amp ? rendered.html : `${rendered.html}

			${serialized_data.map(({ url, body: body2, json }) => {
    let attributes = `type="application/json" data-type="svelte-data" data-url=${escape_html_attr(url)}`;
    if (body2)
      attributes += ` data-body="${hash(body2)}"`;
    return `<script ${attributes}>${json}<\/script>`;
  }).join("\n\n	")}
		`;
  const headers = {
    "content-type": "text/html"
  };
  if (maxage) {
    headers["cache-control"] = `${is_private ? "private" : "public"}, max-age=${maxage}`;
  }
  if (!options2.floc) {
    headers["permissions-policy"] = "interest-cohort=()";
  }
  return {
    status,
    headers,
    body: options2.template({ head, body })
  };
}
function try_serialize(data2, fail) {
  try {
    return devalue(data2);
  } catch (err) {
    if (fail)
      fail(coalesce_to_error(err));
    return null;
  }
}
function serialize_error(error2) {
  if (!error2)
    return null;
  let serialized = try_serialize(error2);
  if (!serialized) {
    const { name, message, stack } = error2;
    serialized = try_serialize({ ...error2, name, message, stack });
  }
  if (!serialized) {
    serialized = "{}";
  }
  return serialized;
}
function normalize(loaded) {
  const has_error_status = loaded.status && loaded.status >= 400 && loaded.status <= 599 && !loaded.redirect;
  if (loaded.error || has_error_status) {
    const status = loaded.status;
    if (!loaded.error && has_error_status) {
      return {
        status: status || 500,
        error: new Error()
      };
    }
    const error2 = typeof loaded.error === "string" ? new Error(loaded.error) : loaded.error;
    if (!(error2 instanceof Error)) {
      return {
        status: 500,
        error: new Error(`"error" property returned from load() must be a string or instance of Error, received type "${typeof error2}"`)
      };
    }
    if (!status || status < 400 || status > 599) {
      console.warn('"error" returned from load() without a valid status code \u2014 defaulting to 500');
      return { status: 500, error: error2 };
    }
    return { status, error: error2 };
  }
  if (loaded.redirect) {
    if (!loaded.status || Math.floor(loaded.status / 100) !== 3) {
      return {
        status: 500,
        error: new Error('"redirect" property returned from load() must be accompanied by a 3xx status code')
      };
    }
    if (typeof loaded.redirect !== "string") {
      return {
        status: 500,
        error: new Error('"redirect" property returned from load() must be a string')
      };
    }
  }
  if (loaded.context) {
    throw new Error('You are returning "context" from a load function. "context" was renamed to "stuff", please adjust your code accordingly.');
  }
  return loaded;
}
var s = JSON.stringify;
async function load_node({
  request,
  options: options2,
  state,
  route,
  page,
  node,
  $session,
  stuff,
  prerender_enabled,
  is_leaf,
  is_error,
  status,
  error: error2
}) {
  const { module: module2 } = node;
  let uses_credentials = false;
  const fetched = [];
  let set_cookie_headers = [];
  let loaded;
  const page_proxy = new Proxy(page, {
    get: (target, prop, receiver) => {
      if (prop === "query" && prerender_enabled) {
        throw new Error("Cannot access query on a page with prerendering enabled");
      }
      return Reflect.get(target, prop, receiver);
    }
  });
  if (module2.load) {
    const load_input = {
      page: page_proxy,
      get session() {
        uses_credentials = true;
        return $session;
      },
      fetch: async (resource, opts = {}) => {
        let url;
        if (typeof resource === "string") {
          url = resource;
        } else {
          url = resource.url;
          opts = {
            method: resource.method,
            headers: resource.headers,
            body: resource.body,
            mode: resource.mode,
            credentials: resource.credentials,
            cache: resource.cache,
            redirect: resource.redirect,
            referrer: resource.referrer,
            integrity: resource.integrity,
            ...opts
          };
        }
        const resolved = resolve(request.path, url.split("?")[0]);
        let response;
        const filename = resolved.replace(options2.paths.assets, "").slice(1);
        const filename_html = `${filename}/index.html`;
        const asset = options2.manifest.assets.find((d2) => d2.file === filename || d2.file === filename_html);
        if (asset) {
          response = options2.read ? new Response(options2.read(asset.file), {
            headers: asset.type ? { "content-type": asset.type } : {}
          }) : await fetch(`http://${page.host}/${asset.file}`, opts);
        } else if (resolved.startsWith("/") && !resolved.startsWith("//")) {
          const relative = resolved;
          const headers = {
            ...opts.headers
          };
          if (opts.credentials !== "omit") {
            uses_credentials = true;
            headers.cookie = request.headers.cookie;
            if (!headers.authorization) {
              headers.authorization = request.headers.authorization;
            }
          }
          if (opts.body && typeof opts.body !== "string") {
            throw new Error("Request body must be a string");
          }
          const search = url.includes("?") ? url.slice(url.indexOf("?") + 1) : "";
          const rendered = await respond({
            host: request.host,
            method: opts.method || "GET",
            headers,
            path: relative,
            rawBody: opts.body == null ? null : new TextEncoder().encode(opts.body),
            query: new URLSearchParams(search)
          }, options2, {
            fetched: url,
            initiator: route
          });
          if (rendered) {
            if (state.prerender) {
              state.prerender.dependencies.set(relative, rendered);
            }
            response = new Response(rendered.body, {
              status: rendered.status,
              headers: rendered.headers
            });
          }
        } else {
          if (resolved.startsWith("//")) {
            throw new Error(`Cannot request protocol-relative URL (${url}) in server-side fetch`);
          }
          if (typeof request.host !== "undefined") {
            const { hostname: fetch_hostname } = new URL(url);
            const [server_hostname] = request.host.split(":");
            if (`.${fetch_hostname}`.endsWith(`.${server_hostname}`) && opts.credentials !== "omit") {
              uses_credentials = true;
              opts.headers = {
                ...opts.headers,
                cookie: request.headers.cookie
              };
            }
          }
          const external_request = new Request(url, opts);
          response = await options2.hooks.externalFetch.call(null, external_request);
        }
        if (response) {
          const proxy = new Proxy(response, {
            get(response2, key, receiver) {
              async function text() {
                const body = await response2.text();
                const headers = {};
                for (const [key2, value] of response2.headers) {
                  if (key2 === "set-cookie") {
                    set_cookie_headers = set_cookie_headers.concat(value);
                  } else if (key2 !== "etag") {
                    headers[key2] = value;
                  }
                }
                if (!opts.body || typeof opts.body === "string") {
                  fetched.push({
                    url,
                    body: opts.body,
                    json: `{"status":${response2.status},"statusText":${s(response2.statusText)},"headers":${s(headers)},"body":"${escape_json_string_in_html(body)}"}`
                  });
                }
                return body;
              }
              if (key === "text") {
                return text;
              }
              if (key === "json") {
                return async () => {
                  return JSON.parse(await text());
                };
              }
              return Reflect.get(response2, key, response2);
            }
          });
          return proxy;
        }
        return response || new Response("Not found", {
          status: 404
        });
      },
      stuff: { ...stuff }
    };
    if (is_error) {
      load_input.status = status;
      load_input.error = error2;
    }
    loaded = await module2.load.call(null, load_input);
  } else {
    loaded = {};
  }
  if (!loaded && is_leaf && !is_error)
    return;
  if (!loaded) {
    throw new Error(`${node.entry} - load must return a value except for page fall through`);
  }
  return {
    node,
    loaded: normalize(loaded),
    stuff: loaded.stuff || stuff,
    fetched,
    set_cookie_headers,
    uses_credentials
  };
}
var absolute = /^([a-z]+:)?\/?\//;
function resolve(base2, path) {
  const base_match = absolute.exec(base2);
  const path_match = absolute.exec(path);
  if (!base_match) {
    throw new Error(`bad base path: "${base2}"`);
  }
  const baseparts = path_match ? [] : base2.slice(base_match[0].length).split("/");
  const pathparts = path_match ? path.slice(path_match[0].length).split("/") : path.split("/");
  baseparts.pop();
  for (let i = 0; i < pathparts.length; i += 1) {
    const part = pathparts[i];
    if (part === ".")
      continue;
    else if (part === "..")
      baseparts.pop();
    else
      baseparts.push(part);
  }
  const prefix = path_match && path_match[0] || base_match && base_match[0] || "";
  return `${prefix}${baseparts.join("/")}`;
}
async function respond_with_error({ request, options: options2, state, $session, status, error: error2 }) {
  const default_layout = await options2.load_component(options2.manifest.layout);
  const default_error = await options2.load_component(options2.manifest.error);
  const page = {
    host: request.host,
    path: request.path,
    query: request.query,
    params: {}
  };
  const loaded = await load_node({
    request,
    options: options2,
    state,
    route: null,
    page,
    node: default_layout,
    $session,
    stuff: {},
    prerender_enabled: is_prerender_enabled(options2, default_error, state),
    is_leaf: false,
    is_error: false
  });
  const branch = [
    loaded,
    await load_node({
      request,
      options: options2,
      state,
      route: null,
      page,
      node: default_error,
      $session,
      stuff: loaded ? loaded.stuff : {},
      prerender_enabled: is_prerender_enabled(options2, default_error, state),
      is_leaf: false,
      is_error: true,
      status,
      error: error2
    })
  ];
  try {
    return await render_response({
      options: options2,
      $session,
      page_config: {
        hydrate: options2.hydrate,
        router: options2.router,
        ssr: options2.ssr
      },
      status,
      error: error2,
      branch,
      page
    });
  } catch (err) {
    const error3 = coalesce_to_error(err);
    options2.handle_error(error3, request);
    return {
      status: 500,
      headers: {},
      body: error3.stack
    };
  }
}
function is_prerender_enabled(options2, node, state) {
  return options2.prerender && (!!node.module.prerender || !!state.prerender && state.prerender.all);
}
async function respond$1(opts) {
  const { request, options: options2, state, $session, route } = opts;
  let nodes;
  try {
    nodes = await Promise.all(route.a.map((id) => id ? options2.load_component(id) : void 0));
  } catch (err) {
    const error3 = coalesce_to_error(err);
    options2.handle_error(error3, request);
    return await respond_with_error({
      request,
      options: options2,
      state,
      $session,
      status: 500,
      error: error3
    });
  }
  const leaf = nodes[nodes.length - 1].module;
  let page_config = get_page_config(leaf, options2);
  if (!leaf.prerender && state.prerender && !state.prerender.all) {
    return {
      status: 204,
      headers: {},
      body: ""
    };
  }
  let branch = [];
  let status = 200;
  let error2;
  let set_cookie_headers = [];
  ssr:
    if (page_config.ssr) {
      let stuff = {};
      for (let i = 0; i < nodes.length; i += 1) {
        const node = nodes[i];
        let loaded;
        if (node) {
          try {
            loaded = await load_node({
              ...opts,
              node,
              stuff,
              prerender_enabled: is_prerender_enabled(options2, node, state),
              is_leaf: i === nodes.length - 1,
              is_error: false
            });
            if (!loaded)
              return;
            set_cookie_headers = set_cookie_headers.concat(loaded.set_cookie_headers);
            if (loaded.loaded.redirect) {
              return with_cookies({
                status: loaded.loaded.status,
                headers: {
                  location: encodeURI(loaded.loaded.redirect)
                }
              }, set_cookie_headers);
            }
            if (loaded.loaded.error) {
              ({ status, error: error2 } = loaded.loaded);
            }
          } catch (err) {
            const e = coalesce_to_error(err);
            options2.handle_error(e, request);
            status = 500;
            error2 = e;
          }
          if (loaded && !error2) {
            branch.push(loaded);
          }
          if (error2) {
            while (i--) {
              if (route.b[i]) {
                const error_node = await options2.load_component(route.b[i]);
                let node_loaded;
                let j = i;
                while (!(node_loaded = branch[j])) {
                  j -= 1;
                }
                try {
                  const error_loaded = await load_node({
                    ...opts,
                    node: error_node,
                    stuff: node_loaded.stuff,
                    prerender_enabled: is_prerender_enabled(options2, error_node, state),
                    is_leaf: false,
                    is_error: true,
                    status,
                    error: error2
                  });
                  if (error_loaded.loaded.error) {
                    continue;
                  }
                  page_config = get_page_config(error_node.module, options2);
                  branch = branch.slice(0, j + 1).concat(error_loaded);
                  break ssr;
                } catch (err) {
                  const e = coalesce_to_error(err);
                  options2.handle_error(e, request);
                  continue;
                }
              }
            }
            return with_cookies(await respond_with_error({
              request,
              options: options2,
              state,
              $session,
              status,
              error: error2
            }), set_cookie_headers);
          }
        }
        if (loaded && loaded.loaded.stuff) {
          stuff = {
            ...stuff,
            ...loaded.loaded.stuff
          };
        }
      }
    }
  try {
    return with_cookies(await render_response({
      ...opts,
      page_config,
      status,
      error: error2,
      branch: branch.filter(Boolean)
    }), set_cookie_headers);
  } catch (err) {
    const error3 = coalesce_to_error(err);
    options2.handle_error(error3, request);
    return with_cookies(await respond_with_error({
      ...opts,
      status: 500,
      error: error3
    }), set_cookie_headers);
  }
}
function get_page_config(leaf, options2) {
  return {
    ssr: "ssr" in leaf ? !!leaf.ssr : options2.ssr,
    router: "router" in leaf ? !!leaf.router : options2.router,
    hydrate: "hydrate" in leaf ? !!leaf.hydrate : options2.hydrate
  };
}
function with_cookies(response, set_cookie_headers) {
  if (set_cookie_headers.length) {
    response.headers["set-cookie"] = set_cookie_headers;
  }
  return response;
}
async function render_page(request, route, match2, options2, state) {
  if (state.initiator === route) {
    return {
      status: 404,
      headers: {},
      body: `Not found: ${request.path}`
    };
  }
  const params = route.params(match2);
  const page = {
    host: request.host,
    path: request.path,
    query: request.query,
    params
  };
  const $session = await options2.hooks.getSession(request);
  const response = await respond$1({
    request,
    options: options2,
    state,
    $session,
    route,
    page
  });
  if (response) {
    return response;
  }
  if (state.fetched) {
    return {
      status: 500,
      headers: {},
      body: `Bad request in load function: failed to fetch ${state.fetched}`
    };
  }
}
function read_only_form_data() {
  const map = new Map();
  return {
    append(key, value) {
      if (map.has(key)) {
        (map.get(key) || []).push(value);
      } else {
        map.set(key, [value]);
      }
    },
    data: new ReadOnlyFormData(map)
  };
}
var ReadOnlyFormData = class {
  constructor(map) {
    __privateAdd(this, _map, void 0);
    __privateSet(this, _map, map);
  }
  get(key) {
    const value = __privateGet(this, _map).get(key);
    return value && value[0];
  }
  getAll(key) {
    return __privateGet(this, _map).get(key);
  }
  has(key) {
    return __privateGet(this, _map).has(key);
  }
  *[Symbol.iterator]() {
    for (const [key, value] of __privateGet(this, _map)) {
      for (let i = 0; i < value.length; i += 1) {
        yield [key, value[i]];
      }
    }
  }
  *entries() {
    for (const [key, value] of __privateGet(this, _map)) {
      for (let i = 0; i < value.length; i += 1) {
        yield [key, value[i]];
      }
    }
  }
  *keys() {
    for (const [key] of __privateGet(this, _map))
      yield key;
  }
  *values() {
    for (const [, value] of __privateGet(this, _map)) {
      for (let i = 0; i < value.length; i += 1) {
        yield value[i];
      }
    }
  }
};
_map = new WeakMap();
function parse_body(raw, headers) {
  if (!raw)
    return raw;
  const content_type = headers["content-type"];
  const [type, ...directives] = content_type ? content_type.split(/;\s*/) : [];
  const text = () => new TextDecoder(headers["content-encoding"] || "utf-8").decode(raw);
  switch (type) {
    case "text/plain":
      return text();
    case "application/json":
      return JSON.parse(text());
    case "application/x-www-form-urlencoded":
      return get_urlencoded(text());
    case "multipart/form-data": {
      const boundary = directives.find((directive) => directive.startsWith("boundary="));
      if (!boundary)
        throw new Error("Missing boundary");
      return get_multipart(text(), boundary.slice("boundary=".length));
    }
    default:
      return raw;
  }
}
function get_urlencoded(text) {
  const { data: data2, append } = read_only_form_data();
  text.replace(/\+/g, " ").split("&").forEach((str) => {
    const [key, value] = str.split("=");
    append(decodeURIComponent(key), decodeURIComponent(value));
  });
  return data2;
}
function get_multipart(text, boundary) {
  const parts = text.split(`--${boundary}`);
  if (parts[0] !== "" || parts[parts.length - 1].trim() !== "--") {
    throw new Error("Malformed form data");
  }
  const { data: data2, append } = read_only_form_data();
  parts.slice(1, -1).forEach((part) => {
    const match2 = /\s*([\s\S]+?)\r\n\r\n([\s\S]*)\s*/.exec(part);
    if (!match2) {
      throw new Error("Malformed form data");
    }
    const raw_headers = match2[1];
    const body = match2[2].trim();
    let key;
    const headers = {};
    raw_headers.split("\r\n").forEach((str) => {
      const [raw_header, ...raw_directives] = str.split("; ");
      let [name, value] = raw_header.split(": ");
      name = name.toLowerCase();
      headers[name] = value;
      const directives = {};
      raw_directives.forEach((raw_directive) => {
        const [name2, value2] = raw_directive.split("=");
        directives[name2] = JSON.parse(value2);
      });
      if (name === "content-disposition") {
        if (value !== "form-data")
          throw new Error("Malformed form data");
        if (directives.filename) {
          throw new Error("File upload is not yet implemented");
        }
        if (directives.name) {
          key = directives.name;
        }
      }
    });
    if (!key)
      throw new Error("Malformed form data");
    append(key, body);
  });
  return data2;
}
async function respond(incoming, options2, state = {}) {
  if (incoming.path !== "/" && options2.trailing_slash !== "ignore") {
    const has_trailing_slash = incoming.path.endsWith("/");
    if (has_trailing_slash && options2.trailing_slash === "never" || !has_trailing_slash && options2.trailing_slash === "always" && !(incoming.path.split("/").pop() || "").includes(".")) {
      const path = has_trailing_slash ? incoming.path.slice(0, -1) : incoming.path + "/";
      const q = incoming.query.toString();
      return {
        status: 301,
        headers: {
          location: options2.paths.base + path + (q ? `?${q}` : "")
        }
      };
    }
  }
  const headers = lowercase_keys(incoming.headers);
  const request = {
    ...incoming,
    headers,
    body: parse_body(incoming.rawBody, headers),
    params: {},
    locals: {}
  };
  try {
    return await options2.hooks.handle({
      request,
      resolve: async (request2) => {
        if (state.prerender && state.prerender.fallback) {
          return await render_response({
            options: options2,
            $session: await options2.hooks.getSession(request2),
            page_config: { ssr: false, router: true, hydrate: true },
            status: 200,
            branch: []
          });
        }
        const decoded = decodeURI(request2.path);
        for (const route of options2.manifest.routes) {
          const match2 = route.pattern.exec(decoded);
          if (!match2)
            continue;
          const response = route.type === "endpoint" ? await render_endpoint(request2, route, match2) : await render_page(request2, route, match2, options2, state);
          if (response) {
            if (response.status === 200) {
              const cache_control = get_single_valued_header(response.headers, "cache-control");
              if (!cache_control || !/(no-store|immutable)/.test(cache_control)) {
                const etag = `"${hash(response.body || "")}"`;
                if (request2.headers["if-none-match"] === etag) {
                  return {
                    status: 304,
                    headers: {},
                    body: ""
                  };
                }
                response.headers["etag"] = etag;
              }
            }
            return response;
          }
        }
        const $session = await options2.hooks.getSession(request2);
        return await respond_with_error({
          request: request2,
          options: options2,
          state,
          $session,
          status: 404,
          error: new Error(`Not found: ${request2.path}`)
        });
      }
    });
  } catch (err) {
    const e = coalesce_to_error(err);
    options2.handle_error(e, request);
    return {
      status: 500,
      headers: {},
      body: options2.dev ? e.stack : e.message
    };
  }
}
function noop() {
}
function is_promise(value) {
  return value && typeof value === "object" && typeof value.then === "function";
}
function run(fn) {
  return fn();
}
function blank_object() {
  return Object.create(null);
}
function run_all(fns) {
  fns.forEach(run);
}
function safe_not_equal(a, b) {
  return a != a ? b == b : a !== b || (a && typeof a === "object" || typeof a === "function");
}
function subscribe(store, ...callbacks) {
  if (store == null) {
    return noop;
  }
  const unsub = store.subscribe(...callbacks);
  return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
}
function get_store_value(store) {
  let value;
  subscribe(store, (_) => value = _)();
  return value;
}
function compute_rest_props(props, keys) {
  const rest = {};
  keys = new Set(keys);
  for (const k in props)
    if (!keys.has(k) && k[0] !== "$")
      rest[k] = props[k];
  return rest;
}
function compute_slots(slots) {
  const result = {};
  for (const key in slots) {
    result[key] = true;
  }
  return result;
}
function null_to_empty(value) {
  return value == null ? "" : value;
}
function set_store_value(store, ret, value) {
  store.set(value);
  return ret;
}
function listen(node, event, handler, options2) {
  node.addEventListener(event, handler, options2);
  return () => node.removeEventListener(event, handler, options2);
}
function prevent_default(fn) {
  return function(event) {
    event.preventDefault();
    return fn.call(this, event);
  };
}
function stop_propagation(fn) {
  return function(event) {
    event.stopPropagation();
    return fn.call(this, event);
  };
}
var current_component;
function set_current_component(component) {
  current_component = component;
}
function get_current_component() {
  if (!current_component)
    throw new Error("Function called outside component initialization");
  return current_component;
}
function onDestroy(fn) {
  get_current_component().$$.on_destroy.push(fn);
}
function setContext(key, context) {
  get_current_component().$$.context.set(key, context);
}
function getContext(key) {
  return get_current_component().$$.context.get(key);
}
function bubble(component, event) {
  const callbacks = component.$$.callbacks[event.type];
  if (callbacks) {
    callbacks.slice().forEach((fn) => fn.call(this, event));
  }
}
Promise.resolve();
var globals = typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : global;
var boolean_attributes = new Set([
  "allowfullscreen",
  "allowpaymentrequest",
  "async",
  "autofocus",
  "autoplay",
  "checked",
  "controls",
  "default",
  "defer",
  "disabled",
  "formnovalidate",
  "hidden",
  "ismap",
  "loop",
  "multiple",
  "muted",
  "nomodule",
  "novalidate",
  "open",
  "playsinline",
  "readonly",
  "required",
  "reversed",
  "selected"
]);
var invalid_attribute_name_character = /[\s'">/=\u{FDD0}-\u{FDEF}\u{FFFE}\u{FFFF}\u{1FFFE}\u{1FFFF}\u{2FFFE}\u{2FFFF}\u{3FFFE}\u{3FFFF}\u{4FFFE}\u{4FFFF}\u{5FFFE}\u{5FFFF}\u{6FFFE}\u{6FFFF}\u{7FFFE}\u{7FFFF}\u{8FFFE}\u{8FFFF}\u{9FFFE}\u{9FFFF}\u{AFFFE}\u{AFFFF}\u{BFFFE}\u{BFFFF}\u{CFFFE}\u{CFFFF}\u{DFFFE}\u{DFFFF}\u{EFFFE}\u{EFFFF}\u{FFFFE}\u{FFFFF}\u{10FFFE}\u{10FFFF}]/u;
function spread(args, classes_to_add) {
  const attributes = Object.assign({}, ...args);
  if (classes_to_add) {
    if (attributes.class == null) {
      attributes.class = classes_to_add;
    } else {
      attributes.class += " " + classes_to_add;
    }
  }
  let str = "";
  Object.keys(attributes).forEach((name) => {
    if (invalid_attribute_name_character.test(name))
      return;
    const value = attributes[name];
    if (value === true)
      str += " " + name;
    else if (boolean_attributes.has(name.toLowerCase())) {
      if (value)
        str += " " + name;
    } else if (value != null) {
      str += ` ${name}="${value}"`;
    }
  });
  return str;
}
var escaped = {
  '"': "&quot;",
  "'": "&#39;",
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;"
};
function escape(html) {
  return String(html).replace(/["'&<>]/g, (match2) => escaped[match2]);
}
function escape_attribute_value(value) {
  return typeof value === "string" ? escape(value) : value;
}
function escape_object(obj) {
  const result = {};
  for (const key in obj) {
    result[key] = escape_attribute_value(obj[key]);
  }
  return result;
}
function each(items, fn) {
  let str = "";
  for (let i = 0; i < items.length; i += 1) {
    str += fn(items[i], i);
  }
  return str;
}
var missing_component = {
  $$render: () => ""
};
function validate_component(component, name) {
  if (!component || !component.$$render) {
    if (name === "svelte:component")
      name += " this={...}";
    throw new Error(`<${name}> is not a valid SSR component. You may need to review your build config to ensure that dependencies are compiled, rather than imported as pre-compiled modules`);
  }
  return component;
}
var on_destroy;
function create_ssr_component(fn) {
  function $$render(result, props, bindings, slots, context) {
    const parent_component = current_component;
    const $$ = {
      on_destroy,
      context: new Map(context || (parent_component ? parent_component.$$.context : [])),
      on_mount: [],
      before_update: [],
      after_update: [],
      callbacks: blank_object()
    };
    set_current_component({ $$ });
    const html = fn(result, props, bindings, slots);
    set_current_component(parent_component);
    return html;
  }
  return {
    render: (props = {}, { $$slots = {}, context = new Map() } = {}) => {
      on_destroy = [];
      const result = { title: "", head: "", css: new Set() };
      const html = $$render(result, props, {}, $$slots, context);
      run_all(on_destroy);
      return {
        html,
        css: {
          code: Array.from(result.css).map((css2) => css2.code).join("\n"),
          map: null
        },
        head: result.title + result.head
      };
    },
    $$render
  };
}
function add_attribute(name, value, boolean) {
  if (value == null || boolean && !value)
    return "";
  return ` ${name}${value === true ? "" : `=${typeof value === "string" ? JSON.stringify(escape(value)) : `"${value}"`}`}`;
}
function afterUpdate() {
}
var css$J = {
  code: "#svelte-announcer.svelte-1j55zn5{position:absolute;left:0;top:0;clip:rect(0 0 0 0);clip-path:inset(50%);overflow:hidden;white-space:nowrap;width:1px;height:1px}",
  map: `{"version":3,"file":"root.svelte","sources":["root.svelte"],"sourcesContent":["<!-- This file is generated by @sveltejs/kit \u2014 do not edit it! -->\\n<script>\\n\\timport { setContext, afterUpdate, onMount } from 'svelte';\\n\\n\\t// stores\\n\\texport let stores;\\n\\texport let page;\\n\\n\\texport let components;\\n\\texport let props_0 = null;\\n\\texport let props_1 = null;\\n\\texport let props_2 = null;\\n\\n\\tsetContext('__svelte__', stores);\\n\\n\\t$: stores.page.set(page);\\n\\tafterUpdate(stores.page.notify);\\n\\n\\tlet mounted = false;\\n\\tlet navigated = false;\\n\\tlet title = null;\\n\\n\\tonMount(() => {\\n\\t\\tconst unsubscribe = stores.page.subscribe(() => {\\n\\t\\t\\tif (mounted) {\\n\\t\\t\\t\\tnavigated = true;\\n\\t\\t\\t\\ttitle = document.title || 'untitled page';\\n\\t\\t\\t}\\n\\t\\t});\\n\\n\\t\\tmounted = true;\\n\\t\\treturn unsubscribe;\\n\\t});\\n<\/script>\\n\\n<svelte:component this={components[0]} {...(props_0 || {})}>\\n\\t{#if components[1]}\\n\\t\\t<svelte:component this={components[1]} {...(props_1 || {})}>\\n\\t\\t\\t{#if components[2]}\\n\\t\\t\\t\\t<svelte:component this={components[2]} {...(props_2 || {})}/>\\n\\t\\t\\t{/if}\\n\\t\\t</svelte:component>\\n\\t{/if}\\n</svelte:component>\\n\\n{#if mounted}\\n\\t<div id=\\"svelte-announcer\\" aria-live=\\"assertive\\" aria-atomic=\\"true\\">\\n\\t\\t{#if navigated}\\n\\t\\t\\t{title}\\n\\t\\t{/if}\\n\\t</div>\\n{/if}\\n\\n<style>\\n\\t#svelte-announcer {\\n\\t\\tposition: absolute;\\n\\t\\tleft: 0;\\n\\t\\ttop: 0;\\n\\t\\tclip: rect(0 0 0 0);\\n\\t\\tclip-path: inset(50%);\\n\\t\\toverflow: hidden;\\n\\t\\twhite-space: nowrap;\\n\\t\\twidth: 1px;\\n\\t\\theight: 1px;\\n\\t}\\n</style>"],"names":[],"mappings":"AAsDC,iBAAiB,eAAC,CAAC,AAClB,QAAQ,CAAE,QAAQ,CAClB,IAAI,CAAE,CAAC,CACP,GAAG,CAAE,CAAC,CACN,IAAI,CAAE,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CACnB,SAAS,CAAE,MAAM,GAAG,CAAC,CACrB,QAAQ,CAAE,MAAM,CAChB,WAAW,CAAE,MAAM,CACnB,KAAK,CAAE,GAAG,CACV,MAAM,CAAE,GAAG,AACZ,CAAC"}`
};
var Root = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let { stores } = $$props;
  let { page } = $$props;
  let { components } = $$props;
  let { props_0 = null } = $$props;
  let { props_1 = null } = $$props;
  let { props_2 = null } = $$props;
  setContext("__svelte__", stores);
  afterUpdate(stores.page.notify);
  if ($$props.stores === void 0 && $$bindings.stores && stores !== void 0)
    $$bindings.stores(stores);
  if ($$props.page === void 0 && $$bindings.page && page !== void 0)
    $$bindings.page(page);
  if ($$props.components === void 0 && $$bindings.components && components !== void 0)
    $$bindings.components(components);
  if ($$props.props_0 === void 0 && $$bindings.props_0 && props_0 !== void 0)
    $$bindings.props_0(props_0);
  if ($$props.props_1 === void 0 && $$bindings.props_1 && props_1 !== void 0)
    $$bindings.props_1(props_1);
  if ($$props.props_2 === void 0 && $$bindings.props_2 && props_2 !== void 0)
    $$bindings.props_2(props_2);
  $$result.css.add(css$J);
  {
    stores.page.set(page);
  }
  return `


${validate_component(components[0] || missing_component, "svelte:component").$$render($$result, Object.assign(props_0 || {}), {}, {
    default: () => `${components[1] ? `${validate_component(components[1] || missing_component, "svelte:component").$$render($$result, Object.assign(props_1 || {}), {}, {
      default: () => `${components[2] ? `${validate_component(components[2] || missing_component, "svelte:component").$$render($$result, Object.assign(props_2 || {}), {}, {})}` : ``}`
    })}` : ``}`
  })}

${``}`;
});
var base = "";
var assets = "";
function set_paths(paths) {
  base = paths.base;
  assets = paths.assets || base;
}
function set_prerendering(value) {
}
var user_hooks = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module"
});
var template = ({ head, body }) => '<!DOCTYPE html>\n<html lang="en">\n	<head>\n		<meta charset="utf-8" />\n		<meta name="viewport" content="width=device-width, initial-scale=1" />\n		<meta name="apple-mobile-web-app-capable" content="yes">\n\n		<!-- favicons -->\n		<link rel="apple-touch-icon" sizes="180x180" href="/favicons/apple-touch-icon.png">\n		<link rel="icon" type="image/png" sizes="32x32" href="/favicons/favicon-32x32.png">\n		<link rel="icon" type="image/png" sizes="16x16" href="/favicons/favicon-16x16.png">\n		<link rel="mask-icon" href="/favicons/safari-pinned-tab.svg" color="#00316b">\n		<link rel="shortcut icon" href="/favicons/favicon.ico">\n		<meta name="apple-mobile-web-app-title" content="League Page">\n		<meta name="application-name" content="League Page">\n		<meta name="msapplication-TileColor" content="#505051">\n		<meta name="msapplication-config" content="/favicons/browserconfig.xml">\n		<meta name="theme-color" content="#ffffff">\n\n		<!-- PWA -->\n		<link rel="manifest" href="/manifest.json">\n		<link rel="apple-touch-startup-image" href="pwa/apple-splash-2048-2732.jpg" media="(device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)">\n		<link rel="apple-touch-startup-image" href="pwa/apple-splash-2732-2048.jpg" media="(device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)">\n		<link rel="apple-touch-startup-image" href="pwa/apple-splash-1668-2388.jpg" media="(device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)">\n		<link rel="apple-touch-startup-image" href="pwa/apple-splash-2388-1668.jpg" media="(device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)">\n		<link rel="apple-touch-startup-image" href="pwa/apple-splash-1536-2048.jpg" media="(device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)">\n		<link rel="apple-touch-startup-image" href="pwa/apple-splash-2048-1536.jpg" media="(device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)">\n		<link rel="apple-touch-startup-image" href="pwa/apple-splash-1668-2224.jpg" media="(device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)">\n		<link rel="apple-touch-startup-image" href="pwa/apple-splash-2224-1668.jpg" media="(device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)">\n		<link rel="apple-touch-startup-image" href="pwa/apple-splash-1620-2160.jpg" media="(device-width: 810px) and (device-height: 1080px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)">\n		<link rel="apple-touch-startup-image" href="pwa/apple-splash-2160-1620.jpg" media="(device-width: 810px) and (device-height: 1080px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)">\n		<link rel="apple-touch-startup-image" href="pwa/apple-splash-1284-2778.jpg" media="(device-width: 428px) and (device-height: 926px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)">\n		<link rel="apple-touch-startup-image" href="pwa/apple-splash-2778-1284.jpg" media="(device-width: 428px) and (device-height: 926px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)">\n		<link rel="apple-touch-startup-image" href="pwa/apple-splash-1170-2532.jpg" media="(device-width: 390px) and (device-height: 844px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)">\n		<link rel="apple-touch-startup-image" href="pwa/apple-splash-2532-1170.jpg" media="(device-width: 390px) and (device-height: 844px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)">\n		<link rel="apple-touch-startup-image" href="pwa/apple-splash-1125-2436.jpg" media="(device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)">\n		<link rel="apple-touch-startup-image" href="pwa/apple-splash-2436-1125.jpg" media="(device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)">\n		<link rel="apple-touch-startup-image" href="pwa/apple-splash-1242-2688.jpg" media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)">\n		<link rel="apple-touch-startup-image" href="pwa/apple-splash-2688-1242.jpg" media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)">\n		<link rel="apple-touch-startup-image" href="pwa/apple-splash-828-1792.jpg" media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)">\n		<link rel="apple-touch-startup-image" href="pwa/apple-splash-1792-828.jpg" media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)">\n		<link rel="apple-touch-startup-image" href="pwa/apple-splash-1242-2208.jpg" media="(device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)">\n		<link rel="apple-touch-startup-image" href="pwa/apple-splash-2208-1242.jpg" media="(device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)">\n		<link rel="apple-touch-startup-image" href="pwa/apple-splash-750-1334.jpg" media="(device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)">\n		<link rel="apple-touch-startup-image" href="pwa/apple-splash-1334-750.jpg" media="(device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)">\n		<link rel="apple-touch-startup-image" href="pwa/apple-splash-640-1136.jpg" media="(device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)">\n		<link rel="apple-touch-startup-image" href="pwa/apple-splash-1136-640.jpg" media="(device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)">\n\n		<!-- Fonts and CSS -->\n		<link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons&display=swap" />\n		<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,600,700&display=swap" />\n		<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto+Mono&display=swap" />\n\n		<!-- SMUI Styles -->\n		<link rel="stylesheet" href="/smui.css" media="(prefers-color-scheme: light)" />\n		<link rel="stylesheet" href="/smui-dark.css" media="screen and (prefers-color-scheme: dark)" />\n		' + head + '\n	</head>\n	<body>\n		<div id="svelte">' + body + "</div>\n	</body>\n</html>\n";
var options = null;
var default_settings = { paths: { "base": "", "assets": "" } };
function init(settings = default_settings) {
  set_paths(settings.paths);
  set_prerendering(settings.prerendering || false);
  const hooks = get_hooks(user_hooks);
  options = {
    amp: false,
    dev: false,
    entry: {
      file: assets + "/_app/start-07d82c21.js",
      css: [assets + "/_app/assets/start-61d1577b.css"],
      js: [assets + "/_app/start-07d82c21.js", assets + "/_app/chunks/vendor-60eb0dec.js", assets + "/_app/chunks/singletons-ff603286.js"]
    },
    fetched: void 0,
    floc: false,
    get_component_path: (id) => assets + "/_app/" + entry_lookup[id],
    get_stack: (error2) => String(error2),
    handle_error: (error2, request) => {
      hooks.handleError({ error: error2, request });
      error2.stack = options.get_stack(error2);
    },
    hooks,
    hydrate: true,
    initiator: void 0,
    load_component,
    manifest,
    paths: settings.paths,
    prerender: true,
    read: settings.read,
    root: Root,
    service_worker: null,
    router: true,
    ssr: false,
    target: "#svelte",
    template,
    trailing_slash: "never"
  };
}
var d = (s2) => s2.replace(/%23/g, "#").replace(/%3[Bb]/g, ";").replace(/%2[Cc]/g, ",").replace(/%2[Ff]/g, "/").replace(/%3[Ff]/g, "?").replace(/%3[Aa]/g, ":").replace(/%40/g, "@").replace(/%26/g, "&").replace(/%3[Dd]/g, "=").replace(/%2[Bb]/g, "+").replace(/%24/g, "$");
var empty = () => ({});
var manifest = {
  assets: [{ "file": ".DS_Store", "size": 10244, "type": null }, { "file": "Carrier Pigeon.png", "size": 2504, "type": "image/png" }, { "file": "Discord.png", "size": 1848, "type": "image/png" }, { "file": "Dynasty.png", "size": 2738, "type": "image/png" }, { "file": "Email.png", "size": 1383, "type": "image/png" }, { "file": "League Page.png", "size": 654030, "type": "image/png" }, { "file": "Phone.png", "size": 977, "type": "image/png" }, { "file": "Rebuild.png", "size": 3785, "type": "image/png" }, { "file": "Rookies.png", "size": 5029, "type": "image/png" }, { "file": "Sleeper.png", "size": 2220, "type": "image/png" }, { "file": "Text.png", "size": 1631, "type": "image/png" }, { "file": "Vets.png", "size": 3969, "type": "image/png" }, { "file": "WhatsApp.png", "size": 2361, "type": "image/png" }, { "file": "Win Now.png", "size": 2303, "type": "image/png" }, { "file": "awards/champion.png", "size": 2813, "type": "image/png" }, { "file": "awards/division.png", "size": 3011, "type": "image/png" }, { "file": "awards/generic.png", "size": 2467, "type": "image/png" }, { "file": "awards/record-1.png", "size": 2439, "type": "image/png" }, { "file": "awards/record-2.png", "size": 2454, "type": "image/png" }, { "file": "awards/record-3.png", "size": 2524, "type": "image/png" }, { "file": "awards/second.png", "size": 2260, "type": "image/png" }, { "file": "awards/third.png", "size": 2196, "type": "image/png" }, { "file": "awards/toilet.png", "size": 3990, "type": "image/png" }, { "file": "awayDivider.jpg", "size": 822, "type": "image/jpeg" }, { "file": "badge.png", "size": 4975, "type": "image/png" }, { "file": "banner.png", "size": 12360, "type": "image/png" }, { "file": "deflated-football.png", "size": 22169, "type": "image/png" }, { "file": "division-1-banner.png", "size": 19337, "type": "image/png" }, { "file": "division-2-banner.png", "size": 20062, "type": "image/png" }, { "file": "favicons/android-chrome-192x192.png", "size": 28699, "type": "image/png" }, { "file": "favicons/android-chrome-512x512.png", "size": 108940, "type": "image/png" }, { "file": "favicons/apple-touch-icon.png", "size": 18368, "type": "image/png" }, { "file": "favicons/browserconfig.xml", "size": 255, "type": "application/xml" }, { "file": "favicons/favicon-16x16.png", "size": 1271, "type": "image/png" }, { "file": "favicons/favicon-32x32.png", "size": 2593, "type": "image/png" }, { "file": "favicons/favicon.ico", "size": 15086, "type": "image/vnd.microsoft.icon" }, { "file": "favicons/mstile-150x150.png", "size": 16948, "type": "image/png" }, { "file": "favicons/safari-pinned-tab.svg", "size": 24235, "type": "image/svg+xml" }, { "file": "green.png", "size": 2249, "type": "image/png" }, { "file": "homeDivider.jpg", "size": 819, "type": "image/jpeg" }, { "file": "laurel.png", "size": 6879, "type": "image/png" }, { "file": "managers/.DS_Store", "size": 6148, "type": null }, { "file": "managers/IMG_9566.HEIC", "size": 1093080, "type": "image/heic" }, { "file": "managers/bailey.jpg", "size": 660718, "type": "image/jpeg" }, { "file": "managers/everyone.png", "size": 6706, "type": "image/png" }, { "file": "managers/garrett.jpg", "size": 193655, "type": "image/jpeg" }, { "file": "managers/jay.jpg", "size": 420948, "type": "image/jpeg" }, { "file": "managers/jj.gif", "size": 63998098, "type": "image/gif" }, { "file": "managers/john.jpg", "size": 2771977, "type": "image/jpeg" }, { "file": "managers/logan.jpg", "size": 165726, "type": "image/jpeg" }, { "file": "managers/question.jpg", "size": 1373, "type": "image/jpeg" }, { "file": "managers/rival-dumb-dumber.jpg", "size": 43921, "type": "image/jpeg" }, { "file": "managers/rival-garrett.jpg", "size": 58110, "type": "image/jpeg" }, { "file": "managers/rival-jay.jpg", "size": 13494, "type": "image/jpeg" }, { "file": "managers/rival-jj.jpg", "size": 125224, "type": "image/jpeg" }, { "file": "managers/rival-mike.gif", "size": 2172512, "type": "image/gif" }, { "file": "managers/rival-tyler.jpg", "size": 23679, "type": "image/jpeg" }, { "file": "managers/rival-wayne.jpg", "size": 84461, "type": "image/jpeg" }, { "file": "managers/rival-zach-2.jpg", "size": 41192, "type": "image/jpeg" }, { "file": "managers/rival-zach.jpg", "size": 115729, "type": "image/jpeg" }, { "file": "managers/scott.jpg", "size": 1697424, "type": "image/jpeg" }, { "file": "managers/travis.jpg", "size": 110550, "type": "image/jpeg" }, { "file": "managers/tyler.jpg", "size": 259549, "type": "image/jpeg" }, { "file": "managers/wayne.jpg", "size": 4121382, "type": "image/jpeg" }, { "file": "managers/zach.jpg", "size": 125375, "type": "image/jpeg" }, { "file": "manifest.json", "size": 1509, "type": "application/json" }, { "file": "medal.png", "size": 4413, "type": "image/png" }, { "file": "newsIcons/DynastyFF.png", "size": 33521, "type": "image/png" }, { "file": "newsIcons/dynastyLeague.png", "size": 28293, "type": "image/png" }, { "file": "newsIcons/dynastyNerds.jpeg", "size": 9108, "type": "image/jpeg" }, { "file": "newsIcons/fantasyfootball.png", "size": 16865, "type": "image/png" }, { "file": "newsIcons/ffballers.jpeg", "size": 6386, "type": "image/jpeg" }, { "file": "newsIcons/ftn.png", "size": 3974, "type": "image/png" }, { "file": "newsIcons/nbcSportsEdge.jpeg", "size": 4329, "type": "image/jpeg" }, { "file": "podium.png", "size": 7454, "type": "image/png" }, { "file": "pwa/apple-icon-180.png", "size": 18662, "type": "image/png" }, { "file": "pwa/apple-splash-1125-2436.jpg", "size": 77343, "type": "image/jpeg" }, { "file": "pwa/apple-splash-1136-640.jpg", "size": 28775, "type": "image/jpeg" }, { "file": "pwa/apple-splash-1170-2532.jpg", "size": 82393, "type": "image/jpeg" }, { "file": "pwa/apple-splash-1242-2208.jpg", "size": 84901, "type": "image/jpeg" }, { "file": "pwa/apple-splash-1242-2688.jpg", "size": 88412, "type": "image/jpeg" }, { "file": "pwa/apple-splash-1284-2778.jpg", "size": 93041, "type": "image/jpeg" }, { "file": "pwa/apple-splash-1334-750.jpg", "size": 35771, "type": "image/jpeg" }, { "file": "pwa/apple-splash-1536-2048.jpg", "size": 105341, "type": "image/jpeg" }, { "file": "pwa/apple-splash-1620-2160.jpg", "size": 111741, "type": "image/jpeg" }, { "file": "pwa/apple-splash-1668-2224.jpg", "size": 114653, "type": "image/jpeg" }, { "file": "pwa/apple-splash-1668-2388.jpg", "size": 117226, "type": "image/jpeg" }, { "file": "pwa/apple-splash-1792-828.jpg", "size": 37192, "type": "image/jpeg" }, { "file": "pwa/apple-splash-2048-1536.jpg", "size": 96495, "type": "image/jpeg" }, { "file": "pwa/apple-splash-2048-2732.jpg", "size": 146819, "type": "image/jpeg" }, { "file": "pwa/apple-splash-2160-1620.jpg", "size": 104008, "type": "image/jpeg" }, { "file": "pwa/apple-splash-2208-1242.jpg", "size": 63732, "type": "image/jpeg" }, { "file": "pwa/apple-splash-2224-1668.jpg", "size": 108e3, "type": "image/jpeg" }, { "file": "pwa/apple-splash-2388-1668.jpg", "size": 107626, "type": "image/jpeg" }, { "file": "pwa/apple-splash-2436-1125.jpg", "size": 53022, "type": "image/jpeg" }, { "file": "pwa/apple-splash-2532-1170.jpg", "size": 58014, "type": "image/jpeg" }, { "file": "pwa/apple-splash-2688-1242.jpg", "size": 61714, "type": "image/jpeg" }, { "file": "pwa/apple-splash-2732-2048.jpg", "size": 139542, "type": "image/jpeg" }, { "file": "pwa/apple-splash-2778-1284.jpg", "size": 65640, "type": "image/jpeg" }, { "file": "pwa/apple-splash-640-1136.jpg", "size": 33393, "type": "image/jpeg" }, { "file": "pwa/apple-splash-750-1334.jpg", "size": 42753, "type": "image/jpeg" }, { "file": "pwa/apple-splash-828-1792.jpg", "size": 48930, "type": "image/jpeg" }, { "file": "pwa/manifest-icon-192.png", "size": 20792, "type": "image/png" }, { "file": "pwa/manifest-icon-512.png", "size": 73982, "type": "image/png" }, { "file": "red.png", "size": 2389, "type": "image/png" }, { "file": "smui-dark.css", "size": 271753, "type": "text/css" }, { "file": "smui.css", "size": 271294, "type": "text/css" }, { "file": "tiedDivider.jpg", "size": 747, "type": "image/jpeg" }, { "file": "toilet-banner.png", "size": 15240, "type": "image/png" }, { "file": "toilet-bowl-2.png", "size": 13319, "type": "image/png" }, { "file": "trophy.png", "size": 9263, "type": "image/png" }],
  layout: "src/routes/__layout.svelte",
  error: "src/routes/__error.svelte",
  routes: [
    {
      type: "page",
      pattern: /^\/$/,
      params: empty,
      a: ["src/routes/__layout.svelte", "src/routes/index.svelte"],
      b: ["src/routes/__error.svelte"]
    },
    {
      type: "page",
      pattern: /^\/constitution\/?$/,
      params: empty,
      a: ["src/routes/__layout.svelte", "src/routes/constitution/index.svelte"],
      b: ["src/routes/__error.svelte"]
    },
    {
      type: "page",
      pattern: /^\/transactions\/?$/,
      params: empty,
      a: ["src/routes/__layout.svelte", "src/routes/transactions/index.svelte"],
      b: ["src/routes/__error.svelte"]
    },
    {
      type: "page",
      pattern: /^\/resources\/?$/,
      params: empty,
      a: ["src/routes/__layout.svelte", "src/routes/resources/index.svelte"],
      b: ["src/routes/__error.svelte"]
    },
    {
      type: "page",
      pattern: /^\/standings\/?$/,
      params: empty,
      a: ["src/routes/__layout.svelte", "src/routes/standings/index.svelte"],
      b: ["src/routes/__error.svelte"]
    },
    {
      type: "page",
      pattern: /^\/managers\/?$/,
      params: empty,
      a: ["src/routes/__layout.svelte", "src/routes/managers/index.svelte"],
      b: ["src/routes/__error.svelte"]
    },
    {
      type: "page",
      pattern: /^\/matchups\/?$/,
      params: empty,
      a: ["src/routes/__layout.svelte", "src/routes/matchups/index.svelte"],
      b: ["src/routes/__error.svelte"]
    },
    {
      type: "page",
      pattern: /^\/records\/?$/,
      params: empty,
      a: ["src/routes/__layout.svelte", "src/routes/records/index.svelte"],
      b: ["src/routes/__error.svelte"]
    },
    {
      type: "page",
      pattern: /^\/rosters\/?$/,
      params: empty,
      a: ["src/routes/__layout.svelte", "src/routes/rosters/index.svelte"],
      b: ["src/routes/__error.svelte"]
    },
    {
      type: "page",
      pattern: /^\/awards\/?$/,
      params: empty,
      a: ["src/routes/__layout.svelte", "src/routes/awards/index.svelte"],
      b: ["src/routes/__error.svelte"]
    },
    {
      type: "page",
      pattern: /^\/drafts\/?$/,
      params: empty,
      a: ["src/routes/__layout.svelte", "src/routes/drafts/index.svelte"],
      b: ["src/routes/__error.svelte"]
    },
    {
      type: "page",
      pattern: /^\/blog\/?$/,
      params: empty,
      a: ["src/routes/__layout.svelte", "src/routes/blog/index.svelte"],
      b: ["src/routes/__error.svelte"]
    },
    {
      type: "endpoint",
      pattern: /^\/api\/fetch_serverside_news\/?$/,
      params: empty,
      load: () => Promise.resolve().then(function() {
        return fetch_serverside_news;
      })
    },
    {
      type: "endpoint",
      pattern: /^\/api\/checkGlobalVersion\/?$/,
      params: empty,
      load: () => Promise.resolve().then(function() {
        return checkGlobalVersion;
      })
    },
    {
      type: "endpoint",
      pattern: /^\/api\/fetch_players_info\/?$/,
      params: empty,
      load: () => Promise.resolve().then(function() {
        return fetch_players_info;
      })
    },
    {
      type: "endpoint",
      pattern: /^\/api\/addBlogComments\/([^/]+?)\/?$/,
      params: (m) => ({ id: d(m[1]) }),
      load: () => Promise.resolve().then(function() {
        return _id_$1;
      })
    },
    {
      type: "endpoint",
      pattern: /^\/api\/getBlogComments\/([^/]+?)\/?$/,
      params: (m) => ({ id: d(m[1]) }),
      load: () => Promise.resolve().then(function() {
        return _id_;
      })
    },
    {
      type: "endpoint",
      pattern: /^\/api\/checkVersion\/?$/,
      params: empty,
      load: () => Promise.resolve().then(function() {
        return checkVersion;
      })
    },
    {
      type: "endpoint",
      pattern: /^\/api\/getBlogPosts\/?$/,
      params: empty,
      load: () => Promise.resolve().then(function() {
        return getBlogPosts;
      })
    }
  ]
};
var get_hooks = (hooks) => ({
  getSession: hooks.getSession || (() => ({})),
  handle: hooks.handle || (({ request, resolve: resolve2 }) => resolve2(request)),
  handleError: hooks.handleError || (({ error: error2 }) => console.error(error2.stack)),
  externalFetch: hooks.externalFetch || fetch
});
var module_lookup = {
  "src/routes/__layout.svelte": () => Promise.resolve().then(function() {
    return __layout;
  }),
  "src/routes/__error.svelte": () => Promise.resolve().then(function() {
    return __error;
  }),
  "src/routes/index.svelte": () => Promise.resolve().then(function() {
    return index$b;
  }),
  "src/routes/constitution/index.svelte": () => Promise.resolve().then(function() {
    return index$a;
  }),
  "src/routes/transactions/index.svelte": () => Promise.resolve().then(function() {
    return index$9;
  }),
  "src/routes/resources/index.svelte": () => Promise.resolve().then(function() {
    return index$8;
  }),
  "src/routes/standings/index.svelte": () => Promise.resolve().then(function() {
    return index$7;
  }),
  "src/routes/managers/index.svelte": () => Promise.resolve().then(function() {
    return index$6;
  }),
  "src/routes/matchups/index.svelte": () => Promise.resolve().then(function() {
    return index$5;
  }),
  "src/routes/records/index.svelte": () => Promise.resolve().then(function() {
    return index$4;
  }),
  "src/routes/rosters/index.svelte": () => Promise.resolve().then(function() {
    return index$3;
  }),
  "src/routes/awards/index.svelte": () => Promise.resolve().then(function() {
    return index$2;
  }),
  "src/routes/drafts/index.svelte": () => Promise.resolve().then(function() {
    return index$1;
  }),
  "src/routes/blog/index.svelte": () => Promise.resolve().then(function() {
    return index;
  })
};
var metadata_lookup = { "src/routes/__layout.svelte": { "entry": "pages/__layout.svelte-59d1f9f3.js", "css": ["assets/index.svelte_svelte&type=style&lang-6a1461e9.css"], "js": ["pages/__layout.svelte-59d1f9f3.js", "chunks/vendor-60eb0dec.js", "chunks/index.svelte_svelte&type=style&lang-b0d2c838.js", "chunks/navigation-51b348a1.js", "chunks/singletons-ff603286.js"], "styles": [] }, "src/routes/__error.svelte": { "entry": "pages/__error.svelte-a4621b36.js", "css": ["assets/pages/__error.svelte-a847da23.css"], "js": ["pages/__error.svelte-a4621b36.js", "chunks/vendor-60eb0dec.js"], "styles": [] }, "src/routes/index.svelte": { "entry": "pages/index.svelte-3d7b58b9.js", "css": ["assets/pages/index.svelte-1143c450.css", "assets/index.svelte_svelte&type=style&lang-6a1461e9.css"], "js": ["pages/index.svelte-3d7b58b9.js", "chunks/vendor-60eb0dec.js", "chunks/index.svelte_svelte&type=style&lang-b0d2c838.js", "chunks/nflState-b19b4ad8.js", "chunks/news-c1036290.js", "chunks/leagueAwards-121d6657.js", "chunks/leagueUsers-b0fdd0b7.js", "chunks/universalFunctions-311859ab.js", "chunks/navigation-51b348a1.js", "chunks/singletons-ff603286.js", "chunks/leagueTransactions-7f753bb7.js", "chunks/players-cc76d476.js", "chunks/Transaction-8f677ee9.js", "chunks/leagueRecords-34904a57.js", "chunks/BarChart-3ba283f3.js"], "styles": [] }, "src/routes/constitution/index.svelte": { "entry": "pages/constitution/index.svelte-e36b3255.js", "css": ["assets/pages/constitution/index.svelte-11a4b21e.css"], "js": ["pages/constitution/index.svelte-e36b3255.js", "chunks/vendor-60eb0dec.js"], "styles": [] }, "src/routes/transactions/index.svelte": { "entry": "pages/transactions/index.svelte-1ddcaee2.js", "css": ["assets/pages/transactions/index.svelte-a4eb43ca.css", "assets/index.svelte_svelte&type=style&lang-6a1461e9.css"], "js": ["pages/transactions/index.svelte-1ddcaee2.js", "chunks/vendor-60eb0dec.js", "chunks/leagueTransactions-7f753bb7.js", "chunks/leagueUsers-b0fdd0b7.js", "chunks/news-c1036290.js", "chunks/index.svelte_svelte&type=style&lang-b0d2c838.js", "chunks/nflState-b19b4ad8.js", "chunks/players-cc76d476.js", "chunks/TransactionsPage-54e39fc7.js", "chunks/Transaction-8f677ee9.js", "chunks/universalFunctions-311859ab.js", "chunks/navigation-51b348a1.js", "chunks/singletons-ff603286.js", "chunks/Pagination-34211372.js"], "styles": [] }, "src/routes/resources/index.svelte": { "entry": "pages/resources/index.svelte-71f1ad12.js", "css": ["assets/pages/resources/index.svelte-f2882eb9.css", "assets/index.svelte_svelte&type=style&lang-6a1461e9.css"], "js": ["pages/resources/index.svelte-71f1ad12.js", "chunks/vendor-60eb0dec.js", "chunks/news-c1036290.js", "chunks/index.svelte_svelte&type=style&lang-b0d2c838.js", "chunks/Pagination-34211372.js"], "styles": [] }, "src/routes/standings/index.svelte": { "entry": "pages/standings/index.svelte-e4f63541.js", "css": ["assets/pages/standings/index.svelte-526f4c56.css", "assets/index.svelte_svelte&type=style&lang-6a1461e9.css"], "js": ["pages/standings/index.svelte-e4f63541.js", "chunks/vendor-60eb0dec.js", "chunks/leagueUsers-b0fdd0b7.js", "chunks/news-c1036290.js", "chunks/index.svelte_svelte&type=style&lang-b0d2c838.js", "chunks/nflState-b19b4ad8.js", "chunks/universalFunctions-311859ab.js", "chunks/navigation-51b348a1.js", "chunks/singletons-ff603286.js"], "styles": [] }, "src/routes/managers/index.svelte": { "entry": "pages/managers/index.svelte-d2a60cea.js", "css": ["assets/pages/managers/index.svelte-250c9e42.css", "assets/index.svelte_svelte&type=style&lang-6a1461e9.css"], "js": ["pages/managers/index.svelte-d2a60cea.js", "chunks/vendor-60eb0dec.js", "chunks/leagueUsers-b0fdd0b7.js", "chunks/news-c1036290.js", "chunks/index.svelte_svelte&type=style&lang-b0d2c838.js", "chunks/leagueTransactions-7f753bb7.js", "chunks/nflState-b19b4ad8.js", "chunks/leagueRecords-34904a57.js", "chunks/leagueAwards-121d6657.js", "chunks/navigation-51b348a1.js", "chunks/singletons-ff603286.js", "chunks/players-cc76d476.js", "chunks/Roster-6cb66c24.js", "chunks/universalFunctions-311859ab.js", "chunks/TransactionsPage-54e39fc7.js", "chunks/Transaction-8f677ee9.js", "chunks/Pagination-34211372.js"], "styles": [] }, "src/routes/matchups/index.svelte": { "entry": "pages/matchups/index.svelte-f052d3c5.js", "css": ["assets/pages/matchups/index.svelte-c806506f.css", "assets/index.svelte_svelte&type=style&lang-6a1461e9.css"], "js": ["pages/matchups/index.svelte-f052d3c5.js", "chunks/vendor-60eb0dec.js", "chunks/leagueUsers-b0fdd0b7.js", "chunks/news-c1036290.js", "chunks/index.svelte_svelte&type=style&lang-b0d2c838.js", "chunks/nflState-b19b4ad8.js", "chunks/players-cc76d476.js", "chunks/universalFunctions-311859ab.js", "chunks/navigation-51b348a1.js", "chunks/singletons-ff603286.js"], "styles": [] }, "src/routes/records/index.svelte": { "entry": "pages/records/index.svelte-6c7e907b.js", "css": ["assets/pages/records/index.svelte-5d90600f.css", "assets/index.svelte_svelte&type=style&lang-6a1461e9.css"], "js": ["pages/records/index.svelte-6c7e907b.js", "chunks/vendor-60eb0dec.js", "chunks/leagueTransactions-7f753bb7.js", "chunks/leagueUsers-b0fdd0b7.js", "chunks/news-c1036290.js", "chunks/index.svelte_svelte&type=style&lang-b0d2c838.js", "chunks/nflState-b19b4ad8.js", "chunks/leagueRecords-34904a57.js", "chunks/universalFunctions-311859ab.js", "chunks/navigation-51b348a1.js", "chunks/singletons-ff603286.js", "chunks/BarChart-3ba283f3.js"], "styles": [] }, "src/routes/rosters/index.svelte": { "entry": "pages/rosters/index.svelte-e7264584.js", "css": ["assets/pages/rosters/index.svelte-418af77e.css", "assets/index.svelte_svelte&type=style&lang-6a1461e9.css"], "js": ["pages/rosters/index.svelte-e7264584.js", "chunks/vendor-60eb0dec.js", "chunks/leagueUsers-b0fdd0b7.js", "chunks/news-c1036290.js", "chunks/index.svelte_svelte&type=style&lang-b0d2c838.js", "chunks/players-cc76d476.js", "chunks/Roster-6cb66c24.js", "chunks/universalFunctions-311859ab.js", "chunks/navigation-51b348a1.js", "chunks/singletons-ff603286.js"], "styles": [] }, "src/routes/awards/index.svelte": { "entry": "pages/awards/index.svelte-5d7029d0.js", "css": ["assets/pages/awards/index.svelte-55134165.css", "assets/index.svelte_svelte&type=style&lang-6a1461e9.css"], "js": ["pages/awards/index.svelte-5d7029d0.js", "chunks/vendor-60eb0dec.js", "chunks/leagueAwards-121d6657.js", "chunks/leagueUsers-b0fdd0b7.js", "chunks/news-c1036290.js", "chunks/index.svelte_svelte&type=style&lang-b0d2c838.js", "chunks/universalFunctions-311859ab.js", "chunks/navigation-51b348a1.js", "chunks/singletons-ff603286.js"], "styles": [] }, "src/routes/drafts/index.svelte": { "entry": "pages/drafts/index.svelte-adac6b11.js", "css": ["assets/pages/matchups/index.svelte-c806506f.css", "assets/index.svelte_svelte&type=style&lang-6a1461e9.css"], "js": ["pages/drafts/index.svelte-adac6b11.js", "chunks/vendor-60eb0dec.js", "chunks/leagueUsers-b0fdd0b7.js", "chunks/news-c1036290.js", "chunks/index.svelte_svelte&type=style&lang-b0d2c838.js", "chunks/universalFunctions-311859ab.js", "chunks/navigation-51b348a1.js", "chunks/singletons-ff603286.js"], "styles": [] }, "src/routes/blog/index.svelte": { "entry": "pages/blog/index.svelte-061370f3.js", "css": ["assets/pages/blog/index.svelte-01be6325.css", "assets/index.svelte_svelte&type=style&lang-6a1461e9.css"], "js": ["pages/blog/index.svelte-061370f3.js", "chunks/vendor-60eb0dec.js", "chunks/index.svelte_svelte&type=style&lang-b0d2c838.js", "chunks/navigation-51b348a1.js", "chunks/singletons-ff603286.js", "chunks/Pagination-34211372.js", "chunks/news-c1036290.js", "chunks/universalFunctions-311859ab.js"], "styles": [] } };
async function load_component(file) {
  const { entry, css: css2, js, styles } = metadata_lookup[file];
  return {
    module: await module_lookup[file](),
    entry: assets + "/_app/" + entry,
    css: css2.map((dep) => assets + "/_app/" + dep),
    js: js.map((dep) => assets + "/_app/" + dep),
    styles
  };
}
function render(request, {
  prerender: prerender2
} = {}) {
  const host = request.headers["host"];
  return respond({ ...request, host }, options, { prerender: prerender2 });
}
var handleRejection = (p) => {
  return p.catch((error2) => ({
    error: error2
  }));
};
var waitForAll = async (...ps) => {
  return Promise.all(ps.map(handleRejection));
};
var subscriber_queue = [];
function writable(value, start = noop) {
  let stop;
  const subscribers = new Set();
  function set(new_value) {
    if (safe_not_equal(value, new_value)) {
      value = new_value;
      if (stop) {
        const run_queue = !subscriber_queue.length;
        for (const subscriber of subscribers) {
          subscriber[1]();
          subscriber_queue.push(subscriber, value);
        }
        if (run_queue) {
          for (let i = 0; i < subscriber_queue.length; i += 2) {
            subscriber_queue[i][0](subscriber_queue[i + 1]);
          }
          subscriber_queue.length = 0;
        }
      }
    }
  }
  function update(fn) {
    set(fn(value));
  }
  function subscribe2(run2, invalidate = noop) {
    const subscriber = [run2, invalidate];
    subscribers.add(subscriber);
    if (subscribers.size === 1) {
      stop = start(set) || noop;
    }
    run2(value);
    return () => {
      subscribers.delete(subscriber);
      if (subscribers.size === 0) {
        stop();
        stop = null;
      }
    };
  }
  return { set, update, subscribe: subscribe2 };
}
var awards = writable({});
var leagueData = writable({});
var upcomingDraft = writable({});
var previousDrafts = writable([]);
var matchupsStore = writable({});
var records = writable({});
var rostersStore = writable({});
var transactionsStore = writable({});
var users = writable({});
var nflState = writable({});
var players = writable({});
var news = writable([]);
var brackets = writable({});
var standingsStore = writable({});
var leagueID = "731530751262183424";
var leagueName = "Tomcat Dynasty League";
var dynasty = true;
var enableBlog = false;
var homepageText = `
  <p>Welcome to the home page for the Tomcat Dynasty League! I will put more helpful info here later.</p>
`;
var managers = [
  {
    "roster": 1,
    "name": "Scott Garcia",
    "location": "Arlington, VA",
    "bio": "I'm the best ever. I'm the most brutal and vicious, and most ruthless champion there's ever been. There's no one can stop me. Lennox is a conqueror? No, I'm Alexander, he's no Alexander. I'm the best ever! There's never been anybody as ruthless! I'm Sonny Liston, I'm Jack Dempsey. There's no one like me. I'm from their cloth. There's no one that can match me. My style is impetuous, my defense is impregnable, and I'm just ferocious. I want your heart! I want to eat his children! Praise be to Allah!",
    "photo": "/managers/scott.jpg",
    "fantasyStart": 2009,
    "favoriteTeam": "ari",
    "mode": "Dynasty",
    "rival": {
      name: "The Navy Yard Nincompoop",
      link: 7,
      image: "/managers/rival-jay.jpg"
    },
    "favoritePlayer": 5849,
    "philosophy": "We will be perfect in every aspect of the game. You drop a pass, you run a mile. You miss a blocking assignment, you run a mile. You fumble the football, and i will break my foot off in your John Brown hind parts and then you will run a mile. Perfection. Let's go to work.",
    "tradingScale": 11
  },
  {
    "roster": 2,
    "name": "JJ Schacht",
    "location": "Scottsdale, AZ",
    "bio": "Just a small town guy from Myers Park looking to make his fantasy dreams come true",
    "photo": "/managers/jj.gif",
    "fantasyStart": 2011,
    "favoriteTeam": "car",
    "mode": "Win Now",
    "rival": {
      name: "Jay 'Half my name and half my height' Malak",
      link: 7,
      image: "/managers/rival-jay.jpg"
    },
    "favoritePlayer": 439,
    "philosophy": "Win early win often",
    "tradingScale": 4.2
  },
  {
    "roster": 3,
    "name": "John Flye",
    "location": "Charlotte, NC",
    "bio": "Raised in the basement off of butter dogs and sneaky snakes, just to climb all the way to the top of the fantasy league",
    "photo": "/managers/john.jpg",
    "fantasyStart": 1969,
    "favoriteTeam": "car",
    "mode": "Rebuild",
    "rival": {
      name: "Zach 'Scrub' Elliott",
      link: 8,
      image: "/managers/rival-zach-2.jpg"
    },
    "favoritePlayer": 5862,
    "philosophy": "Win now, win later, and have Scott Hanson calling your players\u2019 names all Sunday long",
    "tradingScale": 6
  },
  {
    "roster": 4,
    "name": "Travis Barnett",
    "location": "Raleigh, NC",
    "bio": "Born in the desert sands of West Texas, football was always a dream. Without athletic prowess, now it's just a fantasy.",
    "photo": "/managers/travis.jpg",
    "fantasyStart": 2018,
    "favoriteTeam": "car",
    "mode": "Rebuild",
    "rival": {
      name: "Zach Elliott",
      link: 8,
      image: "/managers/rival-zach.jpg"
    },
    "favoritePlayer": 3423,
    "philosophy": "Never lose to Zach... Ever...",
    "tradingScale": 8
  },
  {
    "roster": 5,
    "name": "Garrett Woods",
    "location": "Raleigh, NC",
    "bio": " Former black out artist. Current student of the game and classroom. Future dynasty champion.",
    "photo": "/managers/garrett.jpg",
    "fantasyStart": 2011,
    "favoriteTeam": "car",
    "mode": "Rebuild",
    "rival": {
      name: "@Wayne1030",
      link: 9,
      image: "/managers/rival-wayne.jpg"
    },
    "favoritePlayer": 4866,
    "philosophy": "ludere. vincat. repetere.",
    "tradingScale": 6.5
  },
  {
    "roster": 6,
    "name": "Logan Dennis",
    "location": "Charleston, SC. DC soon.",
    "bio": "The team formerly known as Vick Dawgs, we pride ourselves on our ability to be an exciting team for 50% of the season then succumb to injury and or poor lineup decisions and finish in 7th place.",
    "photo": "/managers/logan.jpg",
    "fantasyStart": 2012,
    "favoriteTeam": "sea",
    "mode": "Rebuild",
    "rival": {
      name: "JJ Schacht",
      link: 1,
      image: "/managers/rival-jj.jpg"
    },
    "favoritePlayer": 5846,
    "philosophy": "Stop losing to JJ and Bailey at inopportune times. Discount Double Check.",
    "tradingScale": 7
  },
  {
    "roster": 7,
    "name": "Bailey Ormond",
    "location": "Charlotte, NC",
    "bio": "Father of two loser children (Garrett, age 14. Wayne, age 12) Trying to win the league to afford double knee replacement for child Garrett.",
    "photo": "/managers/bailey.jpg",
    "fantasyStart": 2014,
    "favoriteTeam": "car",
    "mode": "Rebuild",
    "rival": {
      name: "Mini Mike",
      link: 11,
      image: "/managers/rival-mike.gif"
    },
    "favoritePlayer": 5862,
    "philosophy": "None.",
    "tradingScale": 5
  },
  {
    "roster": 8,
    "name": "Jay Malak",
    "location": "The Swamp",
    "bio": "My first foray into fantasy was in 2005, when I took Ladainian Tomlinson #1 overall. After torching the league, my friend logged into my team and traded him to himself. I\u2019m somehow still friends with him. If any of you try this, however, I will pull a Liam Neeson on you.\nIn seriousness, fantasy has always been my favorite way to stay in touch with friends. I take it pretty seriously, and often care more about my team than the Panthers. (As you could probably tell, the heels and Tottenham are where my primary allegiances lie). I\u2019m glad to be a part of this group, look forward to hopefully kicking your asses, and more importantly hearing your trash talk in return.\nMay the best man win.",
    "photo": "/managers/jay.jpg",
    "fantasyStart": 2005,
    "favoriteTeam": "car",
    "mode": "Rebuild",
    "rival": {
      name: "Lowballers & Anyone he loses to.",
      link: null,
      image: "/managers/everyone.png"
    },
    "favoritePlayer": 2133,
    "philosophy": "Bench star players during the week to motivate better performance on the weekend. Engage in psychological warfare with opposing managers when socially acceptable. Outscore opposition.",
    "tradingScale": 6.5
  },
  {
    "roster": 9,
    "name": "Zach Elliott",
    "location": "Hope Mills, NC",
    "bio": "Taco",
    "photo": "/managers/zach.jpg",
    "fantasyStart": 2016,
    "favoriteTeam": "car",
    "mode": "Rebuild",
    "rival": {
      name: "T-Puss and U Wish Ya Had Moore",
      link: 2,
      image: "/managers/rival-dumb-dumber.jpg"
    },
    "favoritePlayer": 1264,
    "philosophy": "Throw for show, run for dough.",
    "tradingScale": 7
  },
  {
    "roster": 10,
    "name": "Wayne Hester",
    "location": "Raleigh, NC",
    "bio": "I\u2019m from Philly, didn\u2019t hold on to the Philly sports traditions but kept the Philly attitude.",
    "photo": "/managers/wayne.jpg",
    "fantasyStart": 2011,
    "favoriteTeam": "ind",
    "mode": "Rebuild",
    "rival": {
      name: "G Woods",
      link: 4,
      image: "/managers/rival-garrett.jpg"
    },
    "favoritePlayer": 4970,
    "philosophy": "Injuries happen but with a roster of 30 it\u2019s a Next Man Up Mentality. NO EXCUSES.",
    "tradingScale": 5
  },
  {
    "roster": 11,
    "name": "Mike McEvoy",
    "location": "New York, NY",
    "bio": "",
    "photo": "/managers/rival-mike.gif",
    "fantasyStart": "2003 (Fantasy Baseball); 2013 (Fantasy Football)",
    "favoriteTeam": "nyj",
    "mode": "Rebuild",
    "rival": {
      name: "Tyler Pollack",
      link: 11,
      image: "/managers/rival-tyler.jpg"
    },
    "favoritePlayer": 350,
    "philosophy": "I, for one, welcome our new robot (auto draft) overlords.",
    "tradingScale": 10
  },
  {
    "roster": 12,
    "name": "Tyler Pollack",
    "location": "Arlington, VA",
    "bio": "Dr. Evil: The details of my life are quite inconsequential.\nTherapist (Carrie Fisher): Oh no, please, please, let's hear about your childhood.\nDr Evil: Very well, where do I begin? My father was a relentlessly self-improving boulangerie owner from Belgium with low grade narcolepsy and a penchant for buggery. My mother was a fifteen year old French prostitute named Chloe with webbed feet. My father would womanize, he would drink, he would make outrageous claims like he invented the question mark. Sometimes he would accuse chestnuts of being lazy, the sort of general malaise that only the genius possess and the insane lament. My childhood was typical, summers in Rangoon, luge lessons. In the spring we'd make meat helmets. When I was insolent I was placed in a burlap bag and beaten with reeds, pretty standard really. At the age of 12 I received my first scribe. At the age of fourteen, a Zoroastrian named Vilma ritualistically shaved my testicles. There really is nothing like a shorn scrotum, it's breathtaking, I suggest you try it.",
    "photo": "/managers/tyler.jpg",
    "fantasyStart": 2009,
    "favoriteTeam": "nyj",
    "mode": "Rebuild",
    "rival": {
      name: "The Dirty Schnitzel",
      link: 1,
      image: "/managers/rival-jj.jpg"
    },
    "favoritePlayer": 6806,
    "philosophy": "Watch the Jets, then do the opposite.",
    "tradingScale": 5
  }
];
var getLeagueData = async (queryLeagueID = leagueID) => {
  if (get_store_value(leagueData)[queryLeagueID]) {
    return get_store_value(leagueData)[queryLeagueID];
  }
  const res = await fetch(`https://api.sleeper.app/v1/league/${queryLeagueID}`, { compress: true }).catch((err) => {
    console.error(err);
  });
  const data2 = await res.json().catch((err) => {
    console.error(err);
  });
  if (res.ok) {
    leagueData.update((ld) => {
      ld[queryLeagueID] = data2;
      return ld;
    });
    return data2;
  } else {
    throw new Error(data2);
  }
};
var getNflState = async () => {
  if (get_store_value(nflState).season) {
    return get_store_value(nflState);
  }
  const res = await fetch(`https://api.sleeper.app/v1/state/nfl`, { compress: true }).catch((err) => {
    console.error(err);
  });
  const data2 = await res.json().catch((err) => {
    console.error(err);
  });
  if (res.ok) {
    nflState.update(() => data2);
    return data2;
  } else {
    throw new Error(data2);
  }
};
var getLeagueRosters = async (queryLeagueID = leagueID) => {
  if (get_store_value(rostersStore)[queryLeagueID]) {
    return get_store_value(rostersStore)[queryLeagueID];
  }
  const res = await fetch(`https://api.sleeper.app/v1/league/${queryLeagueID}/rosters`, { compress: true }).catch((err) => {
    console.error(err);
  });
  const data2 = await res.json().catch((err) => {
    console.error(err);
  });
  if (res.ok) {
    const processedRosters = processRosters(data2);
    rostersStore.update((r) => {
      r[queryLeagueID] = processedRosters;
      return r;
    });
    return processedRosters;
  } else {
    throw new Error(data2);
  }
};
var processRosters = (rosters) => {
  const startersAndReserve = [];
  for (const roster of rosters) {
    for (const starter of roster.starters) {
      startersAndReserve.push(starter);
    }
    if (roster.reserve) {
      for (const ir of roster.reserve) {
        startersAndReserve.push(ir);
      }
    }
  }
  return { rosters, startersAndReserve };
};
var getLeagueUsers = async (queryLeagueID = leagueID) => {
  if (get_store_value(users)[queryLeagueID]) {
    return get_store_value(users)[queryLeagueID];
  }
  const res = await fetch(`https://api.sleeper.app/v1/league/${queryLeagueID}/users`, { compress: true }).catch((err) => {
    console.error(err);
  });
  const data2 = await res.json().catch((err) => {
    console.error(err);
  });
  if (res.ok) {
    const usersData = processUsers(data2);
    users.update((u) => {
      u[queryLeagueID] = usersData;
      return u;
    });
    return usersData;
  } else {
    throw new Error(data2);
  }
};
var processUsers = (rawUsers) => {
  let finalUsers = {};
  for (const user of rawUsers) {
    finalUsers[user.user_id] = user;
  }
  return finalUsers;
};
var getLeagueTransactions = async (preview, refresh = false) => {
  const transactionsStoreVal = get_store_value(transactionsStore);
  if (transactionsStoreVal.transactions) {
    return {
      transactions: checkPreview(preview, transactionsStoreVal.transactions),
      currentManagers: transactionsStoreVal.currentManagers,
      totals: transactionsStoreVal.totals,
      stale: false
    };
  }
  if (!refresh) {
    let localTransactions = await JSON.parse(localStorage.getItem("transactions"));
    if (localTransactions) {
      localTransactions.transactions = checkPreview(preview, localTransactions.transactions);
      localTransactions.stale = true;
      return localTransactions;
    }
  }
  const nflState2 = await getNflState().catch((err) => {
    console.error(err);
  });
  let week = 18;
  if (nflState2.season_type == "regular") {
    week = nflState2.week;
  }
  const { transactionsData, prevManagers, currentManagers, currentSeason } = await combThroughTransactions(week, leagueID).catch((err) => {
    console.error(err);
  });
  const { transactions, totals } = digestTransactions(transactionsData, prevManagers, currentSeason, Object.keys(currentManagers).length);
  const transactionPackage = {
    transactions,
    currentManagers,
    totals
  };
  localStorage.setItem("transactions", JSON.stringify(transactionPackage));
  transactionsStore.update(() => transactionPackage);
  return {
    transactions: checkPreview(preview, transactions),
    currentManagers,
    totals,
    stale: false
  };
};
var checkPreview = (preview, passedTransactions) => {
  if (preview) {
    const previewToReturn = 3;
    const trades = [];
    const waivers = [];
    let i = 0;
    while ((trades.length < previewToReturn || waivers.length < previewToReturn) && i < passedTransactions.length) {
      if (passedTransactions[i].type == "waiver" && waivers.length < previewToReturn) {
        waivers.push(passedTransactions[i]);
      } else if (passedTransactions[i].type == "trade" && trades.length < previewToReturn) {
        trades.push(passedTransactions[i]);
      }
      i++;
    }
    return { trades, waivers };
  }
  return passedTransactions;
};
var combThroughTransactions = async (week, currentLeagueID) => {
  week = week > 0 ? week : 1;
  const leagueIDs = [];
  const prevManagers = {};
  let currentManagers = null;
  let currentSeason = null;
  while (currentLeagueID && currentLeagueID != 0) {
    const [leagueData2, rosterRes, users2] = await waitForAll(getLeagueData(currentLeagueID), getLeagueRosters(currentLeagueID), getLeagueUsers(currentLeagueID)).catch((err) => {
      console.error(err);
    });
    leagueIDs.push(currentLeagueID);
    const rosters = rosterRes.rosters;
    const managers2 = {};
    for (const roster of rosters) {
      const user = users2[roster.owner_id];
      if (user) {
        managers2[roster.roster_id] = {
          avatar: `https://sleepercdn.com/avatars/thumbs/${user.avatar}`,
          name: user.metadata.team_name ? user.metadata.team_name : user.display_name
        };
      } else {
        managers2[roster.roster_id] = {
          avatar: `https://sleepercdn.com/images/v2/icons/player_default.webp`,
          name: "Unknown Manager"
        };
      }
    }
    if (!currentManagers) {
      currentManagers = managers2;
    }
    if (!currentSeason) {
      currentSeason = leagueData2.season;
    }
    prevManagers[leagueData2.season] = managers2;
    currentLeagueID = leagueData2.previous_league_id;
  }
  const transactionPromises = [];
  for (const singleLeagueID of leagueIDs) {
    while (week > 0) {
      transactionPromises.push(fetch(`https://api.sleeper.app/v1/league/${singleLeagueID}/transactions/${week}`, { compress: true }));
      week--;
    }
    week = 18;
  }
  const transactionRess = await waitForAll(...transactionPromises).catch((err) => {
    console.error(err);
  });
  const transactionDataPromises = [];
  for (const transactionRes of transactionRess) {
    if (!transactionRes.ok) {
      throw new Error(transactionRes);
    }
    transactionDataPromises.push(transactionRes.json());
  }
  const transactionsDataJson = await waitForAll(...transactionDataPromises).catch((err) => {
    console.error(err);
  });
  let transactionsData = [];
  for (const transactionDataJson of transactionsDataJson) {
    transactionsData = transactionsData.concat(transactionDataJson);
  }
  return { transactionsData, prevManagers, currentManagers, currentSeason };
};
var digestTransactions = (transactionsData, prevManagers, currentSeason, numRosters) => {
  const transactions = [];
  const totals = {
    allTime: {},
    seasons: {}
  };
  for (let i = 1; i <= numRosters; i++) {
    totals.allTime[i] = {
      trade: 0,
      waiver: 0
    };
  }
  const transactionOrder = transactionsData.sort((a, b) => b.status_updated - a.status_updated);
  for (const transaction of transactionOrder) {
    const { digestedTransaction, season, success } = digestTransaction(transaction, prevManagers, currentSeason);
    if (!success)
      continue;
    transactions.push(digestedTransaction);
    for (const roster of digestedTransaction.rosters) {
      const type = digestedTransaction.type;
      totals.allTime[roster][type]++;
      if (!totals.seasons[season]) {
        totals.seasons[season] = {};
        for (let i = 1; i <= Object.keys(prevManagers[season]).length; i++) {
          totals.seasons[season][i] = {
            trade: 0,
            waiver: 0,
            manager: prevManagers[season][i]
          };
        }
      }
      totals.seasons[season][roster][type]++;
    }
  }
  return { transactions, totals };
};
var digestDate = (tStamp) => {
  var a = new Date(tStamp);
  var months = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
  var year = a.getFullYear();
  var month = months[a.getMonth()];
  var date = a.getDate();
  var hour = a.getHours();
  var min2 = a.getMinutes();
  return month + " " + date + " " + year + ", " + (hour % 12 == 0 ? 12 : hour % 12) + ":" + min2 + (hour / 12 >= 1 ? "PM" : "AM");
};
var digestTransaction = (transaction, prevManagers, currentSeason) => {
  var _a;
  if (transaction.status == "failed")
    return { success: false };
  const handled = [];
  const transactionRosters = transaction.roster_ids;
  const bid = (_a = transaction.settings) == null ? void 0 : _a.waiver_bid;
  const date = digestDate(transaction.status_updated);
  const season = parseInt(date.split(",")[0].split(" ")[2]);
  let digestedTransaction = {
    id: transaction.transaction_id,
    date,
    type: "waiver",
    rosters: transactionRosters,
    moves: []
  };
  if (transaction.type == "trade") {
    digestedTransaction.type = "trade";
  }
  if (season != currentSeason) {
    digestedTransaction.previousOwners = [];
    for (const roster of transactionRosters) {
      digestedTransaction.previousOwners.push(prevManagers[season][roster]);
    }
  }
  const adds = transaction.adds;
  const drops = transaction.drops;
  const draftPicks = transaction.draft_picks;
  for (let player in adds) {
    if (!player) {
      continue;
    }
    handled.push(player);
    digestedTransaction.moves.push(handleAdds(transactionRosters, adds, drops, player, bid));
  }
  for (let player in drops) {
    if (handled.indexOf(player) > -1) {
      continue;
    }
    let move = new Array(transactionRosters.length).fill(null);
    if (!player) {
      continue;
    }
    move[transactionRosters.indexOf(drops[player])] = {
      type: "Dropped",
      player
    };
    digestedTransaction.moves.push(move);
  }
  for (let pick of draftPicks) {
    let move = new Array(transactionRosters.length).fill(null);
    move[transactionRosters.indexOf(pick.previous_owner_id)] = {
      type: "trade",
      pick: {
        season: pick.season,
        round: pick.round,
        original_owner: null
      }
    };
    if (pick.roster_id != pick.previous_owner_id) {
      const original_owner = {
        original: season != currentSeason ? prevManagers[season][pick.roster_id].name : null,
        current: pick.roster_id
      };
      move[transactionRosters.indexOf(pick.previous_owner_id)].pick.original_owner = original_owner;
    }
    move[transactionRosters.indexOf(pick.owner_id)] = "destination";
    digestedTransaction.moves.push(move);
  }
  for (let wBudget of transaction.waiver_budget) {
    let move = new Array(transactionRosters.length).fill(null);
    move[transactionRosters.indexOf(wBudget.sender)] = {
      type: "trade",
      budget: {
        amount: `${wBudget.amount}$`
      }
    };
    move[transactionRosters.indexOf(wBudget.receiver)] = "destination";
    digestedTransaction.moves.push(move);
  }
  return { digestedTransaction, season, success: true };
};
var handleAdds = (rosters, adds, drops, player, bid) => {
  let move = new Array(rosters.length).fill(null);
  if (drops && drops[player]) {
    move[rosters.indexOf(drops[player])] = {
      type: "trade",
      player
    };
    move[rosters.indexOf(adds[player])] = "destination";
    return move;
  }
  move[rosters.indexOf(adds[player])] = {
    type: "Added",
    player,
    bid
  };
  return move;
};
var getLeagueMatchups = async () => {
  if (get_store_value(matchupsStore).matchupWeeks) {
    return get_store_value(matchupsStore);
  }
  const [nflState2, leagueData2, rosterRes, users2] = await waitForAll(getNflState(), getLeagueData(), getLeagueRosters(), getLeagueUsers()).catch((err) => {
    console.error(err);
  });
  let week = 1;
  if (nflState2.season_type == "regular") {
    week = nflState2.display_week;
  } else if (nflState2.season_type == "post") {
    week = 18;
  }
  const year = leagueData2.season;
  const regularSeasonLength = leagueData2.settings.playoff_week_start - 1;
  const rosters = rosterRes.rosters;
  const matchupsPromises = [];
  for (let i = 1; i < leagueData2.settings.playoff_week_start; i++) {
    matchupsPromises.push(fetch(`https://api.sleeper.app/v1/league/${leagueID}/matchups/${i}`, { compress: true }));
  }
  const matchupsRes = await waitForAll(...matchupsPromises);
  const matchupsJsonPromises = [];
  for (const matchupRes of matchupsRes) {
    const data2 = matchupRes.json();
    matchupsJsonPromises.push(data2);
    if (!matchupRes.ok) {
      throw new Error(data2);
    }
  }
  const matchupsData = await waitForAll(...matchupsJsonPromises).catch((err) => {
    console.error(err);
  }).catch((err) => {
    console.error(err);
  });
  const matchupWeeks = [];
  for (let i = 1; i < matchupsData.length + 1; i++) {
    const processed = processMatchups(matchupsData[i - 1], rosters, users2, i);
    if (processed) {
      matchupWeeks.push({
        matchups: processed.matchups,
        week: processed.week
      });
    }
  }
  const matchupsResponse = {
    matchupWeeks,
    year,
    week,
    regularSeasonLength
  };
  matchupsStore.update(() => matchupsResponse);
  return matchupsResponse;
};
var processMatchups = (inputMatchups, rosters, users2, week) => {
  if (!inputMatchups || inputMatchups.length == 0) {
    return false;
  }
  const matchups = {};
  for (const match2 of inputMatchups) {
    if (!matchups[match2.matchup_id]) {
      matchups[match2.matchup_id] = [];
    }
    let user = users2[rosters[match2.roster_id - 1].owner_id];
    matchups[match2.matchup_id].push({
      manager: {
        name: user.metadata.team_name ? user.metadata.team_name : user.display_name,
        avatar: `https://sleepercdn.com/avatars/thumbs/${user.avatar}`
      },
      starters: match2.starters,
      points: match2.starters_points
    });
  }
  return { matchups, week };
};
var NBC_URL = "https://www.nbcsportsedge.com/edge/api/player_news?sort=-created&page%5Blimit%5D=10&page%5Boffset%5D=0&filter%5Bleague.meta.drupal_internal__id%5D=21&include=player,position,team,team.secondary_logo,player.image,related_players,related_teams";
var REDDIT_DYNASTY = "https://www.reddit.com/r/DynastyFF/new.json";
var SERVER_API = "./api/fetch_serverside_news";
var getNews = async (bypass = false) => {
  if (get_store_value(news)[0] && !bypass) {
    return { articles: get_store_value(news), fresh: false };
  }
  const newsSources = [
    getFeed(NBC_URL, processNBC),
    fetch(SERVER_API, { compress: true })
  ];
  {
    newsSources.push(getFeed(REDDIT_DYNASTY, processReddit));
  }
  const [nbcNews, serverRes, reddit] = await waitForAll(...newsSources).catch((err) => {
    console.error(err);
  });
  const serverData = await serverRes.json().catch((err) => {
    console.error(err);
  });
  const articles = [...nbcNews, ...reddit, ...serverData].sort((a, b) => a.ts < b.ts ? 1 : -1);
  news.update(() => articles);
  return { articles, fresh: true };
};
var getFeed = async (feed, callback) => {
  const res = await fetch(feed, { compress: true }).catch((err) => {
    console.error(err);
  });
  const data2 = await res.json().catch((err) => {
    console.error(err);
  });
  if (res.ok) {
    return callback(data2.data);
  } else {
    throw new Error(data2);
  }
};
var processNBC = (rawArticles) => {
  let finalArticles = [];
  for (const rawArticle of rawArticles) {
    const ts = Date.parse(rawArticle.attributes.changed);
    const d2 = new Date(ts);
    const date = stringDate$1(d2);
    finalArticles.push({
      title: rawArticle.attributes.headline,
      article: `${rawArticle.attributes.news.processed}${rawArticle.attributes.analysis ? rawArticle.attributes.analysis.processed : ""}`,
      link: rawArticle.attributes.source_url,
      author: rawArticle.attributes.source,
      ts,
      date,
      icon: "newsIcons/nbcSportsEdge.jpeg"
    });
  }
  return finalArticles;
};
var processReddit = (rawArticles) => {
  var _a;
  const bannedAuthors = [
    "AutoModerator",
    "FFBot",
    "Brookskbrothers",
    "FTAKJ"
  ];
  const bannedIcons = [
    "",
    "self",
    "thumbnail",
    "default"
  ];
  let finalArticles = [];
  const children = rawArticles.children;
  for (const rawArticle of children) {
    const data2 = rawArticle.data;
    if (bannedAuthors.includes(data2.author)) {
      continue;
    }
    const ts = data2.created_utc * 1e3;
    const d2 = new Date(ts);
    const icon = !bannedIcons.includes(data2.thumbnail) ? data2.thumbnail : `newsIcons/${data2.subreddit}.png`;
    const date = stringDate$1(d2);
    let article = `<a href="${data2.url}" class="body-link">${data2.url}</a>`;
    if (data2.selftext_html) {
      article = decodeHTML(data2.selftext_html);
    }
    if ((_a = data2.secure_media_embed) == null ? void 0 : _a.content) {
      decodeHTML(data2.secure_media_embed.content);
    }
    finalArticles.push({
      title: data2.title,
      article,
      link: `https://www.reddit.com${data2.permalink}`,
      author: `${data2.subreddit_name_prefixed} - u/${data2.author}`,
      ts,
      date,
      icon
    });
  }
  return finalArticles;
};
var htmlEntities = {
  nbsp: " ",
  cent: "\xA2",
  pound: "\xA3",
  yen: "\xA5",
  euro: "\u20AC",
  copy: "\xA9",
  reg: "\xAE",
  lt: "<",
  gt: ">",
  quot: '"',
  amp: "&",
  apos: "'"
};
function decodeHTML(str) {
  return str.replace(/\&([^;]+);/g, function(entity, entityCode) {
    let match2;
    if (entityCode in htmlEntities) {
      return htmlEntities[entityCode];
    } else if (match2 = entityCode.match(/^#x([\da-fA-F]+)$/)) {
      return String.fromCharCode(parseInt(match2[1], 16));
    } else if (match2 = entityCode.match(/^#(\d+)$/)) {
      return String.fromCharCode(~~match2[1]);
    } else {
      return entity;
    }
  });
}
var stringDate$1 = (d2) => {
  return `${d2.getMonth() + 1}/${d2.getDate()}/${d2.getFullYear()} ${d2.getHours() % 12}:${(d2.getMinutes() < 10 ? "0" : "") + d2.getMinutes()}${d2.getHours() / 12 >= 1 ? "PM" : "AM"}`;
};
var loadPlayers = async (refresh = false) => {
  if (get_store_value(players)[1426]) {
    return {
      players: get_store_value(players),
      stale: false
    };
  }
  const now = Math.round(new Date().getTime() / 1e3);
  const playersInfo = JSON.parse(localStorage.getItem("playersInfo"));
  let expiration = parseInt(localStorage.getItem("expiration"));
  if (playersInfo && playersInfo[1426] && expiration && now > expiration && !refresh) {
    return {
      players: playersInfo,
      stale: true
    };
  }
  if (!playersInfo || !expiration || now > expiration) {
    const res = await fetch(`/api/fetch_players_info`, { compress: true });
    const data2 = await res.json();
    if (!res.ok) {
      throw new Error(data2);
    }
    localStorage.setItem("playersInfo", JSON.stringify(data2));
    const ts = Math.round(new Date().getTime() / 1e3);
    const newExpiration = ts + 24 * 3600;
    localStorage.setItem("expiration", newExpiration);
    players.update(() => data2);
    return {
      players: data2,
      stale: false
    };
  }
  players.update(() => playersInfo);
  return {
    players: playersInfo,
    stale: false
  };
};
var getUpcomingDraft = async () => {
  if (get_store_value(upcomingDraft).draft) {
    return get_store_value(upcomingDraft);
  }
  const [rosterRes, users2, leagueData2] = await waitForAll(getLeagueRosters(), getLeagueUsers(), getLeagueData()).catch((err) => {
    console.error(err);
  });
  const draftID = leagueData2.draft_id;
  const regularSeasonLength = leagueData2.settings.playoff_week_start - 1;
  let year = parseInt(leagueData2.season);
  const rosters = rosterRes.rosters;
  const originalManagers = {};
  for (const roster of rosters) {
    const user = users2[roster.owner_id];
    if (user) {
      originalManagers[roster.roster_id] = {
        avatar: `https://sleepercdn.com/avatars/thumbs/${user.avatar}`,
        name: user.metadata.team_name ? user.metadata.team_name : user.display_name
      };
    } else {
      originalManagers[roster.roster_id] = {
        avatar: `https://sleepercdn.com/images/v2/icons/player_default.webp`,
        name: "Unknown Manager"
      };
    }
  }
  const [officialDraftRes, picksRes] = await waitForAll(fetch(`https://api.sleeper.app/v1/draft/${draftID}`, { compress: true }), fetch(`https://api.sleeper.app/v1/league/${leagueID}/traded_picks`, { compress: true })).catch((err) => {
    console.error(err);
  });
  const [officialDraft, picks] = await waitForAll(officialDraftRes.json(), picksRes.json()).catch((err) => {
    console.error(err);
  });
  let draft;
  let draftOrder;
  let accuracy;
  if (officialDraft.status == "complete") {
    year = year + 1;
    const buildRes = buildFromScratch(rosters, officialDraft.slot_to_roster_id, officialDraft.settings.rounds, picks.filter((pick) => parseInt(pick.season) == year), originalManagers, regularSeasonLength);
    draft = buildRes.draft;
    draftOrder = buildRes.draftOrder;
    accuracy = buildRes.accuracy;
  } else {
    const buildRes = buildConfirmed(officialDraft.slot_to_roster_id, officialDraft.settings.rounds, picks.filter((pick) => parseInt(pick.season) == year), originalManagers);
    draft = buildRes.draft;
    draftOrder = buildRes.draftOrder;
  }
  const draftData = {
    year,
    draft,
    draftOrder,
    accuracy,
    draftType: officialDraft.type,
    reversalRound: officialDraft.settings.reversal_round,
    originalManagers
  };
  upcomingDraft.update(() => draftData);
  return draftData;
};
var buildFromScratch = (rosters, previousOrder, rounds, picks, originalManagers, regularSeasonLength) => {
  const draftOrder = [];
  const testRoster = rosters[0].settings;
  const progression = testRoster.wins + testRoster.ties + testRoster.losses;
  if (progression == 0) {
    for (const key in previousOrder) {
      draftOrder.push(previousOrder[key]);
    }
  } else {
    const sortedRosters = rosters.sort((a, b) => {
      const rosterA = a.settings;
      const rosterB = b.settings;
      if (rosterA.wins != rosterB.wins) {
        return rosterA.wins - rosterB.wins;
      }
      if (rosterA.ties != rosterB.ties) {
        return rosterA.ties - rosterB.ties;
      }
      return rosterA.fpts + rosterA.fpts_decimal / 100 - (rosterB.fpts + rosterB.fpts_decimal / 100);
    });
    for (const key in sortedRosters) {
      draftOrder.push(sortedRosters[key].roster_id);
    }
  }
  const row = new Array(rosters.length);
  let draft = [];
  for (let i = 0; i < rounds; i++) {
    draft.push([...row]);
  }
  for (const pick of picks) {
    if (pick.owner_id == pick.roster_id || pick.round > rounds)
      continue;
    draft[pick.round - 1][draftOrder.indexOf(pick.roster_id)] = originalManagers[pick.owner_id].name;
  }
  let accuracy = (progression + 1) / (regularSeasonLength + 1);
  accuracy = accuracy > 1 ? 1 : accuracy;
  return { draft, draftOrder, accuracy };
};
var buildConfirmed = (draftOrderObj, rounds, picks, originalManagers, players2 = null, type = null) => {
  const draftOrder = [];
  let leagueSize = 0;
  for (const key in draftOrderObj) {
    leagueSize++;
    draftOrder.push(draftOrderObj[key]);
  }
  const row = new Array(leagueSize).fill();
  let draft = [];
  for (let i = 0; i < rounds; i++) {
    draft.push([...row]);
  }
  if (players2 && type != "auction") {
    draft = completedNonAuction({ players: players2, draft, picks, originalManagers, draftOrder, rounds });
  } else if (players2) {
    draft = completedAuction({ players: players2, draft, picks, originalManagers, draftOrder, draftOrderObj });
  } else {
    for (const pick of picks) {
      if (pick.owner_id == pick.roster_id || pick.round > rounds)
        continue;
      draft[pick.round - 1][draftOrder.indexOf(pick.roster_id)] = originalManagers[pick.owner_id].name;
    }
  }
  return { draft, draftOrder };
};
var completedNonAuction = ({ players: players2, draft, picks, originalManagers, draftOrder, rounds }) => {
  for (const playerData of players2) {
    const player = {
      name: `${playerData.metadata.first_name} ${playerData.metadata.last_name}`,
      position: playerData.metadata.position,
      team: playerData.metadata.team,
      avatar: playerData.metadata.position == "DEF" ? `background-image: url(https://sleepercdn.com/images/team_logos/nfl/${playerData.player_id.toLowerCase()}.png)` : `background-image: url(https://sleepercdn.com/content/nfl/players/thumb/${playerData.player_id}.jpg), url(https://sleepercdn.com/images/v2/icons/player_default.webp)`
    };
    draft[playerData.round - 1][playerData.draft_slot - 1] = { player };
  }
  for (const pick of picks) {
    if (pick.owner_id == pick.roster_id || pick.round > rounds)
      continue;
    draft[pick.round - 1][draftOrder.indexOf(pick.roster_id)].newOwner = originalManagers[pick.owner_id].name;
  }
  return draft;
};
var completedAuction = ({ players: players2, draft, picks, originalManagers, draftOrder, draftOrderObj }) => {
  const rosters = {};
  for (const key in draftOrderObj) {
    rosters[draftOrderObj[key]] = [];
  }
  for (const playerData of players2) {
    const player = {
      name: `${playerData.metadata.first_name} ${playerData.metadata.last_name}`,
      position: playerData.metadata.position,
      team: playerData.metadata.team,
      amount: playerData.metadata.amount,
      avatar: playerData.metadata.position == "DEF" ? `background-image: url(https://sleepercdn.com/images/team_logos/nfl/${playerData.player_id.toLowerCase()}.png)` : `background-image: url(https://sleepercdn.com/content/nfl/players/thumb/${playerData.player_id}.jpg), url(https://sleepercdn.com/images/v2/icons/player_default.webp)`
    };
    rosters[playerData.roster_id].push(player);
  }
  for (const roster in rosters) {
    const col = draftOrder.indexOf(parseInt(roster));
    const sortedRoster = rosters[roster].sort((a, b) => b.amount - a.amount);
    for (let i = 0; i < sortedRoster.length; i++) {
      const player = sortedRoster[i];
      draft[i][col] = { player };
    }
  }
  return draft;
};
var getPreviousDrafts = async () => {
  if (get_store_value(previousDrafts).length > 0) {
    return get_store_value(previousDrafts);
  }
  let curSeason = leagueID;
  const drafts = [];
  let currentManagers;
  while (curSeason && curSeason != 0) {
    const [rosterRes, users2, leagueData2] = await waitForAll(getLeagueRosters(curSeason), getLeagueUsers(curSeason), getLeagueData(curSeason)).catch((err) => {
      console.error(err);
    });
    const draftID = leagueData2.draft_id;
    let year = parseInt(leagueData2.season);
    curSeason = leagueData2.previous_league_id;
    const rosters = rosterRes.rosters;
    const originalManagers = {};
    for (const roster of rosters) {
      const user = users2[roster.owner_id];
      if (user) {
        originalManagers[roster.roster_id] = {
          avatar: `https://sleepercdn.com/avatars/thumbs/${user.avatar}`,
          name: user.metadata.team_name ? user.metadata.team_name : user.display_name
        };
      } else {
        originalManagers[roster.roster_id] = {
          avatar: `https://sleepercdn.com/images/v2/icons/player_default.webp`,
          name: "Unknown Manager"
        };
      }
    }
    if (!currentManagers) {
      currentManagers = originalManagers;
    }
    const [officialDraftRes, picksRes, playersRes] = await waitForAll(fetch(`https://api.sleeper.app/v1/draft/${draftID}`, { compress: true }), fetch(`https://api.sleeper.app/v1/draft/${draftID}/traded_picks`, { compress: true }), fetch(`https://api.sleeper.app/v1/draft/${draftID}/picks`, { compress: true })).catch((err) => {
      console.error(err);
    });
    const [officialDraft, picks, players2] = await waitForAll(officialDraftRes.json(), picksRes.json(), playersRes.json()).catch((err) => {
      console.error(err);
    });
    if (officialDraft.status != "complete")
      continue;
    let draft;
    let draftOrder;
    const buildRes = buildConfirmed(officialDraft.slot_to_roster_id, officialDraft.settings.rounds, picks, originalManagers, players2, officialDraft.type);
    draft = buildRes.draft;
    draftOrder = buildRes.draftOrder;
    const newDraft = {
      year,
      draft,
      draftOrder,
      draftType: officialDraft.type,
      reversalRound: officialDraft.settings.reversal_round,
      originalManagers
    };
    if (originalManagers != currentManagers) {
      newDraft.currentManagers = currentManagers;
    }
    drafts.push(newDraft);
  }
  previousDrafts.update(() => drafts);
  return drafts;
};
var getLeagueRecords = async (refresh = false) => {
  if (get_store_value(records).seasonWeekRecords) {
    return get_store_value(records);
  }
  if (!refresh) {
    let localRecords = await JSON.parse(localStorage.getItem("records"));
    if (localRecords) {
      localRecords.stale = true;
      return localRecords;
    }
  }
  const nflState2 = await getNflState().catch((err) => {
    console.error(err);
  });
  let week = 0;
  if (nflState2.season_type == "regular") {
    week = nflState2.week - 1;
  } else if (nflState2.season_type == "post") {
    week = 18;
  }
  let curSeason = leagueID;
  let currentManagers;
  let currentYear;
  let lastYear;
  let allTimeMatchupDifferentials = [];
  let leagueRosterRecords = {};
  let seasonWeekRecords = [];
  let leagueWeekRecords = [];
  let mostSeasonLongPoints = [];
  let allTimeBiggestBlowouts = [];
  let allTimeClosestMatchups = [];
  while (curSeason && curSeason != 0) {
    const [rosterRes, users2, leagueData2] = await waitForAll(getLeagueRosters(curSeason), getLeagueUsers(curSeason), getLeagueData(curSeason)).catch((err) => {
      console.error(err);
    });
    let year = parseInt(leagueData2.season);
    if (leagueData2.status == "complete" || week > leagueData2.settings.playoff_week_start - 1) {
      week = leagueData2.settings.playoff_week_start - 1;
    }
    lastYear = year;
    const rosters = rosterRes.rosters;
    const originalManagers = {};
    for (const roster of rosters) {
      const rosterID = roster.roster_id;
      const user = users2[roster.owner_id];
      if (user) {
        originalManagers[rosterID] = {
          avatar: `https://sleepercdn.com/avatars/thumbs/${user.avatar}`,
          name: user.metadata.team_name ? user.metadata.team_name : user.display_name
        };
      } else {
        originalManagers[rosterID] = {
          avatar: `https://sleepercdn.com/images/v2/icons/player_default.webp`,
          name: "Unknown Manager"
        };
      }
      if (roster.settings.wins == 0 && roster.settings.ties == 0 && roster.settings.losses == 0)
        continue;
      if (!leagueRosterRecords[rosterID]) {
        leagueRosterRecords[rosterID] = {
          wins: 0,
          losses: 0,
          ties: 0,
          fptsFor: 0,
          fptsAgainst: 0,
          potentialPoints: 0,
          years: []
        };
      }
      const fpts = roster.settings.fpts + roster.settings.fpts_decimal / 100;
      const fptsAgainst = roster.settings.fpts_against + roster.settings.fpts_against_decimal / 100;
      const potentialPoints = roster.settings.ppts + roster.settings.ppts_decimal / 100;
      leagueRosterRecords[rosterID].wins += roster.settings.wins;
      leagueRosterRecords[rosterID].losses += roster.settings.losses;
      leagueRosterRecords[rosterID].ties += roster.settings.ties;
      leagueRosterRecords[rosterID].fptsFor += fpts;
      leagueRosterRecords[rosterID].fptsAgainst += fptsAgainst;
      leagueRosterRecords[rosterID].potentialPoints += potentialPoints;
      const singleYearInfo = {
        wins: roster.settings.wins,
        losses: roster.settings.losses,
        ties: roster.settings.ties,
        fpts,
        fptsAgainst,
        potentialPoints,
        manager: originalManagers[rosterID],
        year
      };
      leagueRosterRecords[rosterID].years.push(singleYearInfo);
      mostSeasonLongPoints.push({
        rosterID,
        fpts,
        year,
        manager: originalManagers[rosterID]
      });
    }
    if (!currentManagers) {
      currentManagers = originalManagers;
    }
    const matchupsPromises = [];
    let startWeek = parseInt(week);
    while (week > 0) {
      matchupsPromises.push(fetch(`https://api.sleeper.app/v1/league/${curSeason}/matchups/${week}`, { compress: true }));
      week--;
    }
    const matchupsRes = await waitForAll(...matchupsPromises).catch((err) => {
      console.error(err);
    });
    const matchupsJsonPromises = [];
    for (const matchupRes of matchupsRes) {
      const data2 = matchupRes.json();
      matchupsJsonPromises.push(data2);
      if (!matchupRes.ok) {
        throw new Error(data2);
      }
    }
    const matchupsData = await waitForAll(...matchupsJsonPromises).catch((err) => {
      console.error(err);
    });
    curSeason = leagueData2.previous_league_id;
    const seasonPointsRecord = [];
    let matchupDifferentials = [];
    for (const matchupWeek of matchupsData) {
      let matchups = {};
      for (const matchup of matchupWeek) {
        const entry = {
          manager: originalManagers[matchup.roster_id],
          fpts: matchup.points,
          week: startWeek,
          year,
          rosterID: matchup.roster_id
        };
        seasonPointsRecord.push(entry);
        leagueWeekRecords.push(entry);
        if (!matchups[matchup.matchup_id]) {
          matchups[matchup.matchup_id] = [];
        }
        matchups[matchup.matchup_id].push(entry);
      }
      startWeek--;
      for (const matchupKey in matchups) {
        const matchup = matchups[matchupKey];
        let home = matchup[0];
        let away = matchup[1];
        if (matchup[0].fpts < matchup[1].fpts) {
          home = matchup[1];
          away = matchup[0];
        }
        const matchupDifferential = {
          year: home.year,
          week: home.week,
          home: {
            manager: home.manager,
            fpts: home.fpts,
            rosterID: home.rosterID
          },
          away: {
            manager: away.manager,
            fpts: away.fpts,
            rosterID: away.rosterID
          },
          differential: home.fpts - away.fpts
        };
        allTimeMatchupDifferentials.push(matchupDifferential);
        matchupDifferentials.push(matchupDifferential);
      }
    }
    matchupDifferentials = matchupDifferentials.sort((a, b) => b.differential - a.differential);
    const biggestBlowouts = matchupDifferentials.slice(0, 10);
    const closestMatchups = [];
    for (let i = 0; i < 10; i++) {
      closestMatchups.push(matchupDifferentials.pop());
    }
    const interSeasonEntry = {
      year,
      biggestBlowouts,
      closestMatchups,
      seasonPointsRecords: seasonPointsRecord.sort((a, b) => b.fpts - a.fpts).slice(0, 10)
    };
    if (interSeasonEntry.seasonPointsRecords.length > 0) {
      if (!currentYear) {
        currentYear = year;
      }
      seasonWeekRecords.push(interSeasonEntry);
    }
  }
  allTimeMatchupDifferentials = allTimeMatchupDifferentials.sort((a, b) => b.differential - a.differential);
  allTimeBiggestBlowouts = allTimeMatchupDifferentials.slice(0, 10);
  for (let i = 0; i < 10; i++) {
    allTimeClosestMatchups.push(allTimeMatchupDifferentials.pop());
  }
  leagueWeekRecords = leagueWeekRecords.sort((a, b) => b.fpts - a.fpts).slice(0, 10);
  mostSeasonLongPoints = mostSeasonLongPoints.sort((a, b) => b.fpts - a.fpts).slice(0, 10);
  const recordsData = {
    allTimeBiggestBlowouts,
    allTimeClosestMatchups,
    mostSeasonLongPoints,
    leagueWeekRecords,
    seasonWeekRecords,
    leagueRosterRecords,
    currentManagers,
    currentYear,
    lastYear
  };
  localStorage.setItem("records", JSON.stringify(recordsData));
  records.update(() => recordsData);
  return recordsData;
};
var getAwards = async () => {
  if (get_store_value(awards).podiums) {
    return get_store_value(awards);
  }
  const [rosterRes, users2, leagueData2] = await waitForAll(getLeagueRosters(), getLeagueUsers(), getLeagueData()).catch((err) => {
    console.error(err);
  });
  const rosters = rosterRes.rosters;
  const currentManagers = {};
  for (const roster of rosters) {
    const user = users2[roster.owner_id];
    if (user) {
      currentManagers[roster.roster_id] = {
        avatar: `https://sleepercdn.com/avatars/thumbs/${user.avatar}`,
        name: user.metadata.team_name ? user.metadata.team_name : user.display_name
      };
    } else {
      currentManagers[roster.roster_id] = {
        avatar: `https://sleepercdn.com/images/v2/icons/player_default.webp`,
        name: "Unknown Manager"
      };
    }
  }
  let previousSeasonID = leagueData2.previous_league_id;
  const podiums = await getPodiums(previousSeasonID);
  const gatheredAwards = {
    podiums,
    currentManagers
  };
  awards.update(() => gatheredAwards);
  return gatheredAwards;
};
var getPodiums = async (previousSeasonID) => {
  const podiums = [];
  while (previousSeasonID && previousSeasonID != 0) {
    const previousSeasonData = await getPreviousLeagueData(previousSeasonID);
    const {
      losersData,
      winnersData,
      year,
      previousRosters,
      numDivisions,
      usersData,
      playoffRounds,
      toiletRounds,
      leagueMetadata
    } = previousSeasonData;
    previousSeasonID = previousSeasonData.previousSeasonID;
    const { divisions, prevManagers } = buildDivisionsAndManagers({ usersData, previousRosters, leagueMetadata, numDivisions });
    const divisionArr = [];
    for (const key in divisions) {
      divisions[key].manager = prevManagers[divisions[key].roster];
      divisionArr.push(divisions[key]);
    }
    const finalsMatch = winnersData.filter((m) => m.r == playoffRounds && m.t1_from.w)[0];
    const champion = prevManagers[finalsMatch.w];
    const second = prevManagers[finalsMatch.l];
    const runnersUpMatch = winnersData.filter((m) => m.r == playoffRounds && m.t1_from.l)[0];
    const third = prevManagers[runnersUpMatch.w];
    const toiletBowlMatch = losersData.filter((m) => m.r == toiletRounds && (!m.t1_from || m.t1_from.w))[0];
    const toilet = prevManagers[toiletBowlMatch.w];
    const podium = {
      year,
      champion,
      second,
      third,
      divisions: divisionArr,
      toilet
    };
    podiums.push(podium);
  }
  return podiums;
};
var getPreviousLeagueData = async (previousSeasonID) => {
  const resPromises = [
    fetch(`https://api.sleeper.app/v1/league/${previousSeasonID}`, { compress: true }),
    getLeagueRosters(previousSeasonID),
    getLeagueUsers(previousSeasonID),
    fetch(`https://api.sleeper.app/v1/league/${previousSeasonID}/losers_bracket`, { compress: true }),
    fetch(`https://api.sleeper.app/v1/league/${previousSeasonID}/winners_bracket`, { compress: true })
  ];
  const [leagueRes, rostersData, usersData, losersRes, winnersRes] = await waitForAll(...resPromises).catch((err) => {
    console.error(err);
  });
  if (!leagueRes.ok || !losersRes.ok || !winnersRes.ok) {
    throw new Error(data);
  }
  const jsonPromises = [
    leagueRes.json(),
    losersRes.json(),
    winnersRes.json()
  ];
  const [prevLeagueData, losersData, winnersData] = await waitForAll(...jsonPromises).catch((err) => {
    console.error(err);
  });
  const year = prevLeagueData.season;
  const previousRosters = rostersData.rosters;
  const numDivisions = prevLeagueData.settings.divisions || 1;
  previousSeasonID = prevLeagueData.previous_league_id;
  const playoffRounds = winnersData[winnersData.length - 1].r;
  const toiletRounds = losersData[losersData.length - 1].r;
  return {
    losersData,
    winnersData,
    year,
    previousRosters,
    numDivisions,
    usersData,
    previousSeasonID,
    playoffRounds,
    toiletRounds,
    leagueMetadata: prevLeagueData.metadata
  };
};
var buildDivisionsAndManagers = ({ usersData, previousRosters, leagueMetadata, numDivisions }) => {
  const prevManagers = {};
  const divisions = {};
  for (let i = 0; i < numDivisions; i++) {
    divisions[i + 1] = {
      name: leagueMetadata ? leagueMetadata[`division_${i + 1}`] : null,
      roster: null,
      wins: -1,
      points: -1
    };
  }
  for (const roster of previousRosters) {
    const rSettings = roster.settings;
    const div = rSettings.division ? rSettings.division : 1;
    if (rSettings.wins > divisions[div].wins || rSettings.wins == divisions[div].wins && rSettings.fpts + rSettings.fpts_decimal / 100 == divisions[div].points) {
      divisions[div].points = rSettings.fpts + rSettings.fpts_decimal / 100;
      divisions[div].wins = rSettings.wins;
      divisions[div].roster = roster.roster_id;
    }
    const user = usersData[roster.owner_id];
    prevManagers[roster.roster_id] = {
      rosterID: roster.roster_id,
      avatar: `https://sleepercdn.com/images/v2/icons/player_default.webp`,
      name: "Unknown Manager"
    };
    if (user) {
      prevManagers[roster.roster_id].avatar = `https://sleepercdn.com/avatars/thumbs/${user.avatar}`;
      prevManagers[roster.roster_id].name = user.metadata.team_name ? user.metadata.team_name : user.display_name;
    }
  }
  return { divisions, prevManagers };
};
function guard(name) {
  return () => {
    throw new Error(`Cannot call ${name}(...) on the server`);
  };
}
var goto = guard("goto");
var cleanName = (name) => {
  return name.replace("Team ", "").toLowerCase().replace(/[ '!"#$%&\\'()\*+,\-\.\/:;<=>?@\[\\\]\^_`{|}~']/g, "");
};
var round = (num) => {
  return (Math.round((num + Number.EPSILON) * 100) / 100).toFixed(2);
};
var min = (stats, roundOverride) => {
  const num = Math.min(...stats);
  return Math.floor(num / roundOverride) * roundOverride;
};
var max = (stats, roundOverride) => {
  const num = Math.max(...stats);
  return Math.ceil(num / roundOverride) * roundOverride;
};
var generateGraph = ({ stats, x, y, stat, header, field, short, secondField = null }, roundOverride = 10, yMinOverride = null) => {
  if (!stats) {
    return null;
  }
  const graph = {
    stats: [],
    secondStats: [],
    managers: [],
    rosterIDs: [],
    labels: { x, y, stat },
    header,
    yMin: 0,
    yMax: 0,
    short
  };
  const sortedStats = [...stats].sort((a, b) => a.rosterID - b.rosterID);
  for (const indivStat of sortedStats) {
    graph.stats.push(Math.round(indivStat[field]));
    if (secondField) {
      graph.secondStats.push(Math.round(indivStat[secondField]));
    }
    graph.managers.push(indivStat.manager);
    graph.rosterIDs.push(indivStat.rosterID);
  }
  graph.yMax = max(graph.stats, roundOverride);
  graph.yMin = min(graph.stats, roundOverride);
  if (secondField) {
    graph.yMin = min(graph.secondStats, roundOverride);
  }
  if (yMinOverride) {
    graph.yMin = yMinOverride;
  }
  return graph;
};
var predictScores = (players2, week, leagueData2) => {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r;
  const starterPositions = getStarterPositions(leagueData2);
  const projectedPlayers = [...players2].sort((a, b) => (b.wi && b.wi[week] ? b.wi[week].p : 0) - (a.wi && a.wi[week] ? a.wi[week].p : 0));
  const qbs = projectedPlayers.filter((p) => p.pos == "QB");
  const wrs = projectedPlayers.filter((p) => p.pos == "WR");
  const rbs = projectedPlayers.filter((p) => p.pos == "RB");
  const tes = projectedPlayers.filter((p) => p.pos == "TE");
  const defs = projectedPlayers.filter((p) => p.pos == "DEF");
  const ks = projectedPlayers.filter((p) => p.pos == "K");
  const dls = projectedPlayers.filter((p) => p.pos == "DL");
  const lbs = projectedPlayers.filter((p) => p.pos == "LB");
  const dbs = projectedPlayers.filter((p) => p.pos == "DB");
  let powerScore = 0;
  for (const starterPosition of starterPositions) {
    const qb = parseFloat(((_a = qbs[0]) == null ? void 0 : _a.wi) && ((_b = qbs[0]) == null ? void 0 : _b.wi[week]) ? qbs[0].wi[week].p : 0);
    const rb = parseFloat(((_c = rbs[0]) == null ? void 0 : _c.wi) && ((_d = rbs[0]) == null ? void 0 : _d.wi[week]) ? rbs[0].wi[week].p : 0);
    const wr = parseFloat(((_e = wrs[0]) == null ? void 0 : _e.wi) && ((_f = wrs[0]) == null ? void 0 : _f.wi[week]) ? wrs[0].wi[week].p : 0);
    const te = parseFloat(((_g = tes[0]) == null ? void 0 : _g.wi) && ((_h = tes[0]) == null ? void 0 : _h.wi[week]) ? tes[0].wi[week].p : 0);
    const dl = parseFloat(((_i = dls[0]) == null ? void 0 : _i.wi) && ((_j = dls[0]) == null ? void 0 : _j.wi[week]) ? dls[0].wi[week].p : 0);
    const lb = parseFloat(((_k = lbs[0]) == null ? void 0 : _k.wi) && ((_l = lbs[0]) == null ? void 0 : _l.wi[week]) ? lbs[0].wi[week].p : 0);
    const db = parseFloat(((_m = dbs[0]) == null ? void 0 : _m.wi) && ((_n = dbs[0]) == null ? void 0 : _n.wi[week]) ? dbs[0].wi[week].p : 0);
    const k = parseFloat(((_o = ks[0]) == null ? void 0 : _o.wi) && ((_p = ks[0]) == null ? void 0 : _p.wi[week]) ? ks[0].wi[week].p : 0);
    const def = parseFloat(((_q = defs[0]) == null ? void 0 : _q.wi) && ((_r = defs[0]) == null ? void 0 : _r.wi[week]) ? defs[0].wi[week].p : 0);
    switch (starterPosition) {
      case "QB":
        qbs.shift();
        powerScore += qb;
        break;
      case "RB":
        rbs.shift();
        powerScore += rb;
        break;
      case "WR":
        wrs.shift();
        powerScore += wr;
        break;
      case "TE":
        tes.shift();
        powerScore += te;
        break;
      case "DEF":
        defs.shift();
        powerScore += def;
        break;
      case "K":
        ks.shift();
        powerScore += k;
        break;
      case "DL":
        dls.shift();
        powerScore += dl;
        break;
      case "LB":
        lbs.shift();
        powerScore += lb;
        break;
      case "DB":
        dbs.shift();
        powerScore += db;
        break;
      case "FLEX":
        if (rb >= wr && rb >= te) {
          rbs.shift();
          powerScore += rb;
        } else if (wr >= rb && wr >= te) {
          wrs.shift();
          powerScore += wr;
        } else {
          tes.shift();
          powerScore += te;
        }
        break;
      case "WRRB_FLEX":
        if (rb >= wr) {
          rbs.shift();
          powerScore += rb;
        } else {
          wrs.shift();
          powerScore += wr;
        }
        break;
      case "SUPER_FLEX":
        if (qb >= wr && qb >= te && qb >= rb) {
          qbs.shift();
          powerScore += qb;
        } else if (rb >= wr && rb >= te && rb >= qb) {
          rbs.shift();
          powerScore += rb;
        } else if (wr >= rb && wr >= te && wr >= qb) {
          wrs.shift();
          powerScore += wr;
        } else {
          tes.shift();
          powerScore += te;
        }
        break;
      case "IDP":
        if (dl >= lb && dl >= db) {
          dls.shift();
          powerScore += dl;
        } else if (lb >= dl && lb >= db) {
          lbs.shift();
          powerScore += lb;
        } else {
          dbs.shift();
          powerScore += db;
        }
        break;
    }
  }
  return powerScore;
};
var getStarterPositions = (leagueData2) => {
  const rosterPositions = leagueData2.roster_positions;
  const firstBench = rosterPositions.indexOf("BN");
  return rosterPositions.slice(0, firstBench);
};
var getBrackets = async () => {
  if (get_store_value(brackets).champs) {
    return get_store_value(brackets);
  }
  const [rosterRes, users2, leagueData2] = await waitForAll(getLeagueRosters(), getLeagueUsers(), getLeagueData()).catch((err) => {
    console.error(err);
  });
  const rosters = rosterRes.rosters;
  const numRosters = rosters.length;
  const bracketsAndMatchupFetches = [
    fetch(`https://api.sleeper.app/v1/league/${leagueID}/winners_bracket`, { compress: true }),
    fetch(`https://api.sleeper.app/v1/league/${leagueID}/losers_bracket`, { compress: true })
  ];
  const playoffsStart = leagueData2.settings.playoff_week_start;
  for (let i = playoffsStart; i < 19; i++) {
    bracketsAndMatchupFetches.push(fetch(`https://api.sleeper.app/v1/league/${leagueID}/matchups/${i}`, { compress: true }));
  }
  const bracketsAndMatchupResps = await waitForAll(...bracketsAndMatchupFetches).catch((err) => {
    console.error(err);
  });
  const bracketsAndMatchupJson = [];
  for (const bracketsAndMatchupResp of bracketsAndMatchupResps) {
    bracketsAndMatchupJson.push(bracketsAndMatchupResp.json());
  }
  const playoffMatchups = await waitForAll(...bracketsAndMatchupJson).catch((err) => {
    console.error(err);
  });
  const winnersData = playoffMatchups.shift();
  const losersData = playoffMatchups.shift();
  const playoffRounds = winnersData[winnersData.length - 1].r;
  const loserRounds = losersData[losersData.length - 1].r;
  const champs = evaluateBracket(winnersData, playoffRounds, playoffMatchups, rosters, users2);
  let losers = evaluateBracket(losersData, loserRounds, playoffMatchups, rosters, users2);
  const finalBrackets = {
    numRosters,
    playoffsStart,
    playoffRounds,
    loserRounds,
    champs,
    losers
  };
  brackets.update(() => finalBrackets);
  return finalBrackets;
};
var evaluateBracket = (contestants, rounds, playoffMatchups, rosters, users2) => {
  let bracket = [];
  let consolations = [];
  let consolationMs = [];
  let fromWs = [];
  for (let i = 1; i <= rounds; i++) {
    const playoffBrackets = contestants.filter((m) => m.r == i);
    const roundMatchups = [];
    const consolationMatchups = [];
    let first = true;
    const localConsolationMs = [];
    let localFromWs = [];
    for (const playoffBracket of playoffBrackets) {
      if (!playoffBracket.t1_from && playoffBracket.t2_from) {
        let byeMatchup = processPlayoffMatchup(playoffBracket, playoffMatchups[i - 2], rosters, users2, consolationMs, fromWs);
        byeMatchup.bye = true;
        byeMatchup[0].m = null;
        byeMatchup[1].m = null;
        byeMatchup[0].r--;
        byeMatchup[1].r--;
        byeMatchup[1].manager = null;
        if (first) {
          bracket[i - 2].unshift(byeMatchup);
          first = false;
        } else {
          bracket[i - 2].push(byeMatchup);
        }
      }
      const roundMatchup = processPlayoffMatchup(playoffBracket, playoffMatchups[i - 1], rosters, users2, consolationMs, fromWs);
      if (roundMatchup[0].winners) {
        localFromWs.push(roundMatchup[0].m);
      }
      if (roundMatchup[0].consolation) {
        localConsolationMs.push(roundMatchup[0].m);
        consolationMatchups.push(roundMatchup);
      } else {
        roundMatchups.push(roundMatchup);
      }
    }
    bracket.push(roundMatchups);
    for (const consolation of consolations) {
      for (const consolationMatchup of consolationMatchups) {
        if (consolationMatchup[0].winners && consolation[i - 2] && consolationMatchup[0].t1From == consolation[i - 2][0][0].m) {
          consolation[i - 1] = [consolationMatchup];
        }
      }
    }
    const notFromWinners = consolationMatchups.filter((m) => !m[0].fromWinners && !m[0].winners);
    const fromWinners = consolationMatchups.filter((m) => m[0].fromWinners && !m[0].winners);
    if (notFromWinners.length)
      consolations.unshift(newConsolation(notFromWinners, rounds, i));
    if (fromWinners.length)
      consolations.push(newConsolation(fromWinners, rounds, i));
    fromWs = localFromWs;
    consolationMs = localConsolationMs;
  }
  return { bracket, consolations };
};
var newConsolation = (consolationMatchups, rounds, i) => {
  const newConsolation2 = new Array(rounds).fill([]);
  newConsolation2[i - 1] = consolationMatchups;
  return newConsolation2;
};
var processPlayoffMatchup = (bracket, matchups, rosters, users2, consolationMs, fromWs) => {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;
  const matchup = [];
  const m = bracket.m;
  const r = bracket.r;
  const t1From = ((_a = bracket.t1_from) == null ? void 0 : _a.w) ? (_b = bracket.t1_from) == null ? void 0 : _b.w : (_c = bracket.t1_from) == null ? void 0 : _c.l;
  const t2From = ((_d = bracket.t2_from) == null ? void 0 : _d.w) ? (_e = bracket.t2_from) == null ? void 0 : _e.w : (_f = bracket.t2_from) == null ? void 0 : _f.l;
  const winners = ((_g = bracket.t1_from) == null ? void 0 : _g.w) && ((_h = bracket.t2_from) == null ? void 0 : _h.w) ? true : false;
  const fromWinners = fromWs.indexOf(t2From || -999) > -1 ? true : false;
  let consolation = false;
  if (((_i = bracket.t1_from) == null ? void 0 : _i.l) && ((_j = bracket.t2_from) == null ? void 0 : _j.l) || consolationMs.indexOf(t1From) > -1 || consolationMs.indexOf(t2From) > -1) {
    consolation = true;
  }
  const t1 = bracket.t1;
  if (t1) {
    const t1user = users2[rosters[t1 - 1].owner_id];
    const t1Matchup = matchups.filter((m2) => m2.roster_id == t1)[0];
    if (t1user) {
      matchup.push({
        manager: {
          name: t1user.metadata.team_name ? t1user.metadata.team_name : t1user.display_name,
          avatar: `https://sleepercdn.com/avatars/thumbs/${t1user.avatar}`
        },
        starters: t1Matchup == null ? void 0 : t1Matchup.starters,
        points: t1Matchup == null ? void 0 : t1Matchup.starters_points,
        t1From,
        m,
        r,
        winners,
        fromWinners,
        consolation
      });
    } else {
      matchup.push({
        manager: {
          name: "Unknown Manager",
          avatar: `https://sleepercdn.com/images/v2/icons/player_default.webp`
        },
        starters: t1Matchup == null ? void 0 : t1Matchup.starters,
        points: t1Matchup == null ? void 0 : t1Matchup.starters_points,
        t1From,
        m,
        r,
        winners,
        fromWinners,
        consolation
      });
    }
  } else {
    matchup.push({
      manager: null,
      consolation,
      t1From,
      m,
      r,
      winners,
      fromWinners
    });
  }
  const t2 = bracket.t2;
  if (t2) {
    const t2user = users2[rosters[t2 - 1].owner_id];
    const t2Matchup = matchups.filter((m2) => m2.roster_id == t2)[0];
    if (t2user) {
      matchup.push({
        manager: {
          name: t2user.metadata.team_name ? t2user.metadata.team_name : t2user.display_name,
          avatar: `https://sleepercdn.com/avatars/thumbs/${t2user.avatar}`
        },
        starters: t2Matchup == null ? void 0 : t2Matchup.starters,
        points: t2Matchup == null ? void 0 : t2Matchup.starters_points,
        t2From,
        m,
        r,
        winners,
        fromWinners,
        consolation
      });
    } else {
      matchup.push({
        manager: {
          name: "Unknown Manager",
          avatar: `https://sleepercdn.com/images/v2/icons/player_default.webp`
        },
        starters: t2Matchup == null ? void 0 : t2Matchup.starters,
        points: t2Matchup == null ? void 0 : t2Matchup.starters_points,
        t2From,
        m,
        r,
        winners,
        fromWinners,
        consolation
      });
    }
  } else {
    matchup.push({
      manager: null,
      consolation,
      t2From,
      winners,
      fromWinners,
      r,
      m
    });
  }
  return matchup;
};
var getLeagueStandings = async () => {
  if (get_store_value(standingsStore).matchupWeeks) {
    return get_store_value(standingsStore);
  }
  const [nflState2, leagueData2, rosters] = await waitForAll(getNflState(), getLeagueData(), getLeagueRosters()).catch((err) => {
    console.error(err);
  });
  const yearData = leagueData2.season;
  const regularSeasonLength = leagueData2.settings.playoff_week_start - 1;
  if (leagueData2.status != "in_season" && leagueData2.status != "complete") {
    return null;
  }
  let week = 0;
  if (nflState2.season_type == "regular") {
    week = nflState2.display_week > regularSeasonLength ? regularSeasonLength : nflState2.display_week;
  } else if (nflState2.season_type == "post") {
    week = regularSeasonLength;
  }
  if (week < 2) {
    return null;
  }
  const matchupsPromises = [];
  for (let i = week - 1; i > 0; i--) {
    matchupsPromises.push(fetch(`https://api.sleeper.app/v1/league/${leagueID}/matchups/${i}`, { compress: true }));
  }
  const matchupsRes = await waitForAll(...matchupsPromises);
  const matchupsJsonPromises = [];
  for (const matchupRes of matchupsRes) {
    const data2 = matchupRes.json();
    matchupsJsonPromises.push(data2);
    if (!matchupRes.ok) {
      throw new Error(data2);
    }
  }
  const matchupsData = await waitForAll(...matchupsJsonPromises).catch((err) => {
    console.error(err);
  }).catch((err) => {
    console.error(err);
  });
  let standings = {};
  for (const matchup of matchupsData) {
    standings = processStandings(matchup, standings, rosters.rosters);
  }
  const response = {
    standingsInfo: standings,
    rostersData: rosters.rosters,
    yearData
  };
  standingsStore.update(() => response);
  return response;
};
var processStandings = (matchup, standingsData, rosters) => {
  const matchups = {};
  for (const match2 of matchup) {
    if (!matchups[match2.matchup_id]) {
      matchups[match2.matchup_id] = [];
    }
    const rosterID = match2.roster_id;
    if (!standingsData[rosterID]) {
      standingsData[rosterID] = {
        rosterID,
        wins: 0,
        losses: 0,
        ties: 0,
        divisionWins: rosters[rosterID - 1].settings.division ? 0 : null,
        divisionLosses: rosters[rosterID - 1].settings.division ? 0 : null,
        divisionTies: rosters[rosterID - 1].settings.division ? 0 : null
      };
    }
    matchups[match2.matchup_id].push({
      rosterID,
      division: rosters[rosterID - 1].settings.division,
      points: match2.points
    });
  }
  for (const matchupKey in matchups) {
    const teamA = matchups[matchupKey][0];
    const teamB = matchups[matchupKey][1];
    const divisionMatchup = teamA.division && teamB.division && teamA.division == teamB.division;
    if (teamA.points > teamB.points) {
      standingsData[teamA.rosterID].wins++;
      standingsData[teamB.rosterID].losses++;
      if (divisionMatchup) {
        standingsData[teamA.rosterID].divisionWins++;
        standingsData[teamB.rosterID].divisionLosses++;
      }
      continue;
    } else if (teamB.points > teamA.points) {
      standingsData[teamB.rosterID].wins++;
      standingsData[teamA.rosterID].losses++;
      if (divisionMatchup) {
        standingsData[teamB.rosterID].divisionWins++;
        standingsData[teamA.rosterID].divisionLosses++;
      }
      continue;
    }
    standingsData[teamA.rosterID].ties++;
    standingsData[teamB.rosterID].ties++;
    if (divisionMatchup) {
      standingsData[teamA.rosterID].divisionTies++;
      standingsData[teamB.rosterID].divisionTies++;
    }
  }
  return standingsData;
};
var FF_BALLERS = "https://thefantasyfootballers.libsyn.com/fantasyfootball";
var FTN_NEWS = "https://www.ftnfantasy.com/content/news?type=news&sport=nfl&limit=30";
var DYNASTY_LEAGUE = "https://dynastyleaguefootball.com/feed/";
var DYNASTY_NERDS = "https://www.dynastynerds.com/feed/";
async function get$5() {
  const articles = [
    getXMLArticles(FF_BALLERS, processFF),
    getJSONArticles(FTN_NEWS, processFTN)
  ];
  {
    articles.push(getXMLArticles(DYNASTY_LEAGUE, processDynastyLeague));
    getXMLArticles(DYNASTY_NERDS, processDynastyNerds);
  }
  const responses = await waitForAll(...articles).catch((err) => {
    console.error(err);
  });
  let finalArticles = [];
  for (const response of responses) {
    finalArticles = [...finalArticles, ...response];
  }
  return {
    status: 200,
    body: JSON.stringify(finalArticles)
  };
}
var getXMLArticles = async (url, callback) => {
  const res = await fetch(url, { compress: true }).catch((err) => {
    console.error(err);
  });
  const text = await res.text().catch((err) => {
    console.error(err);
  });
  let jsonObj;
  if (import_fast_xml_parser.default.validate(text) === true) {
    jsonObj = import_fast_xml_parser.default.parse(text);
  }
  return callback(jsonObj.rss.channel.item);
};
var getJSONArticles = async (feed, callback) => {
  const res = await fetch(feed, { compress: true }).catch((err) => {
    console.error(err);
  });
  const data2 = await res.json().catch((err) => {
    console.error(err);
  });
  if (res.ok) {
    return callback(data2);
  } else {
    throw new Error(data2);
  }
};
var processFF = (articles) => {
  let finalArticles = [];
  for (const article of articles.slice(0, 5)) {
    const ts = Date.parse(article.pubDate);
    const d2 = new Date(ts);
    const date = stringDate(d2);
    const icon = "newsIcons/ffballers.jpeg";
    finalArticles.push({
      title: article.title,
      article: article.description,
      link: article.link,
      author: `FTN Fantasy`,
      ts,
      date,
      icon
    });
  }
  return finalArticles;
};
var processFTN = (rawArticles) => {
  let finalArticles = [];
  const items = rawArticles.items;
  for (const article of items) {
    if (article.priority > 3)
      continue;
    const ts = Date.parse(article.datetime);
    const d2 = new Date(ts);
    const date = stringDate(d2);
    const icon = "newsIcons/ftn.png";
    finalArticles.push({
      title: article.short_text,
      article: article.analysis[0].analysis,
      link: `https://www.ftnfantasy.com/nfl${article.link}`,
      author: `FTN Fantasy`,
      ts,
      date,
      icon
    });
  }
  return finalArticles;
};
var processDynastyLeague = (articles) => {
  let finalArticles = [];
  for (const article of articles) {
    const ts = Date.parse(article.pubDate);
    const d2 = new Date(ts);
    const date = stringDate(d2);
    const icon = "newsIcons/dynastyLeague.png";
    finalArticles.push({
      title: article.title,
      article: article.description,
      link: article.link,
      author: `Dynasty League Football`,
      ts,
      date,
      icon
    });
  }
  return finalArticles;
};
var processDynastyNerds = (articles) => {
  let finalArticles = [];
  for (const article of articles) {
    const ts = Date.parse(article.pubDate);
    const d2 = new Date(ts);
    const date = stringDate(d2);
    const icon = "newsIcons/dynastyNerds.jpeg";
    finalArticles.push({
      title: article.title,
      article: article.description,
      link: article.link,
      author: `Dynasty Nerds`,
      ts,
      date,
      icon
    });
  }
  return finalArticles;
};
var stringDate = (d2) => {
  return `${d2.getMonth() + 1}/${d2.getDate()}/${d2.getFullYear()} ${d2.getHours()}:${(d2.getMinutes() < 10 ? "0" : "") + d2.getMinutes()}`;
};
var fetch_serverside_news = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  get: get$5
});
var version = "1.2.7";
async function get$4() {
  return {
    status: 200,
    body: JSON.stringify(version)
  };
}
var checkGlobalVersion = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  get: get$4
});
async function get$3() {
  const [nflStateRes, leagueDataRes, playoffsRes] = await waitForAll(fetch(`https://api.sleeper.app/v1/state/nfl`, { compress: true }), fetch(`https://api.sleeper.app/v1/league/${leagueID}`, { compress: true }), fetch(`https://api.sleeper.app/v1/league/${leagueID}/winners_bracket`, { compress: true }));
  const [nflState2, leagueData2, playoffs] = await waitForAll(nflStateRes.json(), leagueDataRes.json(), playoffsRes.json());
  let year = nflState2.league_season;
  const regularSeasonLength = leagueData2.settings.playoff_week_start - 1;
  const playoffLength = playoffs.pop().r;
  const fullSeasonLength = regularSeasonLength + playoffLength;
  const resPromises = [
    fetch(`https://api.sleeper.app/v1/players/nfl`, { compress: true })
  ];
  for (let week = 1; week <= fullSeasonLength + 3; week++) {
    resPromises.push(fetch(`https://api.sleeper.app/projections/nfl/${year}/${week}?season_type=regular&position[]=DB&position[]=DEF&position[]=DL&position[]=FLEX&position[]=IDP_FLEX&position[]=K&position[]=LB&position[]=QB&position[]=RB&position[]=REC_FLEX&position[]=SUPER_FLEX&position[]=TE&position[]=WR&position[]=WRRB_FLEX&order_by=ppr`, { compress: true }));
  }
  const responses = await waitForAll(...resPromises);
  const resJSONs = [];
  for (const res of responses) {
    if (!res.ok) {
      return {
        status: 500,
        body: "No luck"
      };
    }
    resJSONs.push(res.json());
  }
  const weeklyData = await waitForAll(...resJSONs);
  const playerData = weeklyData.shift();
  const scoringSettings = leagueData2.scoring_settings;
  const computedPlayers = computePlayers(playerData, weeklyData, scoringSettings);
  return {
    status: 200,
    body: JSON.stringify(computedPlayers)
  };
}
var computePlayers = (playerData, weeklyData, scoringSettings) => {
  const computedPlayers = {};
  for (const id in playerData) {
    const projPlayer = playerData[id];
    const player = {
      fn: projPlayer.first_name,
      ln: projPlayer.last_name,
      pos: projPlayer.position
    };
    if (projPlayer.team) {
      player.t = projPlayer.team;
      player.wi = {};
    }
    if (projPlayer.team && projPlayer.injury_status) {
      player.is = projPlayer.injury_status;
    }
    computedPlayers[id] = player;
  }
  for (let week = 1; week <= weeklyData.length; week++) {
    for (const player of weeklyData[week - 1]) {
      const id = player.player_id;
      if (!computedPlayers[id].wi)
        continue;
      computedPlayers[id].wi[week] = {
        p: calculateProjection(player.stats, scoringSettings),
        o: player.opponent
      };
    }
  }
  computedPlayers["OAK"] = computedPlayers["LV"];
  return computedPlayers;
};
var calculateProjection = (projectedStats, scoreSettings) => {
  let score = 0;
  for (const stat in projectedStats) {
    const multiplier = scoreSettings[stat] ? scoreSettings[stat] : 0;
    score += projectedStats[stat] * multiplier;
  }
  return round(score);
};
var fetch_players_info = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  get: get$3
});
var lang$1 = "en-US";
async function post(req) {
  var _a, _b, _c;
  const authorID = req.params.id;
  const { comment, postID } = JSON.parse(req.body);
  const users2 = await getLeagueUsers();
  const author = validateID(users2, authorID);
  if (!author) {
    return {
      status: 500,
      body: JSON.stringify("Invalid author")
    };
  }
  const POST_COMMENTS = `https://api.contentful.com/spaces/${{}.VITE_CONTENTFUL_SPACE}/environments/master/entries/${makeid(postID, 10)}`;
  let fields = {
    "blogID": {},
    "comment": {},
    "author": {}
  };
  fields.blogID[lang$1] = postID;
  fields.comment[lang$1] = comment;
  fields.author[lang$1] = author;
  const res = await fetch(POST_COMMENTS, {
    method: "PUT",
    headers: new Headers({
      "Authorization": `Bearer ${{}.VITE_CONTENTFUL_ACCESS_TOKEN}`,
      "Content-Type": "application/vnd.contentful.management.v1+json",
      "X-Contentful-Content-Type": "blog_comment"
    }),
    body: JSON.stringify({
      fields
    })
  });
  const newComment = await res.json();
  if (!res.ok) {
    console.error(newComment);
    console.error((_a = newComment == null ? void 0 : newComment.details) == null ? void 0 : _a.errors);
    return {
      status: 500,
      body: JSON.stringify("Problem adding comment")
    };
  }
  const commentID = (_b = newComment == null ? void 0 : newComment.sys) == null ? void 0 : _b.id;
  const version2 = (_c = newComment == null ? void 0 : newComment.sys) == null ? void 0 : _c.version;
  if (!commentID) {
    console.error(newComment);
    return {
      status: 500,
      body: JSON.stringify("Problem adding comment")
    };
  }
  const PUBLISH_COMMENT = `https://api.contentful.com/spaces/${{}.VITE_CONTENTFUL_SPACE}/environments/master/entries/${commentID}/published`;
  const publishRes = await fetch(PUBLISH_COMMENT, {
    method: "PUT",
    headers: new Headers({
      "Authorization": `Bearer ${{}.VITE_CONTENTFUL_ACCESS_TOKEN}`,
      "X-Contentful-Version": version2
    })
  });
  const publishJson = await publishRes.json();
  if (!res.ok) {
    console.error(publishJson);
    return {
      status: 500,
      body: JSON.stringify("Problem publishing comment")
    };
  }
  return {
    status: 200,
    body: JSON.stringify(newComment)
  };
}
var makeid = (id, length) => {
  let result = "";
  const characters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
  const charactersLength = characters.length;
  for (let i = 0; i < length; i++) {
    result += characters.charAt(Math.floor(Math.random() * charactersLength));
  }
  return `${id}-${result}`;
};
var validateID = (users2, authorID) => {
  let user = null;
  for (const userKey of Object.keys(users2)) {
    if (users2[userKey].user_id == authorID) {
      user = users2[userKey];
      break;
    }
  }
  if (!user) {
    return false;
  }
  return user.display_name;
};
var _id_$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  post
});
async function get$2({ params }) {
  const blogID = params.id;
  const GET_COMMENTS = `https://api.contentful.com/spaces/${{}.VITE_CONTENTFUL_SPACE}/environments/master/entries?access_token=${{}.VITE_CONTENTFUL_ACCESS_TOKEN}&content_type=blog_comment&fields.blogID=${blogID}`;
  const res = await fetch(GET_COMMENTS, { compress: true }).catch((err) => {
    console.error(err);
  });
  if (!res.ok) {
    return {
      status: 500,
      body: "Problem retrieving blog posts"
    };
  }
  const data2 = await res.json().catch((err) => {
    console.error(err);
  });
  return {
    status: 200,
    body: JSON.stringify(data2)
  };
}
var _id_ = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  get: get$2
});
async function get$1() {
  const res = await fetch("https://league-page.nmelhado.com/api/checkGlobalVersion", { compress: true });
  let needsUpdate = false;
  if (res.ok) {
    const globalVersion = await res.json();
    console.log(`VERSION CHECK: global version: ${globalVersion}, local version: ${version}`);
    needsUpdate = globalVersion != version;
  }
  return {
    status: 200,
    body: JSON.stringify(needsUpdate)
  };
}
var checkVersion = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  get: get$1
});
var GET_POSTS = `https://api.contentful.com/spaces/${{}.VITE_CONTENTFUL_SPACE}/environments/master/entries?access_token=${{}.VITE_CONTENTFUL_ACCESS_TOKEN}&content_type=blog_post`;
async function get() {
  const res = await fetch(GET_POSTS, { compress: true }).catch((err) => {
    console.error(err);
  });
  if (!res.ok) {
    return {
      status: 500,
      body: "Problem retrieving blog posts"
    };
  }
  const data2 = await res.json().catch((err) => {
    console.error(err);
  });
  return {
    status: 200,
    body: JSON.stringify(data2)
  };
}
var getBlogPosts = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  get
});
var tabs = [
  {
    icon: "home",
    label: "Home",
    dest: "/"
  },
  {
    icon: "local_fire_department",
    label: "Matchups",
    dest: "/matchups"
  },
  {
    icon: "swap_horiz",
    label: "Trades & Waivers",
    dest: "/transactions"
  },
  {
    icon: "article",
    label: "Blog",
    dest: "/blog"
  },
  {
    icon: "view_comfy",
    label: "League Info",
    nest: true,
    children: [
      {
        icon: "storage",
        label: "Rosters",
        dest: "/rosters"
      },
      {
        icon: "groups",
        label: "Managers",
        dest: "/managers"
      },
      {
        icon: "leaderboard",
        label: "Standings",
        dest: "/standings"
      },
      {
        icon: "view_comfy",
        label: "Drafts",
        dest: "/drafts"
      },
      {
        icon: "emoji_events",
        label: "Trophy Room",
        dest: "/awards"
      },
      {
        icon: "military_tech",
        label: "Records",
        dest: "/records"
      },
      {
        icon: "history_edu",
        label: "Constitution",
        dest: "/constitution"
      },
      {
        icon: "sports_football",
        label: "Go to Sleeper",
        dest: `https://sleeper.app/leagues/${leagueID}`
      }
    ]
  },
  {
    icon: "lightbulb",
    label: "Resources",
    dest: "/resources"
  }
];
var extendStatics = function(d2, b) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b2) {
    d3.__proto__ = b2;
  } || function(d3, b2) {
    for (var p in b2)
      if (Object.prototype.hasOwnProperty.call(b2, p))
        d3[p] = b2[p];
  };
  return extendStatics(d2, b);
};
function __extends(d2, b) {
  if (typeof b !== "function" && b !== null)
    throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d2, b);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign = function() {
  __assign = Object.assign || function __assign2(t) {
    for (var s2, i = 1, n = arguments.length; i < n; i++) {
      s2 = arguments[i];
      for (var p in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p))
          t[p] = s2[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
var MDCFoundation = function() {
  function MDCFoundation2(adapter) {
    if (adapter === void 0) {
      adapter = {};
    }
    this.adapter = adapter;
  }
  Object.defineProperty(MDCFoundation2, "cssClasses", {
    get: function() {
      return {};
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCFoundation2, "strings", {
    get: function() {
      return {};
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCFoundation2, "numbers", {
    get: function() {
      return {};
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCFoundation2, "defaultAdapter", {
    get: function() {
      return {};
    },
    enumerable: false,
    configurable: true
  });
  MDCFoundation2.prototype.init = function() {
  };
  MDCFoundation2.prototype.destroy = function() {
  };
  return MDCFoundation2;
}();
function closest(element, selector) {
  if (element.closest) {
    return element.closest(selector);
  }
  var el = element;
  while (el) {
    if (matches$1(el, selector)) {
      return el;
    }
    el = el.parentElement;
  }
  return null;
}
function matches$1(element, selector) {
  var nativeMatches = element.matches || element.webkitMatchesSelector || element.msMatchesSelector;
  return nativeMatches.call(element, selector);
}
function estimateScrollWidth(element) {
  var htmlEl = element;
  if (htmlEl.offsetParent !== null) {
    return htmlEl.scrollWidth;
  }
  var clone2 = htmlEl.cloneNode(true);
  clone2.style.setProperty("position", "absolute");
  clone2.style.setProperty("transform", "translate(-9999px, -9999px)");
  document.documentElement.appendChild(clone2);
  var scrollWidth = clone2.scrollWidth;
  document.documentElement.removeChild(clone2);
  return scrollWidth;
}
var ponyfill = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  closest,
  matches: matches$1,
  estimateScrollWidth
});
var cssClasses$3 = {
  ANIMATE: "mdc-drawer--animate",
  CLOSING: "mdc-drawer--closing",
  DISMISSIBLE: "mdc-drawer--dismissible",
  MODAL: "mdc-drawer--modal",
  OPEN: "mdc-drawer--open",
  OPENING: "mdc-drawer--opening",
  ROOT: "mdc-drawer"
};
var strings$3 = {
  APP_CONTENT_SELECTOR: ".mdc-drawer-app-content",
  CLOSE_EVENT: "MDCDrawer:closed",
  OPEN_EVENT: "MDCDrawer:opened",
  SCRIM_SELECTOR: ".mdc-drawer-scrim",
  LIST_SELECTOR: ".mdc-list,.mdc-deprecated-list",
  LIST_ITEM_ACTIVATED_SELECTOR: ".mdc-list-item--activated,.mdc-deprecated-list-item--activated"
};
var MDCDismissibleDrawerFoundation = function(_super) {
  __extends(MDCDismissibleDrawerFoundation2, _super);
  function MDCDismissibleDrawerFoundation2(adapter) {
    var _this = _super.call(this, __assign(__assign({}, MDCDismissibleDrawerFoundation2.defaultAdapter), adapter)) || this;
    _this.animationFrame_ = 0;
    _this.animationTimer_ = 0;
    return _this;
  }
  Object.defineProperty(MDCDismissibleDrawerFoundation2, "strings", {
    get: function() {
      return strings$3;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCDismissibleDrawerFoundation2, "cssClasses", {
    get: function() {
      return cssClasses$3;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCDismissibleDrawerFoundation2, "defaultAdapter", {
    get: function() {
      return {
        addClass: function() {
          return void 0;
        },
        removeClass: function() {
          return void 0;
        },
        hasClass: function() {
          return false;
        },
        elementHasClass: function() {
          return false;
        },
        notifyClose: function() {
          return void 0;
        },
        notifyOpen: function() {
          return void 0;
        },
        saveFocus: function() {
          return void 0;
        },
        restoreFocus: function() {
          return void 0;
        },
        focusActiveNavigationItem: function() {
          return void 0;
        },
        trapFocus: function() {
          return void 0;
        },
        releaseFocus: function() {
          return void 0;
        }
      };
    },
    enumerable: false,
    configurable: true
  });
  MDCDismissibleDrawerFoundation2.prototype.destroy = function() {
    if (this.animationFrame_) {
      cancelAnimationFrame(this.animationFrame_);
    }
    if (this.animationTimer_) {
      clearTimeout(this.animationTimer_);
    }
  };
  MDCDismissibleDrawerFoundation2.prototype.open = function() {
    var _this = this;
    if (this.isOpen() || this.isOpening() || this.isClosing()) {
      return;
    }
    this.adapter.addClass(cssClasses$3.OPEN);
    this.adapter.addClass(cssClasses$3.ANIMATE);
    this.runNextAnimationFrame_(function() {
      _this.adapter.addClass(cssClasses$3.OPENING);
    });
    this.adapter.saveFocus();
  };
  MDCDismissibleDrawerFoundation2.prototype.close = function() {
    if (!this.isOpen() || this.isOpening() || this.isClosing()) {
      return;
    }
    this.adapter.addClass(cssClasses$3.CLOSING);
  };
  MDCDismissibleDrawerFoundation2.prototype.isOpen = function() {
    return this.adapter.hasClass(cssClasses$3.OPEN);
  };
  MDCDismissibleDrawerFoundation2.prototype.isOpening = function() {
    return this.adapter.hasClass(cssClasses$3.OPENING) || this.adapter.hasClass(cssClasses$3.ANIMATE);
  };
  MDCDismissibleDrawerFoundation2.prototype.isClosing = function() {
    return this.adapter.hasClass(cssClasses$3.CLOSING);
  };
  MDCDismissibleDrawerFoundation2.prototype.handleKeydown = function(evt) {
    var keyCode = evt.keyCode, key = evt.key;
    var isEscape = key === "Escape" || keyCode === 27;
    if (isEscape) {
      this.close();
    }
  };
  MDCDismissibleDrawerFoundation2.prototype.handleTransitionEnd = function(evt) {
    var OPENING = cssClasses$3.OPENING, CLOSING = cssClasses$3.CLOSING, OPEN = cssClasses$3.OPEN, ANIMATE = cssClasses$3.ANIMATE, ROOT = cssClasses$3.ROOT;
    var isRootElement = this.isElement_(evt.target) && this.adapter.elementHasClass(evt.target, ROOT);
    if (!isRootElement) {
      return;
    }
    if (this.isClosing()) {
      this.adapter.removeClass(OPEN);
      this.closed_();
      this.adapter.restoreFocus();
      this.adapter.notifyClose();
    } else {
      this.adapter.focusActiveNavigationItem();
      this.opened_();
      this.adapter.notifyOpen();
    }
    this.adapter.removeClass(ANIMATE);
    this.adapter.removeClass(OPENING);
    this.adapter.removeClass(CLOSING);
  };
  MDCDismissibleDrawerFoundation2.prototype.opened_ = function() {
  };
  MDCDismissibleDrawerFoundation2.prototype.closed_ = function() {
  };
  MDCDismissibleDrawerFoundation2.prototype.runNextAnimationFrame_ = function(callback) {
    var _this = this;
    cancelAnimationFrame(this.animationFrame_);
    this.animationFrame_ = requestAnimationFrame(function() {
      _this.animationFrame_ = 0;
      clearTimeout(_this.animationTimer_);
      _this.animationTimer_ = setTimeout(callback, 0);
    });
  };
  MDCDismissibleDrawerFoundation2.prototype.isElement_ = function(element) {
    return Boolean(element.classList);
  };
  return MDCDismissibleDrawerFoundation2;
}(MDCFoundation);
var MDCModalDrawerFoundation = function(_super) {
  __extends(MDCModalDrawerFoundation2, _super);
  function MDCModalDrawerFoundation2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  MDCModalDrawerFoundation2.prototype.handleScrimClick = function() {
    this.close();
  };
  MDCModalDrawerFoundation2.prototype.opened_ = function() {
    this.adapter.trapFocus();
  };
  MDCModalDrawerFoundation2.prototype.closed_ = function() {
    this.adapter.releaseFocus();
  };
  return MDCModalDrawerFoundation2;
}(MDCDismissibleDrawerFoundation);
function applyPassive$1(globalObj) {
  if (globalObj === void 0) {
    globalObj = window;
  }
  return supportsPassiveOption(globalObj) ? { passive: true } : false;
}
function supportsPassiveOption(globalObj) {
  if (globalObj === void 0) {
    globalObj = window;
  }
  var passiveSupported = false;
  try {
    var options2 = {
      get passive() {
        passiveSupported = true;
        return false;
      }
    };
    var handler = function() {
    };
    globalObj.document.addEventListener("test", handler, options2);
    globalObj.document.removeEventListener("test", handler, options2);
  } catch (err) {
    passiveSupported = false;
  }
  return passiveSupported;
}
var events = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  applyPassive: applyPassive$1
});
var oldModifierRegex = /^[a-z]+(?::(?:preventDefault|stopPropagation|passive|nonpassive|capture|once|self))+$/;
var newModifierRegex = /^[^$]+(?:\$(?:preventDefault|stopPropagation|passive|nonpassive|capture|once|self))+$/;
function forwardEventsBuilder(component) {
  let $on;
  let events2 = [];
  const componentOn = component.$on;
  component.$on = (fullEventType, callback) => {
    let eventType = fullEventType;
    let destructor = () => {
    };
    if ($on) {
      destructor = $on(eventType, callback);
    } else {
      events2.push([eventType, callback]);
    }
    const oldModifierMatch = eventType.match(oldModifierRegex);
    const newModifierMatch = eventType.match(newModifierRegex);
    const modifierMatch = oldModifierMatch || newModifierMatch;
    if (oldModifierMatch && console) {
      console.warn('Event modifiers in SMUI now use "$" instead of ":", so that all events can be bound with modifiers. Please update your event binding: ', eventType);
    }
    if (modifierMatch) {
      const parts = eventType.split(oldModifierMatch ? ":" : "$");
      eventType = parts[0];
    }
    const componentDestructor = componentOn.call(component, eventType, callback);
    return (...args) => {
      destructor();
      return componentDestructor(...args);
    };
  };
  function forward(e) {
    bubble(component, e);
  }
  return (node) => {
    const destructors = [];
    const forwardDestructors = {};
    $on = (fullEventType, callback) => {
      let eventType = fullEventType;
      let handler = callback;
      let options2 = false;
      const oldModifierMatch = eventType.match(oldModifierRegex);
      const newModifierMatch = eventType.match(newModifierRegex);
      const modifierMatch = oldModifierMatch || newModifierMatch;
      if (modifierMatch) {
        const parts = eventType.split(oldModifierMatch ? ":" : "$");
        eventType = parts[0];
        options2 = Object.fromEntries(parts.slice(1).map((mod) => [mod, true]));
        if (options2.nonpassive) {
          options2.passive = false;
          delete options2.nonpassive;
        }
        if (options2.preventDefault) {
          handler = prevent_default(handler);
          delete options2.preventDefault;
        }
        if (options2.stopPropagation) {
          handler = stop_propagation(handler);
          delete options2.stopPropagation;
        }
      }
      const off = listen(node, eventType, handler, options2);
      const destructor = () => {
        off();
        const idx = destructors.indexOf(destructor);
        if (idx > -1) {
          destructors.splice(idx, 1);
        }
      };
      destructors.push(destructor);
      if (!eventType in forwardDestructors) {
        forwardDestructors[eventType] = listen(node, eventType, forward);
      }
      return destructor;
    };
    for (let i = 0; i < events2.length; i++) {
      $on(events2[i][0], events2[i][1]);
    }
    return {
      destroy: () => {
        for (let i = 0; i < destructors.length; i++) {
          destructors[i]();
        }
        for (let entry of Object.entries(forwardDestructors)) {
          entry[1]();
        }
      }
    };
  };
}
function classMap(classObj) {
  return Object.entries(classObj).filter(([name, value]) => name !== "" && value).map(([name]) => name).join(" ");
}
var { Object: Object_1$6 } = globals;
var internals = {
  component: null,
  class: "",
  classMap: {},
  contexts: {},
  props: {}
};
var ClassAdder = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let $$restProps = compute_rest_props($$props, ["use", "class", "component", "getElement"]);
  let { use = [] } = $$props;
  let { class: className = "" } = $$props;
  let element;
  const smuiClass = internals.class;
  const smuiClassMap = {};
  const smuiClassUnsubscribes = [];
  const contexts = internals.contexts;
  const props = internals.props;
  let { component = internals.component } = $$props;
  Object.entries(internals.classMap).forEach(([name, context]) => {
    const store = getContext(context);
    if (store && "subscribe" in store) {
      smuiClassUnsubscribes.push(store.subscribe((value) => {
        smuiClassMap[name] = value;
      }));
    }
  });
  const forwardEvents = forwardEventsBuilder(get_current_component());
  for (let context in contexts) {
    if (contexts.hasOwnProperty(context)) {
      setContext(context, contexts[context]);
    }
  }
  onDestroy(() => {
    for (const unsubscribe of smuiClassUnsubscribes) {
      unsubscribe();
    }
  });
  function getElement() {
    return element.getElement();
  }
  if ($$props.use === void 0 && $$bindings.use && use !== void 0)
    $$bindings.use(use);
  if ($$props.class === void 0 && $$bindings.class && className !== void 0)
    $$bindings.class(className);
  if ($$props.component === void 0 && $$bindings.component && component !== void 0)
    $$bindings.component(component);
  if ($$props.getElement === void 0 && $$bindings.getElement && getElement !== void 0)
    $$bindings.getElement(getElement);
  let $$settled;
  let $$rendered;
  do {
    $$settled = true;
    $$rendered = `${validate_component(component || missing_component, "svelte:component").$$render($$result, Object_1$6.assign({ use: [forwardEvents, ...use] }, {
      class: classMap({
        [className]: true,
        [smuiClass]: true,
        ...smuiClassMap
      })
    }, props, $$restProps, { this: element }), {
      this: ($$value) => {
        element = $$value;
        $$settled = false;
      }
    }, {
      default: () => `${slots.default ? slots.default({}) : ``}`
    })}`;
  } while (!$$settled);
  return $$rendered;
});
var defaults = { ...internals };
function classAdderBuilder(props) {
  function Component(...args) {
    Object.assign(internals, defaults, props);
    return new ClassAdder(...args);
  }
  Component.prototype = ClassAdder;
  if (ClassAdder.$$render) {
    Component.$$render = (...args) => Object.assign(internals, defaults, props) && ClassAdder.$$render(...args);
  }
  if (ClassAdder.render) {
    Component.render = (...args) => Object.assign(internals, defaults, props) && ClassAdder.render(...args);
  }
  return Component;
}
function dispatch(element, eventType, detail = {}, eventInit = { bubbles: true }) {
  if (typeof Event !== "undefined" && element) {
    const event = new Event(eventType, eventInit);
    event.detail = detail;
    const el = "getElement" in element ? element.getElement() : element;
    el.dispatchEvent(event);
    return event;
  }
}
function exclude(obj, keys) {
  let names = Object.getOwnPropertyNames(obj);
  const newObj = {};
  for (let i = 0; i < names.length; i++) {
    const name = names[i];
    const cashIndex = name.indexOf("$");
    if (cashIndex !== -1 && keys.indexOf(name.substring(0, cashIndex + 1)) !== -1) {
      continue;
    }
    if (keys.indexOf(name) !== -1) {
      continue;
    }
    newObj[name] = obj[name];
  }
  return newObj;
}
function prefixFilter(obj, prefix) {
  let names = Object.getOwnPropertyNames(obj);
  const newObj = {};
  for (let i = 0; i < names.length; i++) {
    const name = names[i];
    if (name.substring(0, prefix.length) === prefix) {
      newObj[name.substring(prefix.length)] = obj[name];
    }
  }
  return newObj;
}
var Drawer = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let $$restProps = compute_rest_props($$props, ["use", "class", "variant", "open", "fixed", "setOpen", "isOpen", "getElement"]);
  forwardEventsBuilder(get_current_component());
  let { use = [] } = $$props;
  let { class: className = "" } = $$props;
  let { variant = null } = $$props;
  let { open = false } = $$props;
  let { fixed = true } = $$props;
  let element;
  let instance;
  let internalClasses = {};
  let previousFocus;
  let focusTrap;
  let scrim = false;
  setContext("SMUI:list:nav", true);
  setContext("SMUI:list:item:nav", true);
  setContext("SMUI:list:wrapFocus", true);
  let oldVariant = variant;
  onDestroy(() => {
    instance && instance.destroy();
    scrim && scrim.removeEventListener("SMUI:drawer:scrim:click", handleScrimClick);
  });
  function getInstance() {
    if (scrim) {
      scrim.removeEventListener("SMUI:drawer:scrim:click", handleScrimClick);
    }
    if (variant === "modal") {
      scrim = element.parentNode.querySelector(".mdc-drawer-scrim");
      if (scrim) {
        scrim.addEventListener("SMUI:drawer:scrim:click", handleScrimClick);
      }
    }
    const Foundation = {
      dismissible: MDCDismissibleDrawerFoundation,
      modal: MDCModalDrawerFoundation
    }[variant];
    return Foundation ? new Foundation({
      addClass,
      removeClass,
      hasClass,
      elementHasClass: (element2, className2) => element2.classList.contains(className2),
      saveFocus: () => previousFocus = document.activeElement,
      restoreFocus: () => {
        if (previousFocus && previousFocus.focus && element.contains(document.activeElement)) {
          previousFocus.focus();
        }
      },
      focusActiveNavigationItem: () => {
        const activeNavItemEl = element.querySelector(".mdc-list-item--activated,.mdc-deprecated-list-item--activated");
        if (activeNavItemEl) {
          activeNavItemEl.focus();
        }
      },
      notifyClose: () => {
        open = false;
        dispatch(element, "MDCDrawer:closed");
      },
      notifyOpen: () => {
        open = true;
        dispatch(element, "MDCDrawer:opened");
      },
      trapFocus: () => focusTrap.trapFocus(),
      releaseFocus: () => focusTrap.releaseFocus()
    }) : void 0;
  }
  function hasClass(className2) {
    return className2 in internalClasses ? internalClasses[className2] : getElement().classList.contains(className2);
  }
  function addClass(className2) {
    if (!internalClasses[className2]) {
      internalClasses[className2] = true;
    }
  }
  function removeClass(className2) {
    if (!(className2 in internalClasses) || internalClasses[className2]) {
      internalClasses[className2] = false;
    }
  }
  function handleScrimClick() {
    instance && instance.handleScrimClick();
  }
  function setOpen(value) {
    open = value;
  }
  function isOpen() {
    return open;
  }
  function getElement() {
    return element;
  }
  if ($$props.use === void 0 && $$bindings.use && use !== void 0)
    $$bindings.use(use);
  if ($$props.class === void 0 && $$bindings.class && className !== void 0)
    $$bindings.class(className);
  if ($$props.variant === void 0 && $$bindings.variant && variant !== void 0)
    $$bindings.variant(variant);
  if ($$props.open === void 0 && $$bindings.open && open !== void 0)
    $$bindings.open(open);
  if ($$props.fixed === void 0 && $$bindings.fixed && fixed !== void 0)
    $$bindings.fixed(fixed);
  if ($$props.setOpen === void 0 && $$bindings.setOpen && setOpen !== void 0)
    $$bindings.setOpen(setOpen);
  if ($$props.isOpen === void 0 && $$bindings.isOpen && isOpen !== void 0)
    $$bindings.isOpen(isOpen);
  if ($$props.getElement === void 0 && $$bindings.getElement && getElement !== void 0)
    $$bindings.getElement(getElement);
  {
    if (oldVariant !== variant) {
      oldVariant = variant;
      instance && instance.destroy();
      internalClasses = {};
      instance = getInstance();
      instance && instance.init();
    }
  }
  {
    if (instance && instance.isOpen() !== open) {
      if (open) {
        instance.open();
      } else {
        instance.close();
      }
    }
  }
  return `<aside${spread([
    {
      class: escape_attribute_value(classMap({
        [className]: true,
        "mdc-drawer": true,
        "mdc-drawer--dismissible": variant === "dismissible",
        "mdc-drawer--modal": variant === "modal",
        "smui-drawer__absolute": variant === "modal" && !fixed,
        ...internalClasses
      }))
    },
    escape_object($$restProps)
  ])}${add_attribute("this", element, 0)}>${slots.default ? slots.default({}) : ``}
</aside>`;
});
var Div = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let $$restProps = compute_rest_props($$props, ["use", "getElement"]);
  let { use = [] } = $$props;
  forwardEventsBuilder(get_current_component());
  let element = null;
  function getElement() {
    return element;
  }
  if ($$props.use === void 0 && $$bindings.use && use !== void 0)
    $$bindings.use(use);
  if ($$props.getElement === void 0 && $$bindings.getElement && getElement !== void 0)
    $$bindings.getElement(getElement);
  return `<div${spread([escape_object($$restProps)])}${add_attribute("this", element, 0)}>${slots.default ? slots.default({}) : ``}
</div>`;
});
classAdderBuilder({
  class: "mdc-drawer-app-content",
  component: Div
});
var Content$1 = classAdderBuilder({
  class: "mdc-drawer__content",
  component: Div
});
var Header = classAdderBuilder({
  class: "mdc-drawer__header",
  component: Div
});
var H1 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let $$restProps = compute_rest_props($$props, ["use", "getElement"]);
  let { use = [] } = $$props;
  forwardEventsBuilder(get_current_component());
  let element = null;
  function getElement() {
    return element;
  }
  if ($$props.use === void 0 && $$bindings.use && use !== void 0)
    $$bindings.use(use);
  if ($$props.getElement === void 0 && $$bindings.getElement && getElement !== void 0)
    $$bindings.getElement(getElement);
  return `<h1${spread([escape_object($$restProps)])}${add_attribute("this", element, 0)}>${slots.default ? slots.default({}) : ``}
</h1>`;
});
var Title$1 = classAdderBuilder({
  class: "mdc-drawer__title",
  component: H1
});
var H2 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let $$restProps = compute_rest_props($$props, ["use", "getElement"]);
  let { use = [] } = $$props;
  forwardEventsBuilder(get_current_component());
  let element = null;
  function getElement() {
    return element;
  }
  if ($$props.use === void 0 && $$bindings.use && use !== void 0)
    $$bindings.use(use);
  if ($$props.getElement === void 0 && $$bindings.getElement && getElement !== void 0)
    $$bindings.getElement(getElement);
  return `<h2${spread([escape_object($$restProps)])}${add_attribute("this", element, 0)}>${slots.default ? slots.default({}) : ``}
</h2>`;
});
classAdderBuilder({
  class: "mdc-drawer__subtitle",
  component: H2
});
var cssClasses$2 = {
  BG_FOCUSED: "mdc-ripple-upgraded--background-focused",
  FG_ACTIVATION: "mdc-ripple-upgraded--foreground-activation",
  FG_DEACTIVATION: "mdc-ripple-upgraded--foreground-deactivation",
  ROOT: "mdc-ripple-upgraded",
  UNBOUNDED: "mdc-ripple-upgraded--unbounded"
};
var strings$2 = {
  VAR_FG_SCALE: "--mdc-ripple-fg-scale",
  VAR_FG_SIZE: "--mdc-ripple-fg-size",
  VAR_FG_TRANSLATE_END: "--mdc-ripple-fg-translate-end",
  VAR_FG_TRANSLATE_START: "--mdc-ripple-fg-translate-start",
  VAR_LEFT: "--mdc-ripple-left",
  VAR_TOP: "--mdc-ripple-top"
};
var numbers = {
  DEACTIVATION_TIMEOUT_MS: 225,
  FG_DEACTIVATION_MS: 150,
  INITIAL_ORIGIN_SCALE: 0.6,
  PADDING: 10,
  TAP_DELAY_MS: 300
};
var supportsCssVariables_;
function supportsCssVariables(windowObj, forceRefresh) {
  if (forceRefresh === void 0) {
    forceRefresh = false;
  }
  var CSS = windowObj.CSS;
  var supportsCssVars = supportsCssVariables_;
  if (typeof supportsCssVariables_ === "boolean" && !forceRefresh) {
    return supportsCssVariables_;
  }
  var supportsFunctionPresent = CSS && typeof CSS.supports === "function";
  if (!supportsFunctionPresent) {
    return false;
  }
  var explicitlySupportsCssVars = CSS.supports("--css-vars", "yes");
  var weAreFeatureDetectingSafari10plus = CSS.supports("(--css-vars: yes)") && CSS.supports("color", "#00000000");
  supportsCssVars = explicitlySupportsCssVars || weAreFeatureDetectingSafari10plus;
  if (!forceRefresh) {
    supportsCssVariables_ = supportsCssVars;
  }
  return supportsCssVars;
}
function getNormalizedEventCoords(evt, pageOffset, clientRect) {
  if (!evt) {
    return { x: 0, y: 0 };
  }
  var x = pageOffset.x, y = pageOffset.y;
  var documentX = x + clientRect.left;
  var documentY = y + clientRect.top;
  var normalizedX;
  var normalizedY;
  if (evt.type === "touchstart") {
    var touchEvent = evt;
    normalizedX = touchEvent.changedTouches[0].pageX - documentX;
    normalizedY = touchEvent.changedTouches[0].pageY - documentY;
  } else {
    var mouseEvent = evt;
    normalizedX = mouseEvent.pageX - documentX;
    normalizedY = mouseEvent.pageY - documentY;
  }
  return { x: normalizedX, y: normalizedY };
}
var ACTIVATION_EVENT_TYPES = [
  "touchstart",
  "pointerdown",
  "mousedown",
  "keydown"
];
var POINTER_DEACTIVATION_EVENT_TYPES = [
  "touchend",
  "pointerup",
  "mouseup",
  "contextmenu"
];
var activatedTargets = [];
var MDCRippleFoundation = function(_super) {
  __extends(MDCRippleFoundation2, _super);
  function MDCRippleFoundation2(adapter) {
    var _this = _super.call(this, __assign(__assign({}, MDCRippleFoundation2.defaultAdapter), adapter)) || this;
    _this.activationAnimationHasEnded_ = false;
    _this.activationTimer_ = 0;
    _this.fgDeactivationRemovalTimer_ = 0;
    _this.fgScale_ = "0";
    _this.frame_ = { width: 0, height: 0 };
    _this.initialSize_ = 0;
    _this.layoutFrame_ = 0;
    _this.maxRadius_ = 0;
    _this.unboundedCoords_ = { left: 0, top: 0 };
    _this.activationState_ = _this.defaultActivationState_();
    _this.activationTimerCallback_ = function() {
      _this.activationAnimationHasEnded_ = true;
      _this.runDeactivationUXLogicIfReady_();
    };
    _this.activateHandler_ = function(e) {
      return _this.activate_(e);
    };
    _this.deactivateHandler_ = function() {
      return _this.deactivate_();
    };
    _this.focusHandler_ = function() {
      return _this.handleFocus();
    };
    _this.blurHandler_ = function() {
      return _this.handleBlur();
    };
    _this.resizeHandler_ = function() {
      return _this.layout();
    };
    return _this;
  }
  Object.defineProperty(MDCRippleFoundation2, "cssClasses", {
    get: function() {
      return cssClasses$2;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCRippleFoundation2, "strings", {
    get: function() {
      return strings$2;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCRippleFoundation2, "numbers", {
    get: function() {
      return numbers;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCRippleFoundation2, "defaultAdapter", {
    get: function() {
      return {
        addClass: function() {
          return void 0;
        },
        browserSupportsCssVars: function() {
          return true;
        },
        computeBoundingRect: function() {
          return { top: 0, right: 0, bottom: 0, left: 0, width: 0, height: 0 };
        },
        containsEventTarget: function() {
          return true;
        },
        deregisterDocumentInteractionHandler: function() {
          return void 0;
        },
        deregisterInteractionHandler: function() {
          return void 0;
        },
        deregisterResizeHandler: function() {
          return void 0;
        },
        getWindowPageOffset: function() {
          return { x: 0, y: 0 };
        },
        isSurfaceActive: function() {
          return true;
        },
        isSurfaceDisabled: function() {
          return true;
        },
        isUnbounded: function() {
          return true;
        },
        registerDocumentInteractionHandler: function() {
          return void 0;
        },
        registerInteractionHandler: function() {
          return void 0;
        },
        registerResizeHandler: function() {
          return void 0;
        },
        removeClass: function() {
          return void 0;
        },
        updateCssVariable: function() {
          return void 0;
        }
      };
    },
    enumerable: false,
    configurable: true
  });
  MDCRippleFoundation2.prototype.init = function() {
    var _this = this;
    var supportsPressRipple = this.supportsPressRipple_();
    this.registerRootHandlers_(supportsPressRipple);
    if (supportsPressRipple) {
      var _a = MDCRippleFoundation2.cssClasses, ROOT_1 = _a.ROOT, UNBOUNDED_1 = _a.UNBOUNDED;
      requestAnimationFrame(function() {
        _this.adapter.addClass(ROOT_1);
        if (_this.adapter.isUnbounded()) {
          _this.adapter.addClass(UNBOUNDED_1);
          _this.layoutInternal_();
        }
      });
    }
  };
  MDCRippleFoundation2.prototype.destroy = function() {
    var _this = this;
    if (this.supportsPressRipple_()) {
      if (this.activationTimer_) {
        clearTimeout(this.activationTimer_);
        this.activationTimer_ = 0;
        this.adapter.removeClass(MDCRippleFoundation2.cssClasses.FG_ACTIVATION);
      }
      if (this.fgDeactivationRemovalTimer_) {
        clearTimeout(this.fgDeactivationRemovalTimer_);
        this.fgDeactivationRemovalTimer_ = 0;
        this.adapter.removeClass(MDCRippleFoundation2.cssClasses.FG_DEACTIVATION);
      }
      var _a = MDCRippleFoundation2.cssClasses, ROOT_2 = _a.ROOT, UNBOUNDED_2 = _a.UNBOUNDED;
      requestAnimationFrame(function() {
        _this.adapter.removeClass(ROOT_2);
        _this.adapter.removeClass(UNBOUNDED_2);
        _this.removeCssVars_();
      });
    }
    this.deregisterRootHandlers_();
    this.deregisterDeactivationHandlers_();
  };
  MDCRippleFoundation2.prototype.activate = function(evt) {
    this.activate_(evt);
  };
  MDCRippleFoundation2.prototype.deactivate = function() {
    this.deactivate_();
  };
  MDCRippleFoundation2.prototype.layout = function() {
    var _this = this;
    if (this.layoutFrame_) {
      cancelAnimationFrame(this.layoutFrame_);
    }
    this.layoutFrame_ = requestAnimationFrame(function() {
      _this.layoutInternal_();
      _this.layoutFrame_ = 0;
    });
  };
  MDCRippleFoundation2.prototype.setUnbounded = function(unbounded) {
    var UNBOUNDED = MDCRippleFoundation2.cssClasses.UNBOUNDED;
    if (unbounded) {
      this.adapter.addClass(UNBOUNDED);
    } else {
      this.adapter.removeClass(UNBOUNDED);
    }
  };
  MDCRippleFoundation2.prototype.handleFocus = function() {
    var _this = this;
    requestAnimationFrame(function() {
      return _this.adapter.addClass(MDCRippleFoundation2.cssClasses.BG_FOCUSED);
    });
  };
  MDCRippleFoundation2.prototype.handleBlur = function() {
    var _this = this;
    requestAnimationFrame(function() {
      return _this.adapter.removeClass(MDCRippleFoundation2.cssClasses.BG_FOCUSED);
    });
  };
  MDCRippleFoundation2.prototype.supportsPressRipple_ = function() {
    return this.adapter.browserSupportsCssVars();
  };
  MDCRippleFoundation2.prototype.defaultActivationState_ = function() {
    return {
      activationEvent: void 0,
      hasDeactivationUXRun: false,
      isActivated: false,
      isProgrammatic: false,
      wasActivatedByPointer: false,
      wasElementMadeActive: false
    };
  };
  MDCRippleFoundation2.prototype.registerRootHandlers_ = function(supportsPressRipple) {
    var _this = this;
    if (supportsPressRipple) {
      ACTIVATION_EVENT_TYPES.forEach(function(evtType) {
        _this.adapter.registerInteractionHandler(evtType, _this.activateHandler_);
      });
      if (this.adapter.isUnbounded()) {
        this.adapter.registerResizeHandler(this.resizeHandler_);
      }
    }
    this.adapter.registerInteractionHandler("focus", this.focusHandler_);
    this.adapter.registerInteractionHandler("blur", this.blurHandler_);
  };
  MDCRippleFoundation2.prototype.registerDeactivationHandlers_ = function(evt) {
    var _this = this;
    if (evt.type === "keydown") {
      this.adapter.registerInteractionHandler("keyup", this.deactivateHandler_);
    } else {
      POINTER_DEACTIVATION_EVENT_TYPES.forEach(function(evtType) {
        _this.adapter.registerDocumentInteractionHandler(evtType, _this.deactivateHandler_);
      });
    }
  };
  MDCRippleFoundation2.prototype.deregisterRootHandlers_ = function() {
    var _this = this;
    ACTIVATION_EVENT_TYPES.forEach(function(evtType) {
      _this.adapter.deregisterInteractionHandler(evtType, _this.activateHandler_);
    });
    this.adapter.deregisterInteractionHandler("focus", this.focusHandler_);
    this.adapter.deregisterInteractionHandler("blur", this.blurHandler_);
    if (this.adapter.isUnbounded()) {
      this.adapter.deregisterResizeHandler(this.resizeHandler_);
    }
  };
  MDCRippleFoundation2.prototype.deregisterDeactivationHandlers_ = function() {
    var _this = this;
    this.adapter.deregisterInteractionHandler("keyup", this.deactivateHandler_);
    POINTER_DEACTIVATION_EVENT_TYPES.forEach(function(evtType) {
      _this.adapter.deregisterDocumentInteractionHandler(evtType, _this.deactivateHandler_);
    });
  };
  MDCRippleFoundation2.prototype.removeCssVars_ = function() {
    var _this = this;
    var rippleStrings = MDCRippleFoundation2.strings;
    var keys = Object.keys(rippleStrings);
    keys.forEach(function(key) {
      if (key.indexOf("VAR_") === 0) {
        _this.adapter.updateCssVariable(rippleStrings[key], null);
      }
    });
  };
  MDCRippleFoundation2.prototype.activate_ = function(evt) {
    var _this = this;
    if (this.adapter.isSurfaceDisabled()) {
      return;
    }
    var activationState = this.activationState_;
    if (activationState.isActivated) {
      return;
    }
    var previousActivationEvent = this.previousActivationEvent_;
    var isSameInteraction = previousActivationEvent && evt !== void 0 && previousActivationEvent.type !== evt.type;
    if (isSameInteraction) {
      return;
    }
    activationState.isActivated = true;
    activationState.isProgrammatic = evt === void 0;
    activationState.activationEvent = evt;
    activationState.wasActivatedByPointer = activationState.isProgrammatic ? false : evt !== void 0 && (evt.type === "mousedown" || evt.type === "touchstart" || evt.type === "pointerdown");
    var hasActivatedChild = evt !== void 0 && activatedTargets.length > 0 && activatedTargets.some(function(target) {
      return _this.adapter.containsEventTarget(target);
    });
    if (hasActivatedChild) {
      this.resetActivationState_();
      return;
    }
    if (evt !== void 0) {
      activatedTargets.push(evt.target);
      this.registerDeactivationHandlers_(evt);
    }
    activationState.wasElementMadeActive = this.checkElementMadeActive_(evt);
    if (activationState.wasElementMadeActive) {
      this.animateActivation_();
    }
    requestAnimationFrame(function() {
      activatedTargets = [];
      if (!activationState.wasElementMadeActive && evt !== void 0 && (evt.key === " " || evt.keyCode === 32)) {
        activationState.wasElementMadeActive = _this.checkElementMadeActive_(evt);
        if (activationState.wasElementMadeActive) {
          _this.animateActivation_();
        }
      }
      if (!activationState.wasElementMadeActive) {
        _this.activationState_ = _this.defaultActivationState_();
      }
    });
  };
  MDCRippleFoundation2.prototype.checkElementMadeActive_ = function(evt) {
    return evt !== void 0 && evt.type === "keydown" ? this.adapter.isSurfaceActive() : true;
  };
  MDCRippleFoundation2.prototype.animateActivation_ = function() {
    var _this = this;
    var _a = MDCRippleFoundation2.strings, VAR_FG_TRANSLATE_START = _a.VAR_FG_TRANSLATE_START, VAR_FG_TRANSLATE_END = _a.VAR_FG_TRANSLATE_END;
    var _b = MDCRippleFoundation2.cssClasses, FG_DEACTIVATION = _b.FG_DEACTIVATION, FG_ACTIVATION = _b.FG_ACTIVATION;
    var DEACTIVATION_TIMEOUT_MS = MDCRippleFoundation2.numbers.DEACTIVATION_TIMEOUT_MS;
    this.layoutInternal_();
    var translateStart = "";
    var translateEnd = "";
    if (!this.adapter.isUnbounded()) {
      var _c = this.getFgTranslationCoordinates_(), startPoint = _c.startPoint, endPoint = _c.endPoint;
      translateStart = startPoint.x + "px, " + startPoint.y + "px";
      translateEnd = endPoint.x + "px, " + endPoint.y + "px";
    }
    this.adapter.updateCssVariable(VAR_FG_TRANSLATE_START, translateStart);
    this.adapter.updateCssVariable(VAR_FG_TRANSLATE_END, translateEnd);
    clearTimeout(this.activationTimer_);
    clearTimeout(this.fgDeactivationRemovalTimer_);
    this.rmBoundedActivationClasses_();
    this.adapter.removeClass(FG_DEACTIVATION);
    this.adapter.computeBoundingRect();
    this.adapter.addClass(FG_ACTIVATION);
    this.activationTimer_ = setTimeout(function() {
      return _this.activationTimerCallback_();
    }, DEACTIVATION_TIMEOUT_MS);
  };
  MDCRippleFoundation2.prototype.getFgTranslationCoordinates_ = function() {
    var _a = this.activationState_, activationEvent = _a.activationEvent, wasActivatedByPointer = _a.wasActivatedByPointer;
    var startPoint;
    if (wasActivatedByPointer) {
      startPoint = getNormalizedEventCoords(activationEvent, this.adapter.getWindowPageOffset(), this.adapter.computeBoundingRect());
    } else {
      startPoint = {
        x: this.frame_.width / 2,
        y: this.frame_.height / 2
      };
    }
    startPoint = {
      x: startPoint.x - this.initialSize_ / 2,
      y: startPoint.y - this.initialSize_ / 2
    };
    var endPoint = {
      x: this.frame_.width / 2 - this.initialSize_ / 2,
      y: this.frame_.height / 2 - this.initialSize_ / 2
    };
    return { startPoint, endPoint };
  };
  MDCRippleFoundation2.prototype.runDeactivationUXLogicIfReady_ = function() {
    var _this = this;
    var FG_DEACTIVATION = MDCRippleFoundation2.cssClasses.FG_DEACTIVATION;
    var _a = this.activationState_, hasDeactivationUXRun = _a.hasDeactivationUXRun, isActivated = _a.isActivated;
    var activationHasEnded = hasDeactivationUXRun || !isActivated;
    if (activationHasEnded && this.activationAnimationHasEnded_) {
      this.rmBoundedActivationClasses_();
      this.adapter.addClass(FG_DEACTIVATION);
      this.fgDeactivationRemovalTimer_ = setTimeout(function() {
        _this.adapter.removeClass(FG_DEACTIVATION);
      }, numbers.FG_DEACTIVATION_MS);
    }
  };
  MDCRippleFoundation2.prototype.rmBoundedActivationClasses_ = function() {
    var FG_ACTIVATION = MDCRippleFoundation2.cssClasses.FG_ACTIVATION;
    this.adapter.removeClass(FG_ACTIVATION);
    this.activationAnimationHasEnded_ = false;
    this.adapter.computeBoundingRect();
  };
  MDCRippleFoundation2.prototype.resetActivationState_ = function() {
    var _this = this;
    this.previousActivationEvent_ = this.activationState_.activationEvent;
    this.activationState_ = this.defaultActivationState_();
    setTimeout(function() {
      return _this.previousActivationEvent_ = void 0;
    }, MDCRippleFoundation2.numbers.TAP_DELAY_MS);
  };
  MDCRippleFoundation2.prototype.deactivate_ = function() {
    var _this = this;
    var activationState = this.activationState_;
    if (!activationState.isActivated) {
      return;
    }
    var state = __assign({}, activationState);
    if (activationState.isProgrammatic) {
      requestAnimationFrame(function() {
        return _this.animateDeactivation_(state);
      });
      this.resetActivationState_();
    } else {
      this.deregisterDeactivationHandlers_();
      requestAnimationFrame(function() {
        _this.activationState_.hasDeactivationUXRun = true;
        _this.animateDeactivation_(state);
        _this.resetActivationState_();
      });
    }
  };
  MDCRippleFoundation2.prototype.animateDeactivation_ = function(_a) {
    var wasActivatedByPointer = _a.wasActivatedByPointer, wasElementMadeActive = _a.wasElementMadeActive;
    if (wasActivatedByPointer || wasElementMadeActive) {
      this.runDeactivationUXLogicIfReady_();
    }
  };
  MDCRippleFoundation2.prototype.layoutInternal_ = function() {
    var _this = this;
    this.frame_ = this.adapter.computeBoundingRect();
    var maxDim = Math.max(this.frame_.height, this.frame_.width);
    var getBoundedRadius = function() {
      var hypotenuse = Math.sqrt(Math.pow(_this.frame_.width, 2) + Math.pow(_this.frame_.height, 2));
      return hypotenuse + MDCRippleFoundation2.numbers.PADDING;
    };
    this.maxRadius_ = this.adapter.isUnbounded() ? maxDim : getBoundedRadius();
    var initialSize = Math.floor(maxDim * MDCRippleFoundation2.numbers.INITIAL_ORIGIN_SCALE);
    if (this.adapter.isUnbounded() && initialSize % 2 !== 0) {
      this.initialSize_ = initialSize - 1;
    } else {
      this.initialSize_ = initialSize;
    }
    this.fgScale_ = "" + this.maxRadius_ / this.initialSize_;
    this.updateLayoutCssVars_();
  };
  MDCRippleFoundation2.prototype.updateLayoutCssVars_ = function() {
    var _a = MDCRippleFoundation2.strings, VAR_FG_SIZE = _a.VAR_FG_SIZE, VAR_LEFT = _a.VAR_LEFT, VAR_TOP = _a.VAR_TOP, VAR_FG_SCALE = _a.VAR_FG_SCALE;
    this.adapter.updateCssVariable(VAR_FG_SIZE, this.initialSize_ + "px");
    this.adapter.updateCssVariable(VAR_FG_SCALE, this.fgScale_);
    if (this.adapter.isUnbounded()) {
      this.unboundedCoords_ = {
        left: Math.round(this.frame_.width / 2 - this.initialSize_ / 2),
        top: Math.round(this.frame_.height / 2 - this.initialSize_ / 2)
      };
      this.adapter.updateCssVariable(VAR_LEFT, this.unboundedCoords_.left + "px");
      this.adapter.updateCssVariable(VAR_TOP, this.unboundedCoords_.top + "px");
    }
  };
  return MDCRippleFoundation2;
}(MDCFoundation);
var cssClasses$1 = {
  ACTIVE: "mdc-tab-indicator--active",
  FADE: "mdc-tab-indicator--fade",
  NO_TRANSITION: "mdc-tab-indicator--no-transition"
};
var strings$1 = {
  CONTENT_SELECTOR: ".mdc-tab-indicator__content"
};
var MDCTabIndicatorFoundation = function(_super) {
  __extends(MDCTabIndicatorFoundation2, _super);
  function MDCTabIndicatorFoundation2(adapter) {
    return _super.call(this, __assign(__assign({}, MDCTabIndicatorFoundation2.defaultAdapter), adapter)) || this;
  }
  Object.defineProperty(MDCTabIndicatorFoundation2, "cssClasses", {
    get: function() {
      return cssClasses$1;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCTabIndicatorFoundation2, "strings", {
    get: function() {
      return strings$1;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCTabIndicatorFoundation2, "defaultAdapter", {
    get: function() {
      return {
        addClass: function() {
          return void 0;
        },
        removeClass: function() {
          return void 0;
        },
        computeContentClientRect: function() {
          return { top: 0, right: 0, bottom: 0, left: 0, width: 0, height: 0 };
        },
        setContentStyleProperty: function() {
          return void 0;
        }
      };
    },
    enumerable: false,
    configurable: true
  });
  MDCTabIndicatorFoundation2.prototype.computeContentClientRect = function() {
    return this.adapter.computeContentClientRect();
  };
  return MDCTabIndicatorFoundation2;
}(MDCFoundation);
var MDCFadingTabIndicatorFoundation = function(_super) {
  __extends(MDCFadingTabIndicatorFoundation2, _super);
  function MDCFadingTabIndicatorFoundation2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  MDCFadingTabIndicatorFoundation2.prototype.activate = function() {
    this.adapter.addClass(MDCTabIndicatorFoundation.cssClasses.ACTIVE);
  };
  MDCFadingTabIndicatorFoundation2.prototype.deactivate = function() {
    this.adapter.removeClass(MDCTabIndicatorFoundation.cssClasses.ACTIVE);
  };
  return MDCFadingTabIndicatorFoundation2;
}(MDCTabIndicatorFoundation);
var MDCSlidingTabIndicatorFoundation = function(_super) {
  __extends(MDCSlidingTabIndicatorFoundation2, _super);
  function MDCSlidingTabIndicatorFoundation2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  MDCSlidingTabIndicatorFoundation2.prototype.activate = function(previousIndicatorClientRect) {
    if (!previousIndicatorClientRect) {
      this.adapter.addClass(MDCTabIndicatorFoundation.cssClasses.ACTIVE);
      return;
    }
    var currentClientRect = this.computeContentClientRect();
    var widthDelta = previousIndicatorClientRect.width / currentClientRect.width;
    var xPosition = previousIndicatorClientRect.left - currentClientRect.left;
    this.adapter.addClass(MDCTabIndicatorFoundation.cssClasses.NO_TRANSITION);
    this.adapter.setContentStyleProperty("transform", "translateX(" + xPosition + "px) scaleX(" + widthDelta + ")");
    this.computeContentClientRect();
    this.adapter.removeClass(MDCTabIndicatorFoundation.cssClasses.NO_TRANSITION);
    this.adapter.addClass(MDCTabIndicatorFoundation.cssClasses.ACTIVE);
    this.adapter.setContentStyleProperty("transform", "");
  };
  MDCSlidingTabIndicatorFoundation2.prototype.deactivate = function() {
    this.adapter.removeClass(MDCTabIndicatorFoundation.cssClasses.ACTIVE);
  };
  return MDCSlidingTabIndicatorFoundation2;
}(MDCTabIndicatorFoundation);
var { applyPassive } = events;
var { matches } = ponyfill;
function Ripple(node, {
  ripple = true,
  surface = false,
  unbounded = false,
  disabled = false,
  color = null,
  active = null,
  eventTarget = null,
  activeTarget = null,
  addClass = (className) => node.classList.add(className),
  removeClass = (className) => node.classList.remove(className),
  addStyle = (name, value) => node.style.setProperty(name, value),
  initPromise = Promise.resolve()
} = {}) {
  let instance;
  let addLayoutListener = getContext("SMUI:addLayoutListener");
  let removeLayoutListener;
  let oldActive = active;
  let oldEventTarget = eventTarget;
  let oldActiveTarget = activeTarget;
  function handleProps() {
    if (surface) {
      addClass("mdc-ripple-surface");
      if (color === "primary") {
        addClass("smui-ripple-surface--primary");
        removeClass("smui-ripple-surface--secondary");
      } else if (color === "secondary") {
        removeClass("smui-ripple-surface--primary");
        addClass("smui-ripple-surface--secondary");
      } else {
        removeClass("smui-ripple-surface--primary");
        removeClass("smui-ripple-surface--secondary");
      }
    }
    if (instance && oldActive !== active) {
      oldActive = active;
      if (active) {
        instance.activate();
      } else if (active === false) {
        instance.deactivate();
      }
    }
    if (ripple && !instance) {
      instance = new MDCRippleFoundation({
        addClass,
        browserSupportsCssVars: () => supportsCssVariables(window),
        computeBoundingRect: () => node.getBoundingClientRect(),
        containsEventTarget: (target) => node.contains(target),
        deregisterDocumentInteractionHandler: (evtType, handler) => document.documentElement.removeEventListener(evtType, handler, applyPassive()),
        deregisterInteractionHandler: (evtType, handler) => (eventTarget || node).removeEventListener(evtType, handler, applyPassive()),
        deregisterResizeHandler: (handler) => window.removeEventListener("resize", handler),
        getWindowPageOffset: () => ({
          x: window.pageXOffset,
          y: window.pageYOffset
        }),
        isSurfaceActive: () => active == null ? matches(activeTarget || node, ":active") : active,
        isSurfaceDisabled: () => !!disabled,
        isUnbounded: () => !!unbounded,
        registerDocumentInteractionHandler: (evtType, handler) => document.documentElement.addEventListener(evtType, handler, applyPassive()),
        registerInteractionHandler: (evtType, handler) => (eventTarget || node).addEventListener(evtType, handler, applyPassive()),
        registerResizeHandler: (handler) => window.addEventListener("resize", handler),
        removeClass,
        updateCssVariable: addStyle
      });
      initPromise.then(() => {
        instance.init();
        instance.setUnbounded(unbounded);
      });
    } else if (instance && !ripple) {
      initPromise.then(() => {
        instance.destroy();
        instance = null;
      });
    }
    if (instance && (oldEventTarget !== eventTarget || oldActiveTarget !== activeTarget)) {
      oldEventTarget = eventTarget;
      oldActiveTarget = activeTarget;
      instance.destroy();
      requestAnimationFrame(() => {
        if (instance) {
          instance.init();
          instance.setUnbounded(unbounded);
        }
      });
    }
    if (!ripple && unbounded) {
      addClass("mdc-ripple-upgraded--unbounded");
    }
  }
  handleProps();
  if (addLayoutListener) {
    removeLayoutListener = addLayoutListener(layout);
  }
  function layout() {
    if (instance) {
      instance.layout();
    }
  }
  return {
    update(props) {
      ({
        ripple,
        surface,
        unbounded,
        disabled,
        color,
        active,
        eventTarget,
        activeTarget,
        addClass,
        removeClass,
        addStyle,
        initPromise
      } = {
        ripple: true,
        surface: false,
        unbounded: false,
        disabled: false,
        color: null,
        active: null,
        eventTarget: null,
        activeTarget: null,
        addClass: (className) => node.classList.add(className),
        removeClass: (className) => node.classList.remove(className),
        addStyle: (name, value) => node.style.setProperty(name, value),
        initPromise: Promise.resolve(),
        ...props
      });
      handleProps();
    },
    destroy() {
      if (instance) {
        instance.destroy();
        instance = null;
        removeClass("mdc-ripple-surface");
        removeClass("smui-ripple-surface--primary");
        removeClass("smui-ripple-surface--secondary");
      }
      if (removeLayoutListener) {
        removeLayoutListener();
      }
    }
  };
}
var A = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let $$restProps = compute_rest_props($$props, ["href", "use", "getElement"]);
  let { href = "javascript:void(0);" } = $$props;
  let { use = [] } = $$props;
  forwardEventsBuilder(get_current_component());
  let element = null;
  function getElement() {
    return element;
  }
  if ($$props.href === void 0 && $$bindings.href && href !== void 0)
    $$bindings.href(href);
  if ($$props.use === void 0 && $$bindings.use && use !== void 0)
    $$bindings.use(use);
  if ($$props.getElement === void 0 && $$bindings.getElement && getElement !== void 0)
    $$bindings.getElement(getElement);
  return `<a${spread([{ href: escape_attribute_value(href) }, escape_object($$restProps)])}${add_attribute("this", element, 0)}>${slots.default ? slots.default({}) : ``}</a>`;
});
var Button = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let $$restProps = compute_rest_props($$props, ["use", "getElement"]);
  let { use = [] } = $$props;
  forwardEventsBuilder(get_current_component());
  let element = null;
  function getElement() {
    return element;
  }
  if ($$props.use === void 0 && $$bindings.use && use !== void 0)
    $$bindings.use(use);
  if ($$props.getElement === void 0 && $$bindings.getElement && getElement !== void 0)
    $$bindings.getElement(getElement);
  return `<button${spread([escape_object($$restProps)])}${add_attribute("this", element, 0)}>${slots.default ? slots.default({}) : ``}</button>`;
});
var TabIndicator = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let $$restProps = compute_rest_props($$props, [
    "use",
    "class",
    "active",
    "type",
    "transition",
    "content$use",
    "content$class",
    "activate",
    "deactivate",
    "computeContentClientRect",
    "getElement"
  ]);
  forwardEventsBuilder(get_current_component());
  let { use = [] } = $$props;
  let { class: className = "" } = $$props;
  let { active = false } = $$props;
  let { type = "underline" } = $$props;
  let { transition = "slide" } = $$props;
  let { content$use = [] } = $$props;
  let { content$class = "" } = $$props;
  let element;
  let instance;
  let content;
  let internalClasses = {};
  let contentStyles = {};
  let changeSets = [];
  let oldTransition = transition;
  function getInstance() {
    const Foundation = {
      fade: MDCFadingTabIndicatorFoundation,
      slide: MDCSlidingTabIndicatorFoundation
    }[transition] || MDCSlidingTabIndicatorFoundation;
    return Foundation ? new Foundation({
      addClass: (...props) => doChange(() => addClass(...props)),
      removeClass: (...props) => doChange(() => removeClass(...props)),
      computeContentClientRect,
      setContentStyleProperty: (...props) => doChange(() => addContentStyle(...props))
    }) : void 0;
  }
  function doChange(fn) {
    if (changeSets.length) {
      changeSets[changeSets.length - 1].push(fn);
    } else {
      fn();
    }
  }
  function addClass(className2) {
    if (!internalClasses[className2]) {
      internalClasses[className2] = true;
    }
  }
  function removeClass(className2) {
    if (!(className2 in internalClasses) || internalClasses[className2]) {
      internalClasses[className2] = false;
    }
  }
  function addContentStyle(name, value) {
    if (contentStyles[name] != value) {
      if (value === "" || value == null) {
        delete contentStyles[name];
        contentStyles = contentStyles;
      } else {
        contentStyles[name] = value;
      }
    }
  }
  function activate(previousIndicatorClientRect) {
    active = true;
    instance.activate(previousIndicatorClientRect);
  }
  function deactivate() {
    active = false;
    instance.deactivate();
  }
  function computeContentClientRect() {
    changeSets.push([]);
    changeSets = changeSets;
    return content.getBoundingClientRect();
  }
  function getElement() {
    return element;
  }
  if ($$props.use === void 0 && $$bindings.use && use !== void 0)
    $$bindings.use(use);
  if ($$props.class === void 0 && $$bindings.class && className !== void 0)
    $$bindings.class(className);
  if ($$props.active === void 0 && $$bindings.active && active !== void 0)
    $$bindings.active(active);
  if ($$props.type === void 0 && $$bindings.type && type !== void 0)
    $$bindings.type(type);
  if ($$props.transition === void 0 && $$bindings.transition && transition !== void 0)
    $$bindings.transition(transition);
  if ($$props.content$use === void 0 && $$bindings.content$use && content$use !== void 0)
    $$bindings.content$use(content$use);
  if ($$props.content$class === void 0 && $$bindings.content$class && content$class !== void 0)
    $$bindings.content$class(content$class);
  if ($$props.activate === void 0 && $$bindings.activate && activate !== void 0)
    $$bindings.activate(activate);
  if ($$props.deactivate === void 0 && $$bindings.deactivate && deactivate !== void 0)
    $$bindings.deactivate(deactivate);
  if ($$props.computeContentClientRect === void 0 && $$bindings.computeContentClientRect && computeContentClientRect !== void 0)
    $$bindings.computeContentClientRect(computeContentClientRect);
  if ($$props.getElement === void 0 && $$bindings.getElement && getElement !== void 0)
    $$bindings.getElement(getElement);
  {
    if (oldTransition !== transition) {
      oldTransition = transition;
      instance && instance.destroy();
      internalClasses = {};
      contentStyles = {};
      instance = getInstance();
      instance.init();
    }
  }
  {
    if (changeSets.length) {
      requestAnimationFrame(() => {
        const changeSet = changeSets.shift();
        changeSets = changeSets;
        for (const fn of changeSet) {
          fn();
        }
      });
    }
  }
  return `<span${spread([
    {
      class: escape_attribute_value(classMap({
        [className]: true,
        "mdc-tab-indicator": true,
        "mdc-tab-indicator--active": active,
        "mdc-tab-indicator--fade": transition === "fade",
        ...internalClasses
      }))
    },
    escape_object(exclude($$restProps, ["content$"]))
  ])}${add_attribute("this", element, 0)}><span${spread([
    {
      class: escape_attribute_value(classMap({
        [content$class]: true,
        "mdc-tab-indicator__content": true,
        "mdc-tab-indicator__content--underline": type === "underline",
        "mdc-tab-indicator__content--icon": type === "icon"
      }))
    },
    {
      style: escape_attribute_value(Object.entries(contentStyles).map(([name, value]) => `${name}: ${value};`).join(" "))
    },
    {
      "aria-hidden": escape_attribute_value(type === "icon" ? "true" : null)
    },
    escape_object(prefixFilter($$restProps, "content$"))
  ])}${add_attribute("this", content, 0)}>${slots.default ? slots.default({}) : ``}</span>
</span>`;
});
var { Object: Object_1$5 } = globals;
var Tab = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let $$restProps = compute_rest_props($$props, [
    "use",
    "class",
    "style",
    "tab",
    "ripple",
    "stacked",
    "minWidth",
    "indicatorSpanOnlyContent",
    "href",
    "content$use",
    "content$class",
    "component",
    "activate",
    "deactivate",
    "focus",
    "getElement"
  ]);
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { use = [] } = $$props;
  let { class: className = "" } = $$props;
  let { style = "" } = $$props;
  let { tab: tabId } = $$props;
  let { ripple = true } = $$props;
  let { stacked = false } = $$props;
  let { minWidth = false } = $$props;
  let { indicatorSpanOnlyContent = false } = $$props;
  let { href = null } = $$props;
  let { content$use = [] } = $$props;
  let { content$class = "" } = $$props;
  let element;
  let instance;
  let content;
  let tabIndicator;
  let internalClasses = {};
  let internalStyles = {};
  let internalAttrs = {};
  let focusOnActivate = getContext("SMUI:tab:focusOnActivate");
  let active = tabId === getContext("SMUI:tab:initialActive");
  let forceAccessible = false;
  let { component = href == null ? Button : A } = $$props;
  setContext("SMUI:label:context", "tab");
  setContext("SMUI:icon:context", "tab");
  if (!tabId) {
    throw new Error("The tab property is required! It should be passed down from the TabBar to the Tab.");
  }
  function addClass(className2) {
    if (!internalClasses[className2]) {
      internalClasses[className2] = true;
    }
  }
  function removeClass(className2) {
    if (!(className2 in internalClasses) || internalClasses[className2]) {
      internalClasses[className2] = false;
    }
  }
  function addStyle(name, value) {
    if (internalStyles[name] != value) {
      if (value === "" || value == null) {
        delete internalStyles[name];
        internalStyles = internalStyles;
      } else {
        internalStyles[name] = value;
      }
    }
  }
  function activate(previousIndicatorClientRect, skipFocus) {
    active = true;
    if (skipFocus) {
      instance.setFocusOnActivate(false);
    }
    instance.activate(previousIndicatorClientRect);
    if (skipFocus) {
      instance.setFocusOnActivate(focusOnActivate);
    }
  }
  function deactivate() {
    active = false;
    instance.deactivate();
  }
  function focus() {
    getElement().focus();
  }
  function getElement() {
    return element.getElement();
  }
  if ($$props.use === void 0 && $$bindings.use && use !== void 0)
    $$bindings.use(use);
  if ($$props.class === void 0 && $$bindings.class && className !== void 0)
    $$bindings.class(className);
  if ($$props.style === void 0 && $$bindings.style && style !== void 0)
    $$bindings.style(style);
  if ($$props.tab === void 0 && $$bindings.tab && tabId !== void 0)
    $$bindings.tab(tabId);
  if ($$props.ripple === void 0 && $$bindings.ripple && ripple !== void 0)
    $$bindings.ripple(ripple);
  if ($$props.stacked === void 0 && $$bindings.stacked && stacked !== void 0)
    $$bindings.stacked(stacked);
  if ($$props.minWidth === void 0 && $$bindings.minWidth && minWidth !== void 0)
    $$bindings.minWidth(minWidth);
  if ($$props.indicatorSpanOnlyContent === void 0 && $$bindings.indicatorSpanOnlyContent && indicatorSpanOnlyContent !== void 0)
    $$bindings.indicatorSpanOnlyContent(indicatorSpanOnlyContent);
  if ($$props.href === void 0 && $$bindings.href && href !== void 0)
    $$bindings.href(href);
  if ($$props.content$use === void 0 && $$bindings.content$use && content$use !== void 0)
    $$bindings.content$use(content$use);
  if ($$props.content$class === void 0 && $$bindings.content$class && content$class !== void 0)
    $$bindings.content$class(content$class);
  if ($$props.component === void 0 && $$bindings.component && component !== void 0)
    $$bindings.component(component);
  if ($$props.activate === void 0 && $$bindings.activate && activate !== void 0)
    $$bindings.activate(activate);
  if ($$props.deactivate === void 0 && $$bindings.deactivate && deactivate !== void 0)
    $$bindings.deactivate(deactivate);
  if ($$props.focus === void 0 && $$bindings.focus && focus !== void 0)
    $$bindings.focus(focus);
  if ($$props.getElement === void 0 && $$bindings.getElement && getElement !== void 0)
    $$bindings.getElement(getElement);
  let $$settled;
  let $$rendered;
  do {
    $$settled = true;
    $$rendered = `${validate_component(component || missing_component, "svelte:component").$$render($$result, Object_1$5.assign({
      use: [
        [
          Ripple,
          {
            ripple,
            unbounded: false,
            addClass,
            removeClass,
            addStyle
          }
        ],
        forwardEvents,
        ...use
      ]
    }, {
      class: classMap({
        [className]: true,
        "mdc-tab": true,
        "mdc-tab--active": active,
        "mdc-tab--stacked": stacked,
        "mdc-tab--min-width": minWidth,
        ...internalClasses
      })
    }, {
      style: Object.entries(internalStyles).map(([name, value]) => `${name}: ${value};`).concat([style]).join(" ")
    }, { role: "tab" }, {
      "aria-selected": active ? "true" : "false"
    }, {
      tabindex: active || forceAccessible ? "0" : "-1"
    }, { href }, internalAttrs, exclude($$restProps, ["content$", "tabIndicator$"]), { this: element }), {
      this: ($$value) => {
        element = $$value;
        $$settled = false;
      }
    }, {
      default: () => `<span${spread([
        {
          class: escape_attribute_value(classMap({
            [content$class]: true,
            "mdc-tab__content": true
          }))
        },
        escape_object(prefixFilter($$restProps, "content$"))
      ])}${add_attribute("this", content, 0)}>${slots.default ? slots.default({}) : ``}
    ${indicatorSpanOnlyContent ? `${validate_component(TabIndicator, "TabIndicator").$$render($$result, Object_1$5.assign({ active }, prefixFilter($$restProps, "tabIndicator$"), { this: tabIndicator }), {
        this: ($$value) => {
          tabIndicator = $$value;
          $$settled = false;
        }
      }, {
        default: () => `${slots["tab-indicator"] ? slots["tab-indicator"]({}) : ``}`
      })}` : ``}</span>
  ${!indicatorSpanOnlyContent ? `${validate_component(TabIndicator, "TabIndicator").$$render($$result, Object_1$5.assign({ active }, prefixFilter($$restProps, "tabIndicator$"), { this: tabIndicator }), {
        this: ($$value) => {
          tabIndicator = $$value;
          $$settled = false;
        }
      }, {
        default: () => `${slots["tab-indicator"] ? slots["tab-indicator"]({}) : ``}`
      })}` : ``}
  <span class="${"mdc-tab__ripple"}"></span>`
    })}`;
  } while (!$$settled);
  return $$rendered;
});
var Span = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let $$restProps = compute_rest_props($$props, ["use", "getElement"]);
  let { use = [] } = $$props;
  forwardEventsBuilder(get_current_component());
  let element = null;
  function getElement() {
    return element;
  }
  if ($$props.use === void 0 && $$bindings.use && use !== void 0)
    $$bindings.use(use);
  if ($$props.getElement === void 0 && $$bindings.getElement && getElement !== void 0)
    $$bindings.getElement(getElement);
  return `<span${spread([escape_object($$restProps)])}${add_attribute("this", element, 0)}>${slots.default ? slots.default({}) : ``}</span>`;
});
var CommonLabel = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let $$restProps = compute_rest_props($$props, ["use", "class", "component", "getElement"]);
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { use = [] } = $$props;
  let { class: className = "" } = $$props;
  let element;
  let { component = Span } = $$props;
  const context = getContext("SMUI:label:context");
  const tabindex = getContext("SMUI:label:tabindex");
  function getElement() {
    return element.getElement();
  }
  if ($$props.use === void 0 && $$bindings.use && use !== void 0)
    $$bindings.use(use);
  if ($$props.class === void 0 && $$bindings.class && className !== void 0)
    $$bindings.class(className);
  if ($$props.component === void 0 && $$bindings.component && component !== void 0)
    $$bindings.component(component);
  if ($$props.getElement === void 0 && $$bindings.getElement && getElement !== void 0)
    $$bindings.getElement(getElement);
  let $$settled;
  let $$rendered;
  do {
    $$settled = true;
    $$rendered = `${validate_component(component || missing_component, "svelte:component").$$render($$result, Object.assign({ use: [forwardEvents, ...use] }, {
      class: classMap({
        [className]: true,
        "mdc-button__label": context === "button",
        "mdc-fab__label": context === "fab",
        "mdc-tab__text-label": context === "tab",
        "mdc-image-list__label": context === "image-list",
        "mdc-snackbar__label": context === "snackbar",
        "mdc-banner__text": context === "banner",
        "mdc-segmented-button__label": context === "segmented-button",
        "mdc-data-table__pagination-rows-per-page-label": context === "data-table:pagination",
        "mdc-data-table__header-cell-label": context === "data-table:sortable-header-cell"
      })
    }, context === "snackbar" ? { "aria-atomic": "false" } : {}, { tabindex }, $$restProps, { this: element }), {
      this: ($$value) => {
        element = $$value;
        $$settled = false;
      }
    }, {
      default: () => `${slots.default ? slots.default({}) : ``}`
    })}`;
  } while (!$$settled);
  return $$rendered;
});
var I = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let $$restProps = compute_rest_props($$props, ["use", "getElement"]);
  let { use = [] } = $$props;
  forwardEventsBuilder(get_current_component());
  let element = null;
  function getElement() {
    return element;
  }
  if ($$props.use === void 0 && $$bindings.use && use !== void 0)
    $$bindings.use(use);
  if ($$props.getElement === void 0 && $$bindings.getElement && getElement !== void 0)
    $$bindings.getElement(getElement);
  return `<i${spread([escape_object($$restProps)])}${add_attribute("this", element, 0)}>${slots.default ? slots.default({}) : ``}</i>`;
});
var Svg = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let $$restProps = compute_rest_props($$props, ["use", "getElement"]);
  let { use = [] } = $$props;
  forwardEventsBuilder(get_current_component());
  let element = null;
  function getElement() {
    return element;
  }
  if ($$props.use === void 0 && $$bindings.use && use !== void 0)
    $$bindings.use(use);
  if ($$props.getElement === void 0 && $$bindings.getElement && getElement !== void 0)
    $$bindings.getElement(getElement);
  return `<svg${spread([escape_object($$restProps)])}${add_attribute("this", element, 0)}>${slots.default ? slots.default({}) : ``}</svg>`;
});
var CommonIcon = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let $$restProps = compute_rest_props($$props, ["use", "class", "on", "component", "getElement"]);
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { use = [] } = $$props;
  let { class: className = "" } = $$props;
  let { on = false } = $$props;
  let element;
  let { component = I } = $$props;
  const context = getContext("SMUI:icon:context");
  function getElement() {
    return element.getElement();
  }
  if ($$props.use === void 0 && $$bindings.use && use !== void 0)
    $$bindings.use(use);
  if ($$props.class === void 0 && $$bindings.class && className !== void 0)
    $$bindings.class(className);
  if ($$props.on === void 0 && $$bindings.on && on !== void 0)
    $$bindings.on(on);
  if ($$props.component === void 0 && $$bindings.component && component !== void 0)
    $$bindings.component(component);
  if ($$props.getElement === void 0 && $$bindings.getElement && getElement !== void 0)
    $$bindings.getElement(getElement);
  let $$settled;
  let $$rendered;
  do {
    $$settled = true;
    $$rendered = `${validate_component(component || missing_component, "svelte:component").$$render($$result, Object.assign({ use: [forwardEvents, ...use] }, {
      class: classMap({
        [className]: true,
        "mdc-button__icon": context === "button",
        "mdc-fab__icon": context === "fab",
        "mdc-icon-button__icon": context === "icon-button",
        "mdc-icon-button__icon--on": context === "icon-button" && on,
        "mdc-tab__icon": context === "tab",
        "mdc-banner__icon": context === "banner",
        "mdc-segmented-button__icon": context === "segmented-button"
      })
    }, { "aria-hidden": "true" }, component === Svg ? { focusable: "false", tabindex: "-1" } : {}, $$restProps, { this: element }), {
      this: ($$value) => {
        element = $$value;
        $$settled = false;
      }
    }, {
      default: () => `${slots.default ? slots.default({}) : ``}`
    })}`;
  } while (!$$settled);
  return $$rendered;
});
var Ul = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let $$restProps = compute_rest_props($$props, ["use", "getElement"]);
  let { use = [] } = $$props;
  forwardEventsBuilder(get_current_component());
  let element = null;
  function getElement() {
    return element;
  }
  if ($$props.use === void 0 && $$bindings.use && use !== void 0)
    $$bindings.use(use);
  if ($$props.getElement === void 0 && $$bindings.getElement && getElement !== void 0)
    $$bindings.getElement(getElement);
  return `<ul${spread([escape_object($$restProps)])}${add_attribute("this", element, 0)}>${slots.default ? slots.default({}) : ``}
</ul>`;
});
var Nav$1 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let $$restProps = compute_rest_props($$props, ["use", "getElement"]);
  let { use = [] } = $$props;
  forwardEventsBuilder(get_current_component());
  let element = null;
  function getElement() {
    return element;
  }
  if ($$props.use === void 0 && $$bindings.use && use !== void 0)
    $$bindings.use(use);
  if ($$props.getElement === void 0 && $$bindings.getElement && getElement !== void 0)
    $$bindings.getElement(getElement);
  return `<nav${spread([escape_object($$restProps)])}${add_attribute("this", element, 0)}>${slots.default ? slots.default({}) : ``}
</nav>`;
});
var List = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let $$restProps = compute_rest_props($$props, [
    "use",
    "class",
    "nonInteractive",
    "dense",
    "textualList",
    "avatarList",
    "iconList",
    "imageList",
    "thumbnailList",
    "videoList",
    "twoLine",
    "threeLine",
    "vertical",
    "wrapFocus",
    "singleSelection",
    "selectedIndex",
    "radioList",
    "checkList",
    "hasTypeahead",
    "radiolist",
    "checklist",
    "component",
    "layout",
    "setEnabled",
    "getTypeaheadInProgress",
    "getSelectedIndex",
    "getElement"
  ]);
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { use = [] } = $$props;
  let { class: className = "" } = $$props;
  let { nonInteractive = false } = $$props;
  let { dense = false } = $$props;
  let { textualList = false } = $$props;
  let { avatarList = false } = $$props;
  let { iconList = false } = $$props;
  let { imageList = false } = $$props;
  let { thumbnailList = false } = $$props;
  let { videoList = false } = $$props;
  let { twoLine = false } = $$props;
  let { threeLine = false } = $$props;
  let { vertical = true } = $$props;
  let { wrapFocus = getContext("SMUI:list:wrapFocus") || false } = $$props;
  let { singleSelection = false } = $$props;
  let { selectedIndex = -1 } = $$props;
  let { radioList = false } = $$props;
  let { checkList = false } = $$props;
  let { hasTypeahead = false } = $$props;
  let { radiolist = false } = $$props;
  if (radiolist) {
    radioList = true;
  }
  let { checklist = false } = $$props;
  if (checklist) {
    checkList = true;
  }
  let element;
  let instance;
  let role = getContext("SMUI:list:role");
  let nav = getContext("SMUI:list:nav");
  let selectionDialog = getContext("SMUI:dialog:selection");
  let addLayoutListener = getContext("SMUI:addLayoutListener");
  let removeLayoutListener;
  let { component = nav ? Nav$1 : Ul } = $$props;
  setContext("SMUI:list:nonInteractive", nonInteractive);
  setContext("SMUI:separator:context", "list");
  if (!role) {
    if (singleSelection) {
      role = "listbox";
      setContext("SMUI:list:item:role", "option");
    } else if (radioList) {
      role = "radiogroup";
      setContext("SMUI:list:item:role", "radio");
    } else if (checkList) {
      role = "group";
      setContext("SMUI:list:item:role", "checkbox");
    } else {
      role = "list";
      setContext("SMUI:list:item:role", void 0);
    }
  }
  if (addLayoutListener) {
    removeLayoutListener = addLayoutListener(layout);
  }
  onDestroy(() => {
    if (removeLayoutListener) {
      removeLayoutListener();
    }
  });
  function layout() {
    return instance.layout();
  }
  function setEnabled(...args) {
    return instance.setEnabled(...args);
  }
  function getTypeaheadInProgress() {
    return instance.isTypeaheadInProgress();
  }
  function getSelectedIndex() {
    return instance.getSelectedIndex();
  }
  function getElement() {
    return element.getElement();
  }
  if ($$props.use === void 0 && $$bindings.use && use !== void 0)
    $$bindings.use(use);
  if ($$props.class === void 0 && $$bindings.class && className !== void 0)
    $$bindings.class(className);
  if ($$props.nonInteractive === void 0 && $$bindings.nonInteractive && nonInteractive !== void 0)
    $$bindings.nonInteractive(nonInteractive);
  if ($$props.dense === void 0 && $$bindings.dense && dense !== void 0)
    $$bindings.dense(dense);
  if ($$props.textualList === void 0 && $$bindings.textualList && textualList !== void 0)
    $$bindings.textualList(textualList);
  if ($$props.avatarList === void 0 && $$bindings.avatarList && avatarList !== void 0)
    $$bindings.avatarList(avatarList);
  if ($$props.iconList === void 0 && $$bindings.iconList && iconList !== void 0)
    $$bindings.iconList(iconList);
  if ($$props.imageList === void 0 && $$bindings.imageList && imageList !== void 0)
    $$bindings.imageList(imageList);
  if ($$props.thumbnailList === void 0 && $$bindings.thumbnailList && thumbnailList !== void 0)
    $$bindings.thumbnailList(thumbnailList);
  if ($$props.videoList === void 0 && $$bindings.videoList && videoList !== void 0)
    $$bindings.videoList(videoList);
  if ($$props.twoLine === void 0 && $$bindings.twoLine && twoLine !== void 0)
    $$bindings.twoLine(twoLine);
  if ($$props.threeLine === void 0 && $$bindings.threeLine && threeLine !== void 0)
    $$bindings.threeLine(threeLine);
  if ($$props.vertical === void 0 && $$bindings.vertical && vertical !== void 0)
    $$bindings.vertical(vertical);
  if ($$props.wrapFocus === void 0 && $$bindings.wrapFocus && wrapFocus !== void 0)
    $$bindings.wrapFocus(wrapFocus);
  if ($$props.singleSelection === void 0 && $$bindings.singleSelection && singleSelection !== void 0)
    $$bindings.singleSelection(singleSelection);
  if ($$props.selectedIndex === void 0 && $$bindings.selectedIndex && selectedIndex !== void 0)
    $$bindings.selectedIndex(selectedIndex);
  if ($$props.radioList === void 0 && $$bindings.radioList && radioList !== void 0)
    $$bindings.radioList(radioList);
  if ($$props.checkList === void 0 && $$bindings.checkList && checkList !== void 0)
    $$bindings.checkList(checkList);
  if ($$props.hasTypeahead === void 0 && $$bindings.hasTypeahead && hasTypeahead !== void 0)
    $$bindings.hasTypeahead(hasTypeahead);
  if ($$props.radiolist === void 0 && $$bindings.radiolist && radiolist !== void 0)
    $$bindings.radiolist(radiolist);
  if ($$props.checklist === void 0 && $$bindings.checklist && checklist !== void 0)
    $$bindings.checklist(checklist);
  if ($$props.component === void 0 && $$bindings.component && component !== void 0)
    $$bindings.component(component);
  if ($$props.layout === void 0 && $$bindings.layout && layout !== void 0)
    $$bindings.layout(layout);
  if ($$props.setEnabled === void 0 && $$bindings.setEnabled && setEnabled !== void 0)
    $$bindings.setEnabled(setEnabled);
  if ($$props.getTypeaheadInProgress === void 0 && $$bindings.getTypeaheadInProgress && getTypeaheadInProgress !== void 0)
    $$bindings.getTypeaheadInProgress(getTypeaheadInProgress);
  if ($$props.getSelectedIndex === void 0 && $$bindings.getSelectedIndex && getSelectedIndex !== void 0)
    $$bindings.getSelectedIndex(getSelectedIndex);
  if ($$props.getElement === void 0 && $$bindings.getElement && getElement !== void 0)
    $$bindings.getElement(getElement);
  let $$settled;
  let $$rendered;
  do {
    $$settled = true;
    $$rendered = `${validate_component(component || missing_component, "svelte:component").$$render($$result, Object.assign({ use: [forwardEvents, ...use] }, {
      class: classMap({
        [className]: true,
        "mdc-deprecated-list": true,
        "mdc-deprecated-list--non-interactive": nonInteractive,
        "mdc-deprecated-list--dense": dense,
        "mdc-deprecated-list--textual-list": textualList,
        "mdc-deprecated-list--avatar-list": avatarList || selectionDialog,
        "mdc-deprecated-list--icon-list": iconList,
        "mdc-deprecated-list--image-list": imageList,
        "mdc-deprecated-list--thumbnail-list": thumbnailList,
        "mdc-deprecated-list--video-list": videoList,
        "mdc-deprecated-list--two-line": twoLine,
        "smui-list--three-line": threeLine && !twoLine
      })
    }, { role }, $$restProps, { this: element }), {
      this: ($$value) => {
        element = $$value;
        $$settled = false;
      }
    }, {
      default: () => `${slots.default ? slots.default({}) : ``}`
    })}`;
  } while (!$$settled);
  return $$rendered;
});
var Li = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let $$restProps = compute_rest_props($$props, ["use", "getElement"]);
  let { use = [] } = $$props;
  forwardEventsBuilder(get_current_component());
  let element = null;
  function getElement() {
    return element;
  }
  if ($$props.use === void 0 && $$bindings.use && use !== void 0)
    $$bindings.use(use);
  if ($$props.getElement === void 0 && $$bindings.getElement && getElement !== void 0)
    $$bindings.getElement(getElement);
  return `<li${spread([escape_object($$restProps)])}${add_attribute("this", element, 0)}>${slots.default ? slots.default({}) : ``}
</li>`;
});
var { Object: Object_1$4 } = globals;
var counter$2 = 0;
var Item = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let tabindex;
  let $$restProps = compute_rest_props($$props, [
    "use",
    "class",
    "style",
    "color",
    "nonInteractive",
    "ripple",
    "activated",
    "role",
    "selected",
    "disabled",
    "tabindex",
    "inputId",
    "href",
    "component",
    "getPrimaryText",
    "getElement"
  ]);
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let uninitializedValue = () => {
  };
  let { use = [] } = $$props;
  let { class: className = "" } = $$props;
  let { style = "" } = $$props;
  let { color = null } = $$props;
  let { nonInteractive = getContext("SMUI:list:nonInteractive") } = $$props;
  setContext("SMUI:list:nonInteractive", void 0);
  let { ripple = !nonInteractive } = $$props;
  let { activated = false } = $$props;
  let { role = getContext("SMUI:list:item:role") } = $$props;
  setContext("SMUI:list:item:role", void 0);
  let { selected = false } = $$props;
  let { disabled = false } = $$props;
  let { tabindex: tabindexProp = uninitializedValue } = $$props;
  let { inputId = "SMUI-form-field-list-" + counter$2++ } = $$props;
  let { href = null } = $$props;
  let element;
  let internalClasses = {};
  let internalStyles = {};
  let internalAttrs = {};
  let input;
  let nav = getContext("SMUI:list:item:nav");
  let { component = nav ? href ? A : Span : Li } = $$props;
  setContext("SMUI:generic:input:props", { id: inputId });
  setContext("SMUI:separator:context", void 0);
  onDestroy(() => {
  });
  function addClass(className2) {
    if (!internalClasses[className2]) {
      internalClasses[className2] = true;
    }
  }
  function removeClass(className2) {
    if (!(className2 in internalClasses) || internalClasses[className2]) {
      internalClasses[className2] = false;
    }
  }
  function addStyle(name, value) {
    if (internalStyles[name] != value) {
      if (value === "" || value == null) {
        delete internalStyles[name];
        internalStyles = internalStyles;
      } else {
        internalStyles[name] = value;
      }
    }
  }
  function getPrimaryText() {
    const element2 = getElement();
    const primaryText = element2.querySelector(".mdc-deprecated-list-item__primary-text");
    if (primaryText) {
      return primaryText.textContent;
    }
    const text = element2.querySelector(".mdc-deprecated-list-item__text");
    if (text) {
      return text.textContent;
    }
    return element2.textContent;
  }
  function getElement() {
    return element.getElement();
  }
  if ($$props.use === void 0 && $$bindings.use && use !== void 0)
    $$bindings.use(use);
  if ($$props.class === void 0 && $$bindings.class && className !== void 0)
    $$bindings.class(className);
  if ($$props.style === void 0 && $$bindings.style && style !== void 0)
    $$bindings.style(style);
  if ($$props.color === void 0 && $$bindings.color && color !== void 0)
    $$bindings.color(color);
  if ($$props.nonInteractive === void 0 && $$bindings.nonInteractive && nonInteractive !== void 0)
    $$bindings.nonInteractive(nonInteractive);
  if ($$props.ripple === void 0 && $$bindings.ripple && ripple !== void 0)
    $$bindings.ripple(ripple);
  if ($$props.activated === void 0 && $$bindings.activated && activated !== void 0)
    $$bindings.activated(activated);
  if ($$props.role === void 0 && $$bindings.role && role !== void 0)
    $$bindings.role(role);
  if ($$props.selected === void 0 && $$bindings.selected && selected !== void 0)
    $$bindings.selected(selected);
  if ($$props.disabled === void 0 && $$bindings.disabled && disabled !== void 0)
    $$bindings.disabled(disabled);
  if ($$props.tabindex === void 0 && $$bindings.tabindex && tabindexProp !== void 0)
    $$bindings.tabindex(tabindexProp);
  if ($$props.inputId === void 0 && $$bindings.inputId && inputId !== void 0)
    $$bindings.inputId(inputId);
  if ($$props.href === void 0 && $$bindings.href && href !== void 0)
    $$bindings.href(href);
  if ($$props.component === void 0 && $$bindings.component && component !== void 0)
    $$bindings.component(component);
  if ($$props.getPrimaryText === void 0 && $$bindings.getPrimaryText && getPrimaryText !== void 0)
    $$bindings.getPrimaryText(getPrimaryText);
  if ($$props.getElement === void 0 && $$bindings.getElement && getElement !== void 0)
    $$bindings.getElement(getElement);
  let $$settled;
  let $$rendered;
  do {
    $$settled = true;
    tabindex = tabindexProp == uninitializedValue ? !nonInteractive && !disabled && (selected || input) && "0" || "-1" : tabindexProp;
    $$rendered = `${validate_component(component || missing_component, "svelte:component").$$render($$result, Object_1$4.assign({
      use: [
        ...nonInteractive ? [] : [
          [
            Ripple,
            {
              ripple: !input,
              unbounded: false,
              color: (activated || selected) && color == null ? "primary" : color,
              disabled,
              addClass,
              removeClass,
              addStyle
            }
          ]
        ],
        forwardEvents,
        ...use
      ]
    }, {
      class: classMap({
        [className]: true,
        "mdc-deprecated-list-item": true,
        "mdc-deprecated-list-item--activated": activated,
        "mdc-deprecated-list-item--selected": selected,
        "mdc-deprecated-list-item--disabled": disabled,
        "mdc-menu-item--selected": !nav && role === "menuitem" && selected,
        "smui-menu-item--non-interactive": nonInteractive,
        ...internalClasses
      })
    }, {
      style: Object.entries(internalStyles).map(([name, value]) => `${name}: ${value};`).concat([style]).join(" ")
    }, nav && activated ? { "aria-current": "page" } : {}, !nav ? { role } : {}, !nav && role === "option" ? {
      "aria-selected": selected ? "true" : "false"
    } : {}, !nav && (role === "radio" || role === "checkbox") ? {
      "aria-checked": "false"
    } : {}, !nav ? {
      "aria-disabled": disabled ? "true" : "false"
    } : {}, { tabindex }, { href }, internalAttrs, $$restProps, { this: element }), {
      this: ($$value) => {
        element = $$value;
        $$settled = false;
      }
    }, {
      default: () => `${ripple ? `<span class="${"mdc-deprecated-list-item__ripple"}"></span>` : ``}${slots.default ? slots.default({}) : ``}`
    })}`;
  } while (!$$settled);
  return $$rendered;
});
var Text = classAdderBuilder({
  class: "mdc-deprecated-list-item__text",
  component: Span
});
classAdderBuilder({
  class: "mdc-deprecated-list-item__primary-text",
  component: Span
});
classAdderBuilder({
  class: "mdc-deprecated-list-item__secondary-text",
  component: Span
});
var Graphic = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let $$restProps = compute_rest_props($$props, ["use", "class", "getElement"]);
  forwardEventsBuilder(get_current_component());
  let { use = [] } = $$props;
  let { class: className = "" } = $$props;
  let element;
  let menuSelectionGroup = getContext("SMUI:list:graphic:menu-selection-group");
  function getElement() {
    return element;
  }
  if ($$props.use === void 0 && $$bindings.use && use !== void 0)
    $$bindings.use(use);
  if ($$props.class === void 0 && $$bindings.class && className !== void 0)
    $$bindings.class(className);
  if ($$props.getElement === void 0 && $$bindings.getElement && getElement !== void 0)
    $$bindings.getElement(getElement);
  return `<span${spread([
    {
      class: escape_attribute_value(classMap({
        [className]: true,
        "mdc-deprecated-list-item__graphic": true,
        "mdc-menu__selection-group-icon": menuSelectionGroup
      }))
    },
    escape_object($$restProps)
  ])}${add_attribute("this", element, 0)}>${slots.default ? slots.default({}) : ``}</span>`;
});
classAdderBuilder({
  class: "mdc-deprecated-list-item__meta",
  component: Span
});
classAdderBuilder({
  class: "mdc-deprecated-list-group",
  component: Div
});
var H3 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let $$restProps = compute_rest_props($$props, ["use", "getElement"]);
  let { use = [] } = $$props;
  forwardEventsBuilder(get_current_component());
  let element = null;
  function getElement() {
    return element;
  }
  if ($$props.use === void 0 && $$bindings.use && use !== void 0)
    $$bindings.use(use);
  if ($$props.getElement === void 0 && $$bindings.getElement && getElement !== void 0)
    $$bindings.getElement(getElement);
  return `<h3${spread([escape_object($$restProps)])}${add_attribute("this", element, 0)}>${slots.default ? slots.default({}) : ``}
</h3>`;
});
var Subheader = classAdderBuilder({
  class: "mdc-deprecated-list-group__subheader",
  component: H3
});
var Hr = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let $$restProps = compute_rest_props($$props, ["use", "getElement"]);
  let { use = [] } = $$props;
  forwardEventsBuilder(get_current_component());
  let element = null;
  function getElement() {
    return element;
  }
  if ($$props.use === void 0 && $$bindings.use && use !== void 0)
    $$bindings.use(use);
  if ($$props.getElement === void 0 && $$bindings.getElement && getElement !== void 0)
    $$bindings.getElement(getElement);
  return `<hr${spread([escape_object($$restProps)])}${add_attribute("this", element, 0)}>
${slots.default ? slots.default({}) : ``}`;
});
var Separator = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let $$restProps = compute_rest_props($$props, [
    "use",
    "class",
    "padded",
    "inset",
    "insetLeading",
    "insetTrailing",
    "insetPadding",
    "component",
    "getElement"
  ]);
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { use = [] } = $$props;
  let { class: className = "" } = $$props;
  let { padded = false } = $$props;
  let { inset = false } = $$props;
  let { insetLeading = false } = $$props;
  let { insetTrailing = false } = $$props;
  let { insetPadding = false } = $$props;
  let element;
  let nav = getContext("SMUI:list:item:nav");
  let context = getContext("SMUI:separator:context");
  let { component = nav || context !== "list" ? Hr : Li } = $$props;
  function getElement() {
    return element.getElement();
  }
  if ($$props.use === void 0 && $$bindings.use && use !== void 0)
    $$bindings.use(use);
  if ($$props.class === void 0 && $$bindings.class && className !== void 0)
    $$bindings.class(className);
  if ($$props.padded === void 0 && $$bindings.padded && padded !== void 0)
    $$bindings.padded(padded);
  if ($$props.inset === void 0 && $$bindings.inset && inset !== void 0)
    $$bindings.inset(inset);
  if ($$props.insetLeading === void 0 && $$bindings.insetLeading && insetLeading !== void 0)
    $$bindings.insetLeading(insetLeading);
  if ($$props.insetTrailing === void 0 && $$bindings.insetTrailing && insetTrailing !== void 0)
    $$bindings.insetTrailing(insetTrailing);
  if ($$props.insetPadding === void 0 && $$bindings.insetPadding && insetPadding !== void 0)
    $$bindings.insetPadding(insetPadding);
  if ($$props.component === void 0 && $$bindings.component && component !== void 0)
    $$bindings.component(component);
  if ($$props.getElement === void 0 && $$bindings.getElement && getElement !== void 0)
    $$bindings.getElement(getElement);
  let $$settled;
  let $$rendered;
  do {
    $$settled = true;
    $$rendered = `${validate_component(component || missing_component, "svelte:component").$$render($$result, Object.assign({ use: [forwardEvents, ...use] }, {
      class: classMap({
        [className]: true,
        "mdc-deprecated-list-divider": true,
        "mdc-deprecated-list-divider--padded": padded,
        "mdc-deprecated-list-divider--inset": inset,
        "mdc-deprecated-list-divider--inset-leading": insetLeading,
        "mdc-deprecated-list-divider--inset-trailing": insetTrailing,
        "mdc-deprecated-list-divider--inset-padding": insetPadding
      })
    }, { role: "separator" }, $$restProps, { this: element }), {
      this: ($$value) => {
        element = $$value;
        $$settled = false;
      }
    }, {})}`;
  } while (!$$settled);
  return $$rendered;
});
var css$I = {
  code: ".menuIcon{position:absolute;top:15px;left:15px;font-size:2em;color:#888;padding:6px;cursor:pointer}.menuIcon:hover{color:#00316b}.nav-drawer{z-index:5;top:0;left:0}.nav-item{color:#858585 !important}.nav-back.svelte-15mzw62{position:fixed;z-index:4;width:100%;width:100vw;height:100%;height:100vh;top:0;left:0;background-color:rgba(0, 0, 0, 0.32);transition:all 0.7s}",
  map: `{"version":3,"file":"NavSmall.svelte","sources":["NavSmall.svelte"],"sourcesContent":["<script>\\n\\timport Drawer, {\\n\\t  Content,\\n\\t  Header,\\n\\t  Title,\\n\\t} from '@smui/drawer';\\n\\timport { Icon } from '@smui/tab';\\n  \\timport List, { Item, Text, Graphic, Separator, Subheader } from '@smui/list';\\n\\timport { goto, prefetch } from '$app/navigation';\\n\\timport { leagueName } from '$lib/utils/helper';\\n\\timport { enableBlog, managers } from '$lib/utils/leagueInfo';\\n\\t\\n\\texport let active, tabs;\\n\\n\\tlet open = false;\\n\\n\\tconst selectTab = (tab) => {\\n\\t\\tactive = tab;\\n\\t\\topen = false;\\n\\t\\tgoto(tab.dest);\\n\\t}\\n<\/script>\\n\\n<style>\\n\\t:global(.menuIcon) {\\n\\t\\tposition: absolute;\\n\\t\\ttop: 15px;\\n\\t\\tleft: 15px;\\n\\t\\tfont-size: 2em;\\n\\t\\tcolor: #888;\\n\\t\\tpadding: 6px;\\n\\t\\tcursor: pointer;\\n\\t}\\n\\n\\t:global(.menuIcon:hover) {\\n\\t\\tcolor: #00316b;\\n\\t}\\n\\n\\t:global(.nav-drawer) {\\n\\t\\tz-index: 5;\\n\\t\\ttop: 0;\\n\\t\\tleft: 0;\\n\\t}\\n\\n\\t:global(.nav-item) {\\n\\t\\tcolor: #858585 !important;\\n\\t}\\n\\n\\t.nav-back {\\n\\t\\tposition: fixed;\\n\\t\\tz-index: 4;\\n\\t\\twidth: 100%;\\n\\t\\twidth: 100vw;\\n\\t\\theight: 100%;\\n\\t\\theight: 100vh;\\n\\t\\ttop: 0;\\n\\t\\tleft: 0;\\n\\t\\tbackground-color: rgba(0, 0, 0, 0.32);\\n\\t\\ttransition: all 0.7s;\\n\\t}\\n</style>\\n\\n<Icon class=\\"material-icons menuIcon\\" on:click={() => (open = true)}>menu</Icon>\\n\\n<div class=\\"nav-back\\" style=\\"pointer-events: {open ? \\"visible\\" : \\"none\\"}; opacity: {open ? 1 : 0};\\" on:click={() => (open = false)}/>\\n\\n<Drawer variant=\\"modal\\" class=\\"nav-drawer\\" fixed={true} bind:open>\\n\\t<Header>\\n\\t\\t<Title>{leagueName}</Title>\\n\\t</Header>\\n\\t<Content>\\n\\t\\t<List>\\n\\t\\t\\t{#each tabs as tab}\\n\\t\\t\\t\\t{#if !tab.nest && (tab.label != 'Blog' || (tab.label == 'Blog' && enableBlog))}\\n\\t\\t\\t\\t\\t<Item href=\\"javascript:void(0)\\" on:click={() => selectTab(tab)} on:touchstart={() => prefetch(tab.dest)} on:mouseover={() => prefetch(tab.dest)} activated={active == tab.dest} >\\n\\t\\t\\t\\t\\t\\t<Graphic class=\\"material-icons{active == tab.dest ? \\"\\" : \\" nav-item\\"}\\" aria-hidden=\\"true\\">{tab.icon}</Graphic>\\n\\t\\t\\t\\t\\t\\t<Text class=\\"{active == tab.dest ? \\"\\" : \\"nav-item\\"}\\">{tab.label}</Text>\\n\\t\\t\\t\\t\\t</Item>\\n\\t\\t\\t\\t{/if}\\n\\t\\t\\t{/each}\\n\\t\\t\\t{#each tabs as tab}\\n\\t\\t\\t\\t{#if tab.nest}\\n\\t\\t\\t\\t\\t<Separator />\\n\\t\\t\\t\\t\\t<Subheader>{tab.label}</Subheader>\\n\\t\\t\\t\\t\\t{#each tab.children as subTab}\\n\\t\\t\\t\\t\\t\\t{#if subTab.label == 'Managers'}\\n\\t\\t\\t\\t\\t\\t\\t{#if managers.length}\\n\\t\\t\\t\\t\\t\\t\\t\\t<Item href=\\"javascript:void(0)\\" on:click={() => selectTab(subTab)} activated={active == subTab.dest}  on:touchstart={() => prefetch(subTab.dest)} on:mouseover={() => prefetch(subTab.dest)}>\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t<Graphic class=\\"material-icons{active == subTab.dest ? \\"\\" : \\" nav-item\\"}\\" aria-hidden=\\"true\\">{subTab.icon}</Graphic>\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t<Text class=\\"{active == subTab.dest ? \\"\\" : \\"nav-item\\"}\\">{subTab.label}</Text>\\n\\t\\t\\t\\t\\t\\t\\t\\t</Item>\\n\\t\\t\\t\\t\\t\\t\\t{/if}\\n\\t\\t\\t\\t\\t\\t{:else}\\n\\t\\t\\t\\t\\t\\t\\t<Item href=\\"javascript:void(0)\\" on:click={() => selectTab(subTab)} activated={active == subTab.dest}  on:touchstart={() => {if(subTab.label != 'Go to Sleeper') prefetch(subTab.dest)}} on:mouseover={() => {if(subTab.label != 'Go to Sleeper') prefetch(subTab.dest)}}>\\n\\t\\t\\t\\t\\t\\t\\t\\t<Graphic class=\\"material-icons{active == subTab.dest ? \\"\\" : \\" nav-item\\"}\\" aria-hidden=\\"true\\">{subTab.icon}</Graphic>\\n\\t\\t\\t\\t\\t\\t\\t\\t<Text class=\\"{active == subTab.dest ? \\"\\" : \\"nav-item\\"}\\">{subTab.label}</Text>\\n\\t\\t\\t\\t\\t\\t\\t</Item>\\n\\t\\t\\t\\t\\t\\t{/if}\\n\\t\\t\\t\\t\\t{/each}\\n\\t\\t\\t\\t{/if}\\n\\t\\t\\t{/each}\\n\\t\\t</List>\\n\\t</Content>\\n  </Drawer>\\n\\t\\n"],"names":[],"mappings":"AAwBS,SAAS,AAAE,CAAC,AACnB,QAAQ,CAAE,QAAQ,CAClB,GAAG,CAAE,IAAI,CACT,IAAI,CAAE,IAAI,CACV,SAAS,CAAE,GAAG,CACd,KAAK,CAAE,IAAI,CACX,OAAO,CAAE,GAAG,CACZ,MAAM,CAAE,OAAO,AAChB,CAAC,AAEO,eAAe,AAAE,CAAC,AACzB,KAAK,CAAE,OAAO,AACf,CAAC,AAEO,WAAW,AAAE,CAAC,AACrB,OAAO,CAAE,CAAC,CACV,GAAG,CAAE,CAAC,CACN,IAAI,CAAE,CAAC,AACR,CAAC,AAEO,SAAS,AAAE,CAAC,AACnB,KAAK,CAAE,OAAO,CAAC,UAAU,AAC1B,CAAC,AAED,SAAS,eAAC,CAAC,AACV,QAAQ,CAAE,KAAK,CACf,OAAO,CAAE,CAAC,CACV,KAAK,CAAE,IAAI,CACX,KAAK,CAAE,KAAK,CACZ,MAAM,CAAE,IAAI,CACZ,MAAM,CAAE,KAAK,CACb,GAAG,CAAE,CAAC,CACN,IAAI,CAAE,CAAC,CACP,gBAAgB,CAAE,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CACrC,UAAU,CAAE,GAAG,CAAC,IAAI,AACrB,CAAC"}`
};
var NavSmall = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let { active, tabs: tabs2 } = $$props;
  let open = false;
  if ($$props.active === void 0 && $$bindings.active && active !== void 0)
    $$bindings.active(active);
  if ($$props.tabs === void 0 && $$bindings.tabs && tabs2 !== void 0)
    $$bindings.tabs(tabs2);
  $$result.css.add(css$I);
  let $$settled;
  let $$rendered;
  do {
    $$settled = true;
    $$rendered = `${validate_component(CommonIcon, "Icon").$$render($$result, { class: "material-icons menuIcon" }, {}, { default: () => `menu` })}

<div class="${"nav-back svelte-15mzw62"}" style="${"pointer-events: " + escape(open ? "visible" : "none") + "; opacity: " + escape(open ? 1 : 0) + ";"}"></div>

${validate_component(Drawer, "Drawer").$$render($$result, {
      variant: "modal",
      class: "nav-drawer",
      fixed: true,
      open
    }, {
      open: ($$value) => {
        open = $$value;
        $$settled = false;
      }
    }, {
      default: () => `${validate_component(Header, "Header").$$render($$result, {}, {}, {
        default: () => `${validate_component(Title$1, "Title").$$render($$result, {}, {}, { default: () => `${escape(leagueName)}` })}`
      })}
	${validate_component(Content$1, "Content").$$render($$result, {}, {}, {
        default: () => `${validate_component(List, "List").$$render($$result, {}, {}, {
          default: () => `${each(tabs2, (tab) => `${!tab.nest && (tab.label != "Blog" || tab.label == "Blog" && enableBlog) ? `${validate_component(Item, "Item").$$render($$result, {
            href: "javascript:void(0)",
            activated: active == tab.dest
          }, {}, {
            default: () => `${validate_component(Graphic, "Graphic").$$render($$result, {
              class: "material-icons" + (active == tab.dest ? "" : " nav-item"),
              "aria-hidden": "true"
            }, {}, { default: () => `${escape(tab.icon)}` })}
						${validate_component(Text, "Text").$$render($$result, {
              class: active == tab.dest ? "" : "nav-item"
            }, {}, { default: () => `${escape(tab.label)}` })}
					`
          })}` : ``}`)}
			${each(tabs2, (tab) => `${tab.nest ? `${validate_component(Separator, "Separator").$$render($$result, {}, {}, {})}
					${validate_component(Subheader, "Subheader").$$render($$result, {}, {}, { default: () => `${escape(tab.label)}` })}
					${each(tab.children, (subTab) => `${subTab.label == "Managers" ? `${managers.length ? `${validate_component(Item, "Item").$$render($$result, {
            href: "javascript:void(0)",
            activated: active == subTab.dest
          }, {}, {
            default: () => `${validate_component(Graphic, "Graphic").$$render($$result, {
              class: "material-icons" + (active == subTab.dest ? "" : " nav-item"),
              "aria-hidden": "true"
            }, {}, { default: () => `${escape(subTab.icon)}` })}
									${validate_component(Text, "Text").$$render($$result, {
              class: active == subTab.dest ? "" : "nav-item"
            }, {}, { default: () => `${escape(subTab.label)}` })}
								`
          })}` : ``}` : `${validate_component(Item, "Item").$$render($$result, {
            href: "javascript:void(0)",
            activated: active == subTab.dest
          }, {}, {
            default: () => `${validate_component(Graphic, "Graphic").$$render($$result, {
              class: "material-icons" + (active == subTab.dest ? "" : " nav-item"),
              "aria-hidden": "true"
            }, {}, { default: () => `${escape(subTab.icon)}` })}
								${validate_component(Text, "Text").$$render($$result, {
              class: active == subTab.dest ? "" : "nav-item"
            }, {}, { default: () => `${escape(subTab.label)}` })}
							`
          })}`}`)}` : ``}`)}`
        })}`
      })}`
    })}`;
  } while (!$$settled);
  return $$rendered;
});
var TabScroller = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let $$restProps = compute_rest_props($$props, [
    "use",
    "class",
    "align",
    "scrollArea$use",
    "scrollArea$class",
    "scrollContent$use",
    "scrollContent$class",
    "getScrollPosition",
    "getScrollContentWidth",
    "incrementScroll",
    "scrollTo",
    "getElement"
  ]);
  forwardEventsBuilder(get_current_component());
  let { use = [] } = $$props;
  let { class: className = "" } = $$props;
  let { align = null } = $$props;
  let { scrollArea$use = [] } = $$props;
  let { scrollArea$class = "" } = $$props;
  let { scrollContent$use = [] } = $$props;
  let { scrollContent$class = "" } = $$props;
  let element;
  let instance;
  let scrollArea;
  let scrollContent;
  let internalClasses = {};
  let scrollAreaClasses = {};
  let scrollAreaStyles = {};
  let scrollContentStyles = {};
  function getScrollPosition() {
    return instance.getScrollPosition();
  }
  function getScrollContentWidth() {
    return scrollContent.offsetWidth;
  }
  function incrementScroll(scrollXIncrement) {
    instance.incrementScroll(scrollXIncrement);
  }
  function scrollTo(scrollX) {
    instance.scrollTo(scrollX);
  }
  function getElement() {
    return element;
  }
  if ($$props.use === void 0 && $$bindings.use && use !== void 0)
    $$bindings.use(use);
  if ($$props.class === void 0 && $$bindings.class && className !== void 0)
    $$bindings.class(className);
  if ($$props.align === void 0 && $$bindings.align && align !== void 0)
    $$bindings.align(align);
  if ($$props.scrollArea$use === void 0 && $$bindings.scrollArea$use && scrollArea$use !== void 0)
    $$bindings.scrollArea$use(scrollArea$use);
  if ($$props.scrollArea$class === void 0 && $$bindings.scrollArea$class && scrollArea$class !== void 0)
    $$bindings.scrollArea$class(scrollArea$class);
  if ($$props.scrollContent$use === void 0 && $$bindings.scrollContent$use && scrollContent$use !== void 0)
    $$bindings.scrollContent$use(scrollContent$use);
  if ($$props.scrollContent$class === void 0 && $$bindings.scrollContent$class && scrollContent$class !== void 0)
    $$bindings.scrollContent$class(scrollContent$class);
  if ($$props.getScrollPosition === void 0 && $$bindings.getScrollPosition && getScrollPosition !== void 0)
    $$bindings.getScrollPosition(getScrollPosition);
  if ($$props.getScrollContentWidth === void 0 && $$bindings.getScrollContentWidth && getScrollContentWidth !== void 0)
    $$bindings.getScrollContentWidth(getScrollContentWidth);
  if ($$props.incrementScroll === void 0 && $$bindings.incrementScroll && incrementScroll !== void 0)
    $$bindings.incrementScroll(incrementScroll);
  if ($$props.scrollTo === void 0 && $$bindings.scrollTo && scrollTo !== void 0)
    $$bindings.scrollTo(scrollTo);
  if ($$props.getElement === void 0 && $$bindings.getElement && getElement !== void 0)
    $$bindings.getElement(getElement);
  return `<div${spread([
    {
      class: escape_attribute_value(classMap({
        [className]: true,
        "mdc-tab-scroller": true,
        "mdc-tab-scroller--align-start": align === "start",
        "mdc-tab-scroller--align-end": align === "end",
        "mdc-tab-scroller--align-center": align === "center",
        ...internalClasses
      }))
    },
    escape_object(exclude($$restProps, ["scrollArea$", "scrollContent$"]))
  ])}${add_attribute("this", element, 0)}><div${spread([
    {
      class: escape_attribute_value(classMap({
        [scrollArea$class]: true,
        "mdc-tab-scroller__scroll-area": true,
        ...scrollAreaClasses
      }))
    },
    {
      style: escape_attribute_value(Object.entries(scrollAreaStyles).map(([name, value]) => `${name}: ${value};`).join(" "))
    },
    escape_object(prefixFilter($$restProps, "scrollArea$"))
  ])}${add_attribute("this", scrollArea, 0)}><div${spread([
    {
      class: escape_attribute_value(classMap({
        [scrollContent$class]: true,
        "mdc-tab-scroller__scroll-content": true
      }))
    },
    {
      style: escape_attribute_value(Object.entries(scrollContentStyles).map(([name, value]) => `${name}: ${value};`).join(" "))
    },
    escape_object(prefixFilter($$restProps, "scrollContent$"))
  ])}${add_attribute("this", scrollContent, 0)}>${slots.default ? slots.default({}) : ``}</div></div>
</div>`;
});
var { Object: Object_1$3 } = globals;
var TabBar = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let $$restProps = compute_rest_props($$props, [
    "use",
    "class",
    "tabs",
    "key",
    "focusOnActivate",
    "focusOnProgrammatic",
    "useAutomaticActivation",
    "active",
    "scrollIntoView",
    "getElement"
  ]);
  forwardEventsBuilder(get_current_component());
  let { use = [] } = $$props;
  let { class: className = "" } = $$props;
  let { tabs: tabs2 = [] } = $$props;
  let { key = (tab) => tab } = $$props;
  let { focusOnActivate = true } = $$props;
  let { focusOnProgrammatic = false } = $$props;
  let { useAutomaticActivation = true } = $$props;
  let { active = null } = $$props;
  let element;
  let instance;
  let tabScroller;
  let activeIndex = tabs2.indexOf(active);
  let tabAccessorMap = {};
  let tabAccessorWeakMap = new WeakMap();
  setContext("SMUI:tab:focusOnActivate", focusOnActivate);
  setContext("SMUI:tab:initialActive", active);
  function scrollIntoView(index2) {
    instance.scrollIntoView(index2);
  }
  function getElement() {
    return element;
  }
  if ($$props.use === void 0 && $$bindings.use && use !== void 0)
    $$bindings.use(use);
  if ($$props.class === void 0 && $$bindings.class && className !== void 0)
    $$bindings.class(className);
  if ($$props.tabs === void 0 && $$bindings.tabs && tabs2 !== void 0)
    $$bindings.tabs(tabs2);
  if ($$props.key === void 0 && $$bindings.key && key !== void 0)
    $$bindings.key(key);
  if ($$props.focusOnActivate === void 0 && $$bindings.focusOnActivate && focusOnActivate !== void 0)
    $$bindings.focusOnActivate(focusOnActivate);
  if ($$props.focusOnProgrammatic === void 0 && $$bindings.focusOnProgrammatic && focusOnProgrammatic !== void 0)
    $$bindings.focusOnProgrammatic(focusOnProgrammatic);
  if ($$props.useAutomaticActivation === void 0 && $$bindings.useAutomaticActivation && useAutomaticActivation !== void 0)
    $$bindings.useAutomaticActivation(useAutomaticActivation);
  if ($$props.active === void 0 && $$bindings.active && active !== void 0)
    $$bindings.active(active);
  if ($$props.scrollIntoView === void 0 && $$bindings.scrollIntoView && scrollIntoView !== void 0)
    $$bindings.scrollIntoView(scrollIntoView);
  if ($$props.getElement === void 0 && $$bindings.getElement && getElement !== void 0)
    $$bindings.getElement(getElement);
  let $$settled;
  let $$rendered;
  do {
    $$settled = true;
    {
      if (active !== tabs2[activeIndex]) {
        activeIndex = tabs2.indexOf(active);
      }
    }
    {
      if (tabs2.length) {
        const accessor = tabs2[0] instanceof Object ? tabAccessorWeakMap.get(tabs2[0]) : tabAccessorMap[tabs2[0]];
        if (accessor) {
          accessor.forceAccessible(activeIndex === -1);
        }
      }
    }
    $$rendered = `<div${spread([
      {
        class: escape_attribute_value(classMap({ [className]: true, "mdc-tab-bar": true }))
      },
      { role: "tablist" },
      escape_object(exclude($$restProps, ["tabScroller$"]))
    ])}${add_attribute("this", element, 0)}>${validate_component(TabScroller, "TabScroller").$$render($$result, Object_1$3.assign(prefixFilter($$restProps, "tabScroller$"), { this: tabScroller }), {
      this: ($$value) => {
        tabScroller = $$value;
        $$settled = false;
      }
    }, {
      default: () => `${each(tabs2, (tab, i) => `${slots.default ? slots.default({ tab }) : ``}`)}`
    })}
</div>`;
  } while (!$$settled);
  return $$rendered;
});
var css$H = {
  code: ".navBar{display:inline-flex;position:relative;justify-content:center}.navBar .material-icons{font-size:1.8em;height:25px;width:22px}.parent.svelte-1wryr23{position:relative}.subMenu.svelte-1wryr23{overflow-y:hidden;display:block;position:absolute;z-index:5;background-color:var(--fff);transition:all 0.4s}.overlay.svelte-1wryr23{display:block;position:absolute;top:0;left:0;width:100%;height:100%;height:100vh;z-index:4}.mdc-deprecated-list{padding:0}.subText{font-size:0.8em}.dontDisplay{display:none}",
  map: `{"version":3,"file":"NavLarge.svelte","sources":["NavLarge.svelte"],"sourcesContent":["<script>\\n\\timport Tab, { Icon, Label } from '@smui/tab';\\n\\timport List, { Item, Graphic, Text, Separator } from '@smui/list';\\n\\timport TabBar from '@smui/tab-bar';\\n\\timport { goto, prefetch } from '$app/navigation';\\n\\timport { enableBlog, managers } from '$lib/utils/leagueInfo';\\n\\n\\texport let active, tabs;\\n\\n\\tlet activeTab = active;\\n\\n\\tlet display;\\n\\tlet el, width, height, left, top;\\n\\n\\tconst sizeSubMenu = (w) => {\\n\\t\\ttop = el?.getBoundingClientRect() ? el?.getBoundingClientRect().top  : 0;\\n\\t\\tconst bottom = el?.getBoundingClientRect() ? el?.getBoundingClientRect().bottom  : 0;\\n\\n\\t\\theight = bottom - top + 1;\\n\\n\\t\\tleft = el?.getBoundingClientRect() ? el?.getBoundingClientRect().left  : 0;\\n\\t\\tconst right = el?.getBoundingClientRect() ? el?.getBoundingClientRect().right  : 0;\\n\\n\\t\\twidth = right - left;\\n\\t}\\n\\n\\tlet innerWidth;\\n\\n\\t$: sizeSubMenu(innerWidth);\\n\\n\\tconst open = (close = false) => {\\n\\t\\tif(close) {\\n\\t\\t\\tsetTimeout(() => {\\n\\t\\t\\t\\tactive = activeTab;\\n\\t\\t\\t}, 500)\\n\\t\\t} else {\\n\\t\\t\\tactiveTab = active;\\n\\t\\t}\\n\\t\\tdisplay = !display;\\n\\t}\\n\\n\\tconst subGoto = (dest) => {\\n\\t\\topen(false);\\n\\t\\tgoto(dest);\\n\\t}\\n\\n\\tlet tabChildren = []\\n\\n\\tfor(const tab of tabs) {\\n\\t\\tif(tab.nest) {\\n\\t\\t\\ttabChildren = tab.children;\\n\\t\\t}\\n\\t}\\n\\n<\/script>\\n\\n<svelte:window bind:innerWidth={innerWidth} />\\n\\n<style>\\n    :global(.navBar) {\\n\\t\\tdisplay: inline-flex;\\n\\t\\tposition: relative;\\n    \\tjustify-content: center;\\n    }\\n\\n\\t:global(.navBar .material-icons) {\\n\\t\\tfont-size: 1.8em;\\n\\t\\theight: 25px;\\n\\t\\twidth: 22px;\\n\\t}\\n\\n\\t.parent {\\n\\t\\tposition: relative;\\n\\t}\\n\\n\\t.subMenu {\\n\\t\\toverflow-y: hidden;\\n\\t\\tdisplay: block;\\n\\t\\tposition: absolute;\\n\\t\\tz-index: 5;\\n\\t\\tbackground-color: var(--fff);\\n\\t\\ttransition: all 0.4s;\\n\\t}\\n\\n\\t.overlay {\\n\\t\\tdisplay: block;\\n\\t\\tposition: absolute;\\n\\t\\ttop: 0;\\n\\t\\tleft: 0;\\n\\t\\twidth: 100%;\\n\\t\\theight: 100%;\\n\\t\\theight: 100vh;\\n\\t\\tz-index: 4;\\n\\t}\\n\\n\\t:global(.mdc-deprecated-list) {\\n\\t\\tpadding: 0;\\n\\t}\\n\\n\\t:global(.subText) {\\n\\t\\tfont-size: 0.8em;\\n\\t}\\n\\n\\t:global(.dontDisplay) {\\n\\t\\tdisplay: none;\\n\\t}\\n</style>\\n\\n<div class=\\"overlay\\" style=\\"display: {display ? \\"block\\" : \\"none\\"};\\" on:click={() => open(true)} />\\n\\n<div class=\\"parent\\">\\n\\t<TabBar class=\\"navBar\\" {tabs} let:tab bind:active>\\n\\t\\t{#if tab.nest}\\n\\t\\t\\t<div bind:this={el}>\\n\\t\\t\\t\\t<Tab\\n\\t\\t\\t\\t\\t{tab}\\n\\t\\t\\t\\t\\ton:click={() => open(display)}\\n\\t\\t\\t\\t\\tminWidth\\n\\t\\t\\t\\t>\\n\\t\\t\\t\\t\\t<Icon class=\\"material-icons\\">{tab.icon}</Icon>\\n\\t\\t\\t\\t\\t<Label>{tab.label}</Label>\\n\\t\\t\\t\\t</Tab>\\n\\t\\t\\t</div>\\n\\t\\t{:else}\\n\\t\\t\\t<Tab\\n\\t\\t\\t\\tclass=\\"{tab.label == 'Blog' && !enableBlog ? 'dontDisplay' : ''}\\"\\n\\t\\t\\t\\t{tab}\\n\\t\\t\\t\\ton:touchstart={() => prefetch(tab.dest)}\\n\\t\\t\\t\\ton:mouseover={() => prefetch(tab.dest)}\\n\\t\\t\\t\\ton:click={() => goto(tab.dest)}\\n\\t\\t\\t\\tminWidth\\n\\t\\t\\t>\\n\\t\\t\\t\\t<Icon class=\\"material-icons\\">{tab.icon}</Icon>\\n\\t\\t\\t\\t<Label>{tab.label}</Label>\\n\\t\\t\\t</Tab>\\n\\t\\t{/if}\\n\\t</TabBar>\\n\\t<div class=\\"subMenu\\" style=\\"max-height: {display ? 49 * tabChildren.length - 1 - (managers.length ? 0 : 48) : 0}px; width: {width}px; top: {height}px; left: {left}px; box-shadow: 0 0 {display ? \\"3px\\" : \\"0\\"} 0 #00316b; border: {display ? \\"1px\\" : \\"0\\"} solid #00316b; border-top: none;\\">\\n\\t\\t<List>\\n\\t\\t\\t{#each tabChildren as subTab, ix}\\n\\t\\t\\t\\t{#if subTab.label == 'Managers'}\\n\\t\\t\\t\\t\\t<Item class=\\"{managers.length ? '' : 'dontDisplay'}\\" on:SMUI:action={() => subGoto(subTab.dest)} on:touchstart={() => prefetch(subTab.dest)} on:mouseover={() => prefetch(subTab.dest)}>\\n\\t\\t\\t\\t\\t\\t<Graphic class=\\"material-icons\\">{subTab.icon}</Graphic>\\n\\t\\t\\t\\t\\t\\t<Text class=\\"subText\\">{subTab.label}</Text>\\n\\t\\t\\t\\t\\t</Item>\\n\\t\\t\\t\\t\\t{#if ix != tabChildren.length - 1}\\n\\t\\t\\t\\t\\t\\t<Separator />\\n\\t\\t\\t\\t\\t{/if}\\n\\t\\t\\t\\t{:else}\\n\\t\\t\\t\\t\\t<Item on:SMUI:action={() => subGoto(subTab.dest)} on:touchstart={() => {if(subTab.label != 'Go to Sleeper') prefetch(subTab.dest)}} on:mouseover={() => {if(subTab.label != 'Go to Sleeper') prefetch(subTab.dest)}}>\\n\\t\\t\\t\\t\\t\\t<Graphic class=\\"material-icons\\">{subTab.icon}</Graphic>\\n\\t\\t\\t\\t\\t\\t<Text class=\\"subText\\">{subTab.label}</Text>\\n\\t\\t\\t\\t\\t</Item>\\n\\t\\t\\t\\t\\t{#if ix != tabChildren.length - 1}\\n\\t\\t\\t\\t\\t\\t<Separator />\\n\\t\\t\\t\\t\\t{/if}\\n\\t\\t\\t\\t{/if}\\n\\t\\t\\t{/each}\\n\\t\\t</List>\\n\\t</div>\\n</div>\\n"],"names":[],"mappings":"AA2DY,OAAO,AAAE,CAAC,AACpB,OAAO,CAAE,WAAW,CACpB,QAAQ,CAAE,QAAQ,CACf,eAAe,CAAE,MAAM,AACxB,CAAC,AAEI,uBAAuB,AAAE,CAAC,AACjC,SAAS,CAAE,KAAK,CAChB,MAAM,CAAE,IAAI,CACZ,KAAK,CAAE,IAAI,AACZ,CAAC,AAED,OAAO,eAAC,CAAC,AACR,QAAQ,CAAE,QAAQ,AACnB,CAAC,AAED,QAAQ,eAAC,CAAC,AACT,UAAU,CAAE,MAAM,CAClB,OAAO,CAAE,KAAK,CACd,QAAQ,CAAE,QAAQ,CAClB,OAAO,CAAE,CAAC,CACV,gBAAgB,CAAE,IAAI,KAAK,CAAC,CAC5B,UAAU,CAAE,GAAG,CAAC,IAAI,AACrB,CAAC,AAED,QAAQ,eAAC,CAAC,AACT,OAAO,CAAE,KAAK,CACd,QAAQ,CAAE,QAAQ,CAClB,GAAG,CAAE,CAAC,CACN,IAAI,CAAE,CAAC,CACP,KAAK,CAAE,IAAI,CACX,MAAM,CAAE,IAAI,CACZ,MAAM,CAAE,KAAK,CACb,OAAO,CAAE,CAAC,AACX,CAAC,AAEO,oBAAoB,AAAE,CAAC,AAC9B,OAAO,CAAE,CAAC,AACX,CAAC,AAEO,QAAQ,AAAE,CAAC,AAClB,SAAS,CAAE,KAAK,AACjB,CAAC,AAEO,YAAY,AAAE,CAAC,AACtB,OAAO,CAAE,IAAI,AACd,CAAC"}`
};
var NavLarge = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let { active, tabs: tabs2 } = $$props;
  let el, width, height, left, top;
  const sizeSubMenu = (w) => {
    top = (el == null ? void 0 : el.getBoundingClientRect()) ? el == null ? void 0 : el.getBoundingClientRect().top : 0;
    const bottom = (el == null ? void 0 : el.getBoundingClientRect()) ? el == null ? void 0 : el.getBoundingClientRect().bottom : 0;
    height = bottom - top + 1;
    left = (el == null ? void 0 : el.getBoundingClientRect()) ? el == null ? void 0 : el.getBoundingClientRect().left : 0;
    const right = (el == null ? void 0 : el.getBoundingClientRect()) ? el == null ? void 0 : el.getBoundingClientRect().right : 0;
    width = right - left;
  };
  let tabChildren = [];
  for (const tab of tabs2) {
    if (tab.nest) {
      tabChildren = tab.children;
    }
  }
  if ($$props.active === void 0 && $$bindings.active && active !== void 0)
    $$bindings.active(active);
  if ($$props.tabs === void 0 && $$bindings.tabs && tabs2 !== void 0)
    $$bindings.tabs(tabs2);
  $$result.css.add(css$H);
  let $$settled;
  let $$rendered;
  do {
    $$settled = true;
    {
      sizeSubMenu();
    }
    $$rendered = `



<div class="${"overlay svelte-1wryr23"}" style="${"display: " + escape("none") + ";"}"></div>

<div class="${"parent svelte-1wryr23"}">${validate_component(TabBar, "TabBar").$$render($$result, { class: "navBar", tabs: tabs2, active }, {
      active: ($$value) => {
        active = $$value;
        $$settled = false;
      }
    }, {
      default: ({ tab }) => `${tab.nest ? `<div${add_attribute("this", el, 0)}>${validate_component(Tab, "Tab").$$render($$result, { tab, minWidth: true }, {}, {
        default: () => `${validate_component(CommonIcon, "Icon").$$render($$result, { class: "material-icons" }, {}, { default: () => `${escape(tab.icon)}` })}
					${validate_component(CommonLabel, "Label").$$render($$result, {}, {}, { default: () => `${escape(tab.label)}` })}`
      })}</div>` : `${validate_component(Tab, "Tab").$$render($$result, {
        class: tab.label == "Blog" && !enableBlog ? "dontDisplay" : "",
        tab,
        minWidth: true
      }, {}, {
        default: () => `${validate_component(CommonIcon, "Icon").$$render($$result, { class: "material-icons" }, {}, { default: () => `${escape(tab.icon)}` })}
				${validate_component(CommonLabel, "Label").$$render($$result, {}, {}, { default: () => `${escape(tab.label)}` })}`
      })}`}`
    })}
	<div class="${"subMenu svelte-1wryr23"}" style="${"max-height: " + escape(0) + "px; width: " + escape(width) + "px; top: " + escape(height) + "px; left: " + escape(left) + "px; box-shadow: 0 0 " + escape("0") + " 0 #00316b; border: " + escape("0") + " solid #00316b; border-top: none;"}">${validate_component(List, "List").$$render($$result, {}, {}, {
      default: () => `${each(tabChildren, (subTab, ix) => `${subTab.label == "Managers" ? `${validate_component(Item, "Item").$$render($$result, {
        class: managers.length ? "" : "dontDisplay"
      }, {}, {
        default: () => `${validate_component(Graphic, "Graphic").$$render($$result, { class: "material-icons" }, {}, { default: () => `${escape(subTab.icon)}` })}
						${validate_component(Text, "Text").$$render($$result, { class: "subText" }, {}, { default: () => `${escape(subTab.label)}` })}
					`
      })}
					${ix != tabChildren.length - 1 ? `${validate_component(Separator, "Separator").$$render($$result, {}, {}, {})}` : ``}` : `${validate_component(Item, "Item").$$render($$result, {}, {}, {
        default: () => `${validate_component(Graphic, "Graphic").$$render($$result, { class: "material-icons" }, {}, { default: () => `${escape(subTab.icon)}` })}
						${validate_component(Text, "Text").$$render($$result, { class: "subText" }, {}, { default: () => `${escape(subTab.label)}` })}
					`
      })}
					${ix != tabChildren.length - 1 ? `${validate_component(Separator, "Separator").$$render($$result, {}, {}, {})}` : ``}`}`)}`
    })}</div></div>`;
  } while (!$$settled);
  return $$rendered;
});
var cssClasses = {
  ICON_BUTTON_ON: "mdc-icon-button--on",
  ROOT: "mdc-icon-button"
};
var strings = {
  ARIA_LABEL: "aria-label",
  ARIA_PRESSED: "aria-pressed",
  DATA_ARIA_LABEL_OFF: "data-aria-label-off",
  DATA_ARIA_LABEL_ON: "data-aria-label-on",
  CHANGE_EVENT: "MDCIconButtonToggle:change"
};
var MDCIconButtonToggleFoundation = function(_super) {
  __extends(MDCIconButtonToggleFoundation2, _super);
  function MDCIconButtonToggleFoundation2(adapter) {
    var _this = _super.call(this, __assign(__assign({}, MDCIconButtonToggleFoundation2.defaultAdapter), adapter)) || this;
    _this.hasToggledAriaLabel = false;
    return _this;
  }
  Object.defineProperty(MDCIconButtonToggleFoundation2, "cssClasses", {
    get: function() {
      return cssClasses;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCIconButtonToggleFoundation2, "strings", {
    get: function() {
      return strings;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCIconButtonToggleFoundation2, "defaultAdapter", {
    get: function() {
      return {
        addClass: function() {
          return void 0;
        },
        hasClass: function() {
          return false;
        },
        notifyChange: function() {
          return void 0;
        },
        removeClass: function() {
          return void 0;
        },
        getAttr: function() {
          return null;
        },
        setAttr: function() {
          return void 0;
        }
      };
    },
    enumerable: false,
    configurable: true
  });
  MDCIconButtonToggleFoundation2.prototype.init = function() {
    var ariaLabelOn = this.adapter.getAttr(strings.DATA_ARIA_LABEL_ON);
    var ariaLabelOff = this.adapter.getAttr(strings.DATA_ARIA_LABEL_OFF);
    if (ariaLabelOn && ariaLabelOff) {
      if (this.adapter.getAttr(strings.ARIA_PRESSED) !== null) {
        throw new Error("MDCIconButtonToggleFoundation: Button should not set `aria-pressed` if it has a toggled aria label.");
      }
      this.hasToggledAriaLabel = true;
    } else {
      this.adapter.setAttr(strings.ARIA_PRESSED, String(this.isOn()));
    }
  };
  MDCIconButtonToggleFoundation2.prototype.handleClick = function() {
    this.toggle();
    this.adapter.notifyChange({ isOn: this.isOn() });
  };
  MDCIconButtonToggleFoundation2.prototype.isOn = function() {
    return this.adapter.hasClass(cssClasses.ICON_BUTTON_ON);
  };
  MDCIconButtonToggleFoundation2.prototype.toggle = function(isOn) {
    if (isOn === void 0) {
      isOn = !this.isOn();
    }
    if (isOn) {
      this.adapter.addClass(cssClasses.ICON_BUTTON_ON);
    } else {
      this.adapter.removeClass(cssClasses.ICON_BUTTON_ON);
    }
    if (this.hasToggledAriaLabel) {
      var ariaLabel = isOn ? this.adapter.getAttr(strings.DATA_ARIA_LABEL_ON) : this.adapter.getAttr(strings.DATA_ARIA_LABEL_OFF);
      this.adapter.setAttr(strings.ARIA_LABEL, ariaLabel || "");
    } else {
      this.adapter.setAttr(strings.ARIA_PRESSED, "" + isOn);
    }
  };
  return MDCIconButtonToggleFoundation2;
}(MDCFoundation);
var { Object: Object_1$2 } = globals;
var IconButton = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let actionProp;
  let $$restProps = compute_rest_props($$props, [
    "use",
    "class",
    "style",
    "ripple",
    "color",
    "toggle",
    "pressed",
    "ariaLabelOn",
    "ariaLabelOff",
    "href",
    "action",
    "component",
    "getElement"
  ]);
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let uninitializedValue = () => {
  };
  let { use = [] } = $$props;
  let { class: className = "" } = $$props;
  let { style = "" } = $$props;
  let { ripple = true } = $$props;
  let { color = null } = $$props;
  let { toggle = false } = $$props;
  let { pressed = uninitializedValue } = $$props;
  let { ariaLabelOn = null } = $$props;
  let { ariaLabelOff = null } = $$props;
  let { href = null } = $$props;
  let { action = null } = $$props;
  let element;
  let instance;
  let internalClasses = {};
  let internalStyles = {};
  let internalAttrs = {};
  let context = getContext("SMUI:icon-button:context");
  let ariaDescribedby = getContext("SMUI:icon-button:aria-describedby");
  let { component = href == null ? Button : A } = $$props;
  setContext("SMUI:icon:context", "icon-button");
  let oldToggle = null;
  onDestroy(() => {
    instance && instance.destroy();
  });
  function hasClass(className2) {
    return className2 in internalClasses ? internalClasses[className2] : getElement().classList.contains(className2);
  }
  function addClass(className2) {
    if (!internalClasses[className2]) {
      internalClasses[className2] = true;
    }
  }
  function removeClass(className2) {
    if (!(className2 in internalClasses) || internalClasses[className2]) {
      internalClasses[className2] = false;
    }
  }
  function addStyle(name, value) {
    if (internalStyles[name] != value) {
      if (value === "" || value == null) {
        delete internalStyles[name];
        internalStyles = internalStyles;
      } else {
        internalStyles[name] = value;
      }
    }
  }
  function getAttr(name) {
    return name in internalAttrs ? internalAttrs[name] : getElement().getAttribute(name);
  }
  function addAttr(name, value) {
    if (internalAttrs[name] !== value) {
      internalAttrs[name] = value;
    }
  }
  function handleChange(evtData) {
    pressed = evtData.isOn;
  }
  function getElement() {
    return element.getElement();
  }
  if ($$props.use === void 0 && $$bindings.use && use !== void 0)
    $$bindings.use(use);
  if ($$props.class === void 0 && $$bindings.class && className !== void 0)
    $$bindings.class(className);
  if ($$props.style === void 0 && $$bindings.style && style !== void 0)
    $$bindings.style(style);
  if ($$props.ripple === void 0 && $$bindings.ripple && ripple !== void 0)
    $$bindings.ripple(ripple);
  if ($$props.color === void 0 && $$bindings.color && color !== void 0)
    $$bindings.color(color);
  if ($$props.toggle === void 0 && $$bindings.toggle && toggle !== void 0)
    $$bindings.toggle(toggle);
  if ($$props.pressed === void 0 && $$bindings.pressed && pressed !== void 0)
    $$bindings.pressed(pressed);
  if ($$props.ariaLabelOn === void 0 && $$bindings.ariaLabelOn && ariaLabelOn !== void 0)
    $$bindings.ariaLabelOn(ariaLabelOn);
  if ($$props.ariaLabelOff === void 0 && $$bindings.ariaLabelOff && ariaLabelOff !== void 0)
    $$bindings.ariaLabelOff(ariaLabelOff);
  if ($$props.href === void 0 && $$bindings.href && href !== void 0)
    $$bindings.href(href);
  if ($$props.action === void 0 && $$bindings.action && action !== void 0)
    $$bindings.action(action);
  if ($$props.component === void 0 && $$bindings.component && component !== void 0)
    $$bindings.component(component);
  if ($$props.getElement === void 0 && $$bindings.getElement && getElement !== void 0)
    $$bindings.getElement(getElement);
  let $$settled;
  let $$rendered;
  do {
    $$settled = true;
    actionProp = (() => {
      if (context === "data-table:pagination") {
        switch (action) {
          case "first-page":
            return { "data-first-page": "true" };
          case "prev-page":
            return { "data-prev-page": "true" };
          case "next-page":
            return { "data-next-page": "true" };
          case "last-page":
            return { "data-last-page": "true" };
          default:
            return { "data-action": "true" };
        }
      } else if (context === "dialog:header") {
        return { "data-mdc-dialog-action": action };
      } else {
        return { action };
      }
    })();
    {
      if (element && getElement() && toggle !== oldToggle) {
        if (toggle && !instance) {
          instance = new MDCIconButtonToggleFoundation({
            addClass,
            hasClass,
            notifyChange: (evtData) => {
              handleChange(evtData);
              dispatch(getElement(), "MDCIconButtonToggle:change", evtData);
            },
            removeClass,
            getAttr,
            setAttr: addAttr
          });
          instance.init();
        } else if (!toggle && instance) {
          instance.destroy();
          instance = null;
          internalClasses = {};
          internalAttrs = {};
        }
        oldToggle = toggle;
      }
    }
    {
      if (instance && instance.isOn() !== pressed) {
        instance.toggle(pressed);
      }
    }
    $$rendered = `${validate_component(component || missing_component, "svelte:component").$$render($$result, Object_1$2.assign({
      use: [
        [
          Ripple,
          {
            ripple,
            unbounded: true,
            color,
            disabled: !!$$restProps.disabled,
            addClass,
            removeClass,
            addStyle
          }
        ],
        forwardEvents,
        ...use
      ]
    }, {
      class: classMap({
        [className]: true,
        "mdc-icon-button": true,
        "mdc-icon-button--on": pressed !== uninitializedValue && pressed,
        "mdc-card__action": context === "card:action",
        "mdc-card__action--icon": context === "card:action",
        "mdc-top-app-bar__navigation-icon": context === "top-app-bar:navigation",
        "mdc-top-app-bar__action-item": context === "top-app-bar:action",
        "mdc-snackbar__dismiss": context === "snackbar:actions",
        "mdc-data-table__pagination-button": context === "data-table:pagination",
        "mdc-data-table__sort-icon-button": context === "data-table:sortable-header-cell",
        "mdc-dialog__close": context === "dialog:header" && action === "close",
        ...internalClasses
      })
    }, {
      style: Object.entries(internalStyles).map(([name, value]) => `${name}: ${value};`).concat([style]).join(" ")
    }, {
      "aria-pressed": pressed !== uninitializedValue ? pressed ? "true" : "false" : null
    }, {
      "aria-label": pressed ? ariaLabelOn : ariaLabelOff
    }, { "data-aria-label-on": ariaLabelOn }, { "data-aria-label-off": ariaLabelOff }, { "aria-describedby": ariaDescribedby }, { href }, actionProp, internalAttrs, $$restProps, { this: element }), {
      this: ($$value) => {
        element = $$value;
        $$settled = false;
      }
    }, {
      default: () => `${slots.default ? slots.default({}) : ``}`
    })}`;
  } while (!$$settled);
  return $$rendered;
});
var css$G = {
  code: "a.svelte-1ejetaj{display:table;margin:0 auto}nav.svelte-1ejetaj{background-color:var(--fff);position:relative;z-index:2;border-bottom:1px solid #00316b;box-shadow:0 0 8px 0 #00316b}#logo.svelte-1ejetaj{width:80px;display:block;margin:0 auto;padding:10px}.large.svelte-1ejetaj{display:block}.small.svelte-1ejetaj{display:none}.container.svelte-1ejetaj{position:absolute;top:0.25em;right:0.25em}.lightDark{color:var(--g555)\n	}@media(max-width: 950px){.large.svelte-1ejetaj{display:none}.small.svelte-1ejetaj{display:block}}",
  map: `{"version":3,"file":"index.svelte","sources":["index.svelte"],"sourcesContent":["<script>\\n\\timport { tabs } from '$lib/utils/tabs';\\n\\timport NavSmall from './NavSmall.svelte';\\n\\timport NavLarge from './NavLarge.svelte';\\n\\t\\n\\timport IconButton from '@smui/icon-button';\\n\\timport { Icon } from '@smui/common';\\n\\n\\texport let activeTab;\\n\\n\\t$: active = tabs.find(tab => tab.dest == activeTab || (tab.nest && tab.children.find(subTab => subTab.dest == activeTab)));\\n\\n\\t// toggle dark mode\\n\\tlet lightTheme =\\n\\t\\ttypeof window === \\"undefined\\" ||\\n\\t\\twindow.matchMedia(\\"(prefers-color-scheme: light)\\").matches;\\n\\t\\n\\tfunction switchTheme() {\\n\\t\\tlightTheme = !lightTheme;\\n\\t\\tlet themeLink = document.head.querySelector(\\"#theme\\");\\n\\t\\tif (!themeLink) {\\n\\t\\t\\tthemeLink = document.createElement(\\"link\\");\\n\\t\\t\\tthemeLink.rel = \\"stylesheet\\";\\n\\t\\t\\tthemeLink.id = \\"theme\\";\\n\\t\\t}\\n\\t\\tthemeLink.href = \`/smui\${lightTheme ? \\"\\" : \\"-dark\\"}.css\`;\\n\\t\\tdocument.head\\n\\t\\t.querySelector('link[href=\\"/smui-dark.css\\"]')\\n\\t\\t.insertAdjacentElement(\\"afterend\\", themeLink);\\n\\t}\\n<\/script>\\n\\n<svelte:head>\\n\\t<title>{!activeTab[1] ? 'Home' : activeTab[1].toUpperCase() + activeTab.slice(2)} | League Page</title>\\n</svelte:head>\\n\\n<style>\\n\\ta {\\n\\t\\tdisplay: table;\\n    \\tmargin: 0 auto;\\n\\t}\\n\\tnav {\\n\\t\\tbackground-color: var(--fff);\\n\\t\\tposition: relative;\\n\\t\\tz-index: 2;\\n\\t\\tborder-bottom: 1px solid #00316b;\\n\\t\\tbox-shadow: 0 0 8px 0 #00316b;\\n\\t}\\n\\n\\t#logo {\\n\\t\\twidth: 80px;\\n\\t\\tdisplay: block;\\n\\t\\tmargin: 0 auto;\\n\\t\\tpadding: 10px;\\n\\t}\\n\\n    .large {\\n\\t\\tdisplay: block;\\n    }\\n\\n\\t.small {\\n\\t\\tdisplay: none;\\n\\t}\\n\\n\\t.container {\\n\\t\\tposition: absolute;\\n\\t\\ttop: 0.25em;\\n\\t\\tright: 0.25em;\\n\\t}\\n\\n\\t:global(.lightDark) {\\n\\t\\tcolor: var(--g555)\\n\\t}\\n\\n\\t@media (max-width: 950px) { /* width of the large navBar */\\n\\t\\t.large {\\n\\t\\t\\tdisplay: none;\\n\\t\\t}\\n\\n\\t\\t.small {\\n\\t\\t\\tdisplay: block;\\n\\t\\t}\\n\\t}\\n</style>\\n\\n<nav>\\n\\t<a href=\\"/\\"><img id=\\"logo\\" alt=\\"league logo\\" src=\\"./badge.png\\" /></a>\\n\\n\\t<div class=\\"container\\">\\n\\t\\t<IconButton\\n\\t\\t\\ttoggle\\n\\t\\t\\tpressed={lightTheme}\\n\\t\\t\\ton:MDCIconButtonToggle:change={switchTheme}\\n\\t\\t\\tclass=\\"lightDark\\"\\n\\t\\t>\\n\\t\\t\\t<Icon class=\\"material-icons\\" on>dark_mode</Icon>\\n\\t\\t\\t<Icon class=\\"material-icons\\">light_mode</Icon>\\n\\t\\t</IconButton>\\n\\t</div>\\n\\n\\t<div class=\\"large\\">\\n\\t\\t<NavLarge {tabs} bind:active={active} />\\n\\t</div>\\n\\n\\t<div class=\\"small\\">\\n\\t\\t<NavSmall {tabs} bind:active={activeTab} />\\n\\t</div>\\n\\n</nav>\\n"],"names":[],"mappings":"AAqCC,CAAC,eAAC,CAAC,AACF,OAAO,CAAE,KAAK,CACX,MAAM,CAAE,CAAC,CAAC,IAAI,AAClB,CAAC,AACD,GAAG,eAAC,CAAC,AACJ,gBAAgB,CAAE,IAAI,KAAK,CAAC,CAC5B,QAAQ,CAAE,QAAQ,CAClB,OAAO,CAAE,CAAC,CACV,aAAa,CAAE,GAAG,CAAC,KAAK,CAAC,OAAO,CAChC,UAAU,CAAE,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,OAAO,AAC9B,CAAC,AAED,KAAK,eAAC,CAAC,AACN,KAAK,CAAE,IAAI,CACX,OAAO,CAAE,KAAK,CACd,MAAM,CAAE,CAAC,CAAC,IAAI,CACd,OAAO,CAAE,IAAI,AACd,CAAC,AAEE,MAAM,eAAC,CAAC,AACV,OAAO,CAAE,KAAK,AACZ,CAAC,AAEJ,MAAM,eAAC,CAAC,AACP,OAAO,CAAE,IAAI,AACd,CAAC,AAED,UAAU,eAAC,CAAC,AACX,QAAQ,CAAE,QAAQ,CAClB,GAAG,CAAE,MAAM,CACX,KAAK,CAAE,MAAM,AACd,CAAC,AAEO,UAAU,AAAE,CAAC,AACpB,KAAK,CAAE,IAAI,MAAM,CAAC;CACnB,CAAC,AAED,MAAM,AAAC,YAAY,KAAK,CAAC,AAAC,CAAC,AAC1B,MAAM,eAAC,CAAC,AACP,OAAO,CAAE,IAAI,AACd,CAAC,AAED,MAAM,eAAC,CAAC,AACP,OAAO,CAAE,KAAK,AACf,CAAC,AACF,CAAC"}`
};
var Nav = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let active;
  let { activeTab } = $$props;
  let lightTheme = typeof window === "undefined" || window.matchMedia("(prefers-color-scheme: light)").matches;
  if ($$props.activeTab === void 0 && $$bindings.activeTab && activeTab !== void 0)
    $$bindings.activeTab(activeTab);
  $$result.css.add(css$G);
  let $$settled;
  let $$rendered;
  do {
    $$settled = true;
    active = tabs.find((tab) => tab.dest == activeTab || tab.nest && tab.children.find((subTab) => subTab.dest == activeTab));
    $$rendered = `${$$result.head += `${$$result.title = `<title>${escape(!activeTab[1] ? "Home" : activeTab[1].toUpperCase() + activeTab.slice(2))} | League Page</title>`, ""}`, ""}



<nav class="${"svelte-1ejetaj"}"><a href="${"/"}" class="${"svelte-1ejetaj"}"><img id="${"logo"}" alt="${"league logo"}" src="${"./badge.png"}" class="${"svelte-1ejetaj"}"></a>

	<div class="${"container svelte-1ejetaj"}">${validate_component(IconButton, "IconButton").$$render($$result, {
      toggle: true,
      pressed: lightTheme,
      class: "lightDark"
    }, {}, {
      default: () => `${validate_component(CommonIcon, "Icon").$$render($$result, { class: "material-icons", on: true }, {}, { default: () => `dark_mode` })}
			${validate_component(CommonIcon, "Icon").$$render($$result, { class: "material-icons" }, {}, { default: () => `light_mode` })}`
    })}</div>

	<div class="${"large svelte-1ejetaj"}">${validate_component(NavLarge, "NavLarge").$$render($$result, { tabs, active }, {
      active: ($$value) => {
        active = $$value;
        $$settled = false;
      }
    }, {})}</div>

	<div class="${"small svelte-1ejetaj"}">${validate_component(NavSmall, "NavSmall").$$render($$result, { tabs, active: activeTab }, {
      active: ($$value) => {
        activeTab = $$value;
        $$settled = false;
      }
    }, {})}</div></nav>`;
  } while (!$$settled);
  return $$rendered;
});
var css$F = {
  code: 'footer.svelte-1tg8r2e.svelte-1tg8r2e{background-color:var(--f8f8f8);width:100%;display:block;position:absolute;bottom:0;z-index:1;border-top:1px solid #920505;padding:30px 0 60px;text-align:center;color:#777}#navigation.svelte-1tg8r2e.svelte-1tg8r2e{margin:0 0 2em}#navigation.svelte-1tg8r2e ul.svelte-1tg8r2e{margin:0;padding:0}#navigation.svelte-1tg8r2e ul li.svelte-1tg8r2e{list-style-type:none;display:inline}#navigation.svelte-1tg8r2e li.svelte-1tg8r2e:not(:first-child):before{content:" | "}.navLink.svelte-1tg8r2e.svelte-1tg8r2e{display:inline-block;cursor:pointer;padding:6px 10px}.navLink.svelte-1tg8r2e.svelte-1tg8r2e:hover{color:#920505}.updateNotice.svelte-1tg8r2e.svelte-1tg8r2e{color:var(--g999);font-style:italic;font-size:0.8em;margin-top:0}.invisible.svelte-1tg8r2e.svelte-1tg8r2e{visibility:hidden;pointer-events:none}',
  map: `{"version":3,"file":"Footer.svelte","sources":["Footer.svelte"],"sourcesContent":["<script>\\n\\timport { goto } from '$app/navigation';\\n\\timport { tabs } from '$lib/utils/tabs';\\n\\timport { onMount } from 'svelte';\\n\\n\\tlet outOfDate = false;\\n\\n\\tonMount(async () => {\\n\\t\\tconst res = await fetch('/api/checkVersion', {compress: true})\\n\\t\\tconst needUpdate = await res.json();\\n\\t\\toutOfDate = needUpdate;\\n\\t})\\n\\n\\tconst year = new Date().getFullYear();\\n\\n\\tlet el, elNeedUpdate, innerWidth, footerHeight, footerHeightNeedUpdate;\\n\\n\\tconst resize = (w) => {\\n\\t\\tconst top = el?.getBoundingClientRect() ? el?.getBoundingClientRect().top  : 0;\\n\\t\\tconst bottom = el?.getBoundingClientRect() ? el?.getBoundingClientRect().bottom  : 0;\\n\\t\\tconst topNeedUpdate = elNeedUpdate?.getBoundingClientRect() ? elNeedUpdate?.getBoundingClientRect().top  : 0;\\n\\t\\tconst bottomNeedUpdate = elNeedUpdate?.getBoundingClientRect() ? elNeedUpdate?.getBoundingClientRect().bottom  : 0;\\n\\n\\t\\tfooterHeight = bottom - top;\\n\\t\\tfooterHeightNeedUpdate = bottomNeedUpdate - topNeedUpdate;\\n\\t}\\n\\n    $: resize(innerWidth);\\n<\/script>\\n\\n<svelte:window bind:innerWidth={innerWidth} />\\n\\n<style>\\n\\tfooter {\\n\\t\\tbackground-color: var(--f8f8f8);\\n\\t\\twidth: 100%;\\n        display: block;\\n        position: absolute;\\n        bottom: 0;\\n\\t\\tz-index: 1;\\n\\t\\tborder-top: 1px solid #920505;\\n\\t\\tpadding: 30px 0 60px;\\n\\t\\ttext-align: center;\\n\\t\\tcolor: #777;\\n\\t}\\n\\n\\t#navigation {\\n\\t\\tmargin: 0 0 2em;\\n\\t}\\n\\n\\t#navigation ul {\\n\\t\\tmargin: 0;\\n\\t\\tpadding: 0;\\n\\t}\\n\\n\\t#navigation ul li {\\n\\t\\tlist-style-type: none;\\n\\t\\tdisplay: inline;\\n\\t}\\n\\n\\t#navigation li:not(:first-child):before {\\n\\t\\tcontent: \\" | \\";\\n\\t}\\n\\n\\t.navLink {\\n\\t\\tdisplay: inline-block;\\n\\t\\tcursor: pointer;\\n\\t\\tpadding: 6px 10px;\\n\\t}\\n\\n\\t.navLink:hover {\\n\\t\\tcolor: #920505;\\n\\t}\\n\\n\\t.updateNotice {\\n\\t\\tcolor: var(--g999);\\n\\t\\tfont-style: italic;\\n\\t\\tfont-size: 0.8em;\\n\\t\\tmargin-top: 0;\\n\\t}\\n\\n\\t.invisible {\\n\\t\\tvisibility: hidden;\\n\\t\\tpointer-events: none;\\n\\t}\\n</style>\\n\\n<div class=\\"footerSpacer\\" style=\\"height: {outOfDate ? footerHeightNeedUpdate : footerHeight}px;\\" />\\n\\n<!-- footer with update notice -->\\n<footer class=\\"{outOfDate ? '' : 'invisible'}\\" bind:this={elNeedUpdate}>\\n\\t<p class=\\"updateNotice\\">There is an update available for your League Page. <a href=\\"https://github.com/nmelhado/league-page/blob/master/TRAINING_WHEELS.md#iii-updates\\">Follow the Update Instructions</a> to get all of the newest features!</p>\\n\\t<div id=\\"navigation\\">\\n\\t\\t<ul>\\n\\t\\t\\t{#each tabs as tab}\\n\\t\\t\\t\\t{#if !tab.nest}\\n\\t\\t\\t\\t\\t<li><div class=\\"navLink\\" on:click={() => goto(tab.dest)}>{tab.label}</div></li>\\n\\t\\t\\t\\t{:else}\\n\\t\\t\\t\\t\\t{#each tab.children as child}\\n\\t\\t\\t\\t\\t\\t<li><div class=\\"navLink\\" on:click={() => goto(child.dest)}>{child.label}</div></li>\\n\\t\\t\\t\\t\\t{/each}\\n\\t\\t\\t\\t{/if}\\n\\t\\t\\t{/each}\\n\\t\\t</ul>\\n\\t</div>\\n\\t<!-- PLEASE DO NOT REMOVE THE COPYRIGHT -->\\n\\t<span class=\\"copyright\\">&copy; 2021 - {year} <a href=\\"https://github.com/nmelhado/league-page\\">League Page</a></span>\\n\\t<br />\\n\\t<!-- PLEASE DO NOT REMOVE THE BUILT BY -->\\n\\t<span class=\\"creator\\">Built by <a href=\\"http://www.nmelhado.com/\\">Nicholas Melhado</a><br /></span>\\n\\t<!-- You can remove the donation link (although any donations to help\\n\\t maintain and enhance League Page would be greatly appreciated!) -->\\n\\tLove League Page? Please consider <a href=\\"https://www.buymeacoffee.com/nmelhado\\">donating</a> to support enhancements or just to say thank you!\\n</footer>\\n\\n<footer class=\\"{!outOfDate ? '' : 'invisible'}\\" bind:this={el}>\\n\\t<div id=\\"navigation\\">\\n\\t\\t<ul>\\n\\t\\t\\t{#each tabs as tab}\\n\\t\\t\\t\\t{#if !tab.nest}\\n\\t\\t\\t\\t\\t<li><div class=\\"navLink\\" on:click={() => goto(tab.dest)}>{tab.label}</div></li>\\n\\t\\t\\t\\t{:else}\\n\\t\\t\\t\\t\\t{#each tab.children as child}\\n\\t\\t\\t\\t\\t\\t<li><div class=\\"navLink\\" on:click={() => goto(child.dest)}>{child.label}</div></li>\\n\\t\\t\\t\\t\\t{/each}\\n\\t\\t\\t\\t{/if}\\n\\t\\t\\t{/each}\\n\\t\\t</ul>\\n\\t</div>\\n\\t<!-- PLEASE DO NOT REMOVE THE COPYRIGHT -->\\n\\t<span class=\\"copyright\\">&copy; 2021 - {year} <a href=\\"https://github.com/nmelhado/league-page\\">League Page</a></span>\\n\\t<br />\\n\\t<!-- PLEASE DO NOT REMOVE THE BUILT BY -->\\n\\t<span class=\\"creator\\">Built by <a href=\\"http://www.nmelhado.com/\\">Nicholas Melhado</a><br /></span>\\n\\t<!-- You can remove the donation link (although any donations to help\\n\\t maintain and enhance League Page would be greatly appreciated!) -->\\n\\tLove League Page? Please consider <a href=\\"https://www.buymeacoffee.com/nmelhado\\">donating</a> to support enhancements or just to say thank you!\\n</footer>\\n"],"names":[],"mappings":"AAiCC,MAAM,8BAAC,CAAC,AACP,gBAAgB,CAAE,IAAI,QAAQ,CAAC,CAC/B,KAAK,CAAE,IAAI,CACL,OAAO,CAAE,KAAK,CACd,QAAQ,CAAE,QAAQ,CAClB,MAAM,CAAE,CAAC,CACf,OAAO,CAAE,CAAC,CACV,UAAU,CAAE,GAAG,CAAC,KAAK,CAAC,OAAO,CAC7B,OAAO,CAAE,IAAI,CAAC,CAAC,CAAC,IAAI,CACpB,UAAU,CAAE,MAAM,CAClB,KAAK,CAAE,IAAI,AACZ,CAAC,AAED,WAAW,8BAAC,CAAC,AACZ,MAAM,CAAE,CAAC,CAAC,CAAC,CAAC,GAAG,AAChB,CAAC,AAED,0BAAW,CAAC,EAAE,eAAC,CAAC,AACf,MAAM,CAAE,CAAC,CACT,OAAO,CAAE,CAAC,AACX,CAAC,AAED,0BAAW,CAAC,EAAE,CAAC,EAAE,eAAC,CAAC,AAClB,eAAe,CAAE,IAAI,CACrB,OAAO,CAAE,MAAM,AAChB,CAAC,AAED,0BAAW,CAAC,iBAAE,KAAK,YAAY,CAAC,OAAO,AAAC,CAAC,AACxC,OAAO,CAAE,KAAK,AACf,CAAC,AAED,QAAQ,8BAAC,CAAC,AACT,OAAO,CAAE,YAAY,CACrB,MAAM,CAAE,OAAO,CACf,OAAO,CAAE,GAAG,CAAC,IAAI,AAClB,CAAC,AAED,sCAAQ,MAAM,AAAC,CAAC,AACf,KAAK,CAAE,OAAO,AACf,CAAC,AAED,aAAa,8BAAC,CAAC,AACd,KAAK,CAAE,IAAI,MAAM,CAAC,CAClB,UAAU,CAAE,MAAM,CAClB,SAAS,CAAE,KAAK,CAChB,UAAU,CAAE,CAAC,AACd,CAAC,AAED,UAAU,8BAAC,CAAC,AACX,UAAU,CAAE,MAAM,CAClB,cAAc,CAAE,IAAI,AACrB,CAAC"}`
};
var Footer = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  const year = new Date().getFullYear();
  let el, elNeedUpdate, footerHeight;
  const resize = (w) => {
    const top = (el == null ? void 0 : el.getBoundingClientRect()) ? el == null ? void 0 : el.getBoundingClientRect().top : 0;
    const bottom = (el == null ? void 0 : el.getBoundingClientRect()) ? el == null ? void 0 : el.getBoundingClientRect().bottom : 0;
    (elNeedUpdate == null ? void 0 : elNeedUpdate.getBoundingClientRect()) ? elNeedUpdate == null ? void 0 : elNeedUpdate.getBoundingClientRect().top : 0;
    (elNeedUpdate == null ? void 0 : elNeedUpdate.getBoundingClientRect()) ? elNeedUpdate == null ? void 0 : elNeedUpdate.getBoundingClientRect().bottom : 0;
    footerHeight = bottom - top;
  };
  $$result.css.add(css$F);
  {
    resize();
  }
  return `



<div class="${"footerSpacer"}" style="${"height: " + escape(footerHeight) + "px;"}"></div>


<footer class="${escape(null_to_empty("invisible")) + " svelte-1tg8r2e"}"${add_attribute("this", elNeedUpdate, 0)}><p class="${"updateNotice svelte-1tg8r2e"}">There is an update available for your League Page. <a href="${"https://github.com/nmelhado/league-page/blob/master/TRAINING_WHEELS.md#iii-updates"}">Follow the Update Instructions</a> to get all of the newest features!</p>
	<div id="${"navigation"}" class="${"svelte-1tg8r2e"}"><ul class="${"svelte-1tg8r2e"}">${each(tabs, (tab) => `${!tab.nest ? `<li class="${"svelte-1tg8r2e"}"><div class="${"navLink svelte-1tg8r2e"}">${escape(tab.label)}</div></li>` : `${each(tab.children, (child) => `<li class="${"svelte-1tg8r2e"}"><div class="${"navLink svelte-1tg8r2e"}">${escape(child.label)}</div></li>`)}`}`)}</ul></div>
	
	<span class="${"copyright"}">\xA9 2021 - ${escape(year)} <a href="${"https://github.com/nmelhado/league-page"}">League Page</a></span>
	<br>
	
	<span class="${"creator"}">Built by <a href="${"http://www.nmelhado.com/"}">Nicholas Melhado</a><br></span>
	
	Love League Page? Please consider <a href="${"https://www.buymeacoffee.com/nmelhado"}">donating</a> to support enhancements or just to say thank you!
</footer>

<footer class="${escape(null_to_empty("")) + " svelte-1tg8r2e"}"${add_attribute("this", el, 0)}><div id="${"navigation"}" class="${"svelte-1tg8r2e"}"><ul class="${"svelte-1tg8r2e"}">${each(tabs, (tab) => `${!tab.nest ? `<li class="${"svelte-1tg8r2e"}"><div class="${"navLink svelte-1tg8r2e"}">${escape(tab.label)}</div></li>` : `${each(tab.children, (child) => `<li class="${"svelte-1tg8r2e"}"><div class="${"navLink svelte-1tg8r2e"}">${escape(child.label)}</div></li>`)}`}`)}</ul></div>
	
	<span class="${"copyright"}">\xA9 2021 - ${escape(year)} <a href="${"https://github.com/nmelhado/league-page"}">League Page</a></span>
	<br>
	
	<span class="${"creator"}">Built by <a href="${"http://www.nmelhado.com/"}">Nicholas Melhado</a><br></span>
	
	Love League Page? Please consider <a href="${"https://www.buymeacoffee.com/nmelhado"}">donating</a> to support enhancements or just to say thank you!
</footer>`;
});
var Paper = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let $$restProps = compute_rest_props($$props, ["use", "class", "square", "color", "elevation", "transition", "getElement"]);
  forwardEventsBuilder(get_current_component());
  let { use = [] } = $$props;
  let { class: className = "" } = $$props;
  let { square = false } = $$props;
  let { color = "default" } = $$props;
  let { elevation = 1 } = $$props;
  let { transition = false } = $$props;
  let element;
  function getElement() {
    return element;
  }
  if ($$props.use === void 0 && $$bindings.use && use !== void 0)
    $$bindings.use(use);
  if ($$props.class === void 0 && $$bindings.class && className !== void 0)
    $$bindings.class(className);
  if ($$props.square === void 0 && $$bindings.square && square !== void 0)
    $$bindings.square(square);
  if ($$props.color === void 0 && $$bindings.color && color !== void 0)
    $$bindings.color(color);
  if ($$props.elevation === void 0 && $$bindings.elevation && elevation !== void 0)
    $$bindings.elevation(elevation);
  if ($$props.transition === void 0 && $$bindings.transition && transition !== void 0)
    $$bindings.transition(transition);
  if ($$props.getElement === void 0 && $$bindings.getElement && getElement !== void 0)
    $$bindings.getElement(getElement);
  return `<div${spread([
    {
      class: escape_attribute_value(classMap({
        [className]: true,
        "smui-paper": true,
        ["smui-paper--elevation-z" + elevation]: elevation !== 0,
        "smui-paper--rounded": !square,
        ["smui-paper--color-" + color]: color !== "default",
        "smui-paper-transition": transition
      }))
    },
    escape_object($$restProps)
  ])}${add_attribute("this", element, 0)}>${slots.default ? slots.default({}) : ``}
</div>`;
});
var Content = classAdderBuilder({
  class: "smui-paper__content",
  component: Div
});
var H5 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let $$restProps = compute_rest_props($$props, ["use", "getElement"]);
  let { use = [] } = $$props;
  forwardEventsBuilder(get_current_component());
  let element = null;
  function getElement() {
    return element;
  }
  if ($$props.use === void 0 && $$bindings.use && use !== void 0)
    $$bindings.use(use);
  if ($$props.getElement === void 0 && $$bindings.getElement && getElement !== void 0)
    $$bindings.getElement(getElement);
  return `<h5${spread([escape_object($$restProps)])}${add_attribute("this", element, 0)}>${slots.default ? slots.default({}) : ``}
</h5>`;
});
var Title = classAdderBuilder({
  class: "smui-paper__title",
  component: H5
});
var H6 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let $$restProps = compute_rest_props($$props, ["use", "getElement"]);
  let { use = [] } = $$props;
  forwardEventsBuilder(get_current_component());
  let element = null;
  function getElement() {
    return element;
  }
  if ($$props.use === void 0 && $$bindings.use && use !== void 0)
    $$bindings.use(use);
  if ($$props.getElement === void 0 && $$bindings.getElement && getElement !== void 0)
    $$bindings.getElement(getElement);
  return `<h6${spread([escape_object($$restProps)])}${add_attribute("this", element, 0)}>${slots.default ? slots.default({}) : ``}
</h6>`;
});
classAdderBuilder({
  class: "smui-paper__subtitle",
  component: H6
});
var css$E = {
  code: ".card-media-square{background-size:600px}.article-title{display:flex;margin:1em 0 0.5em}.title-link.svelte-z26sd2{font-weight:500;color:var(--blueOne);text-decoration:none;text-align:center;max-height:96px;margin:0 auto;overflow:hidden;text-overflow:ellipsis;-webkit-line-clamp:3;display:-webkit-box;-webkit-box-orient:vertical}.title-link.svelte-z26sd2:hover{color:#920505}.body.svelte-z26sd2{display:flex;margin:2em 0 1em}.icon.svelte-z26sd2{height:40px;width:auto}.body-text.svelte-z26sd2{position:relative;flex-grow:1;min-width:0;max-height:480px;margin:0 auto;overflow:hidden}.body-text.svelte-z26sd2::after{content:'';position:absolute;width:100%;height:60px;top:420px;background:-webkit-linear-gradient(\n            var(--fadeOne),\n            var(--fadeTwo),\n            var(--fadeThree),\n            var(--fadeFour)\n        );background-image:-moz-linear-gradient(\n            var(--fadeOne),\n            var(--fadeTwo),\n            var(--fadeThree),\n            var(--fadeFour)\n        );background-image:-o-linear-gradient(\n            var(--fadeOne),\n            var(--fadeTwo),\n            var(--fadeThree),\n            var(--fadeFour)\n        );background-image:linear-gradient(\n            var(--fadeOne),\n            var(--fadeTwo),\n            var(--fadeThree),\n            var(--fadeFour)\n        );background-image:-ms-linear-gradient(\n            var(--fadeOne),\n            var(--fadeTwo),\n            var(--fadeThree),\n            var(--fadeFour)\n        )}.body-text p{margin-top:0}.body-text a{margin-top:0;word-break:break-word}.body-text blockquote{margin-top:0}.body-text div{overflow-x:scroll}.date.svelte-z26sd2{font-style:italic;color:#888}",
  map: `{"version":3,"file":"SingleNews.svelte","sources":["SingleNews.svelte"],"sourcesContent":["<script>\\n    import Paper, { Title, Content } from '@smui/paper';\\n\\n    export let article;\\n<\/script>\\n\\n<style>\\n    :global(.card-media-square) {\\n        background-size: 600px;\\n    }\\n    \\n     :global(.article-title) {\\n        display: flex;\\n        margin: 1em 0 0.5em;\\n    }\\n\\n    .title-link {\\n        font-weight: 500;\\n        color: var(--blueOne);\\n        text-decoration: none;\\n        text-align: center;\\n        max-height: 96px;\\n        margin: 0 auto;\\n        overflow: hidden;\\n        text-overflow: ellipsis;\\n        -webkit-line-clamp: 3;\\n        display: -webkit-box;\\n        -webkit-box-orient: vertical;\\n    }\\n\\n    .title-link:hover {\\n        color: #920505;\\n    }\\n\\n    .body {\\n        display: flex;\\n        margin: 2em 0 1em;\\n    }\\n\\n    .icon {\\n        height: 40px;\\n        width: auto;\\n    }\\n\\n    .body-text {\\n        position: relative;\\n        flex-grow: 1;\\n        min-width: 0;\\n        max-height: 480px;\\n        margin: 0 auto;\\n        overflow: hidden;\\n    }\\n\\n    .body-text::after {\\n        content: '';\\n        position: absolute;\\n        width: 100%;\\n        height: 60px;\\n        top: 420px;\\n        background: -webkit-linear-gradient(\\n            var(--fadeOne),\\n            var(--fadeTwo),\\n            var(--fadeThree),\\n            var(--fadeFour)\\n        ); \\n        background-image: -moz-linear-gradient(\\n            var(--fadeOne),\\n            var(--fadeTwo),\\n            var(--fadeThree),\\n            var(--fadeFour)\\n        );\\n        background-image: -o-linear-gradient(\\n            var(--fadeOne),\\n            var(--fadeTwo),\\n            var(--fadeThree),\\n            var(--fadeFour)\\n        );\\n        background-image: linear-gradient(\\n            var(--fadeOne),\\n            var(--fadeTwo),\\n            var(--fadeThree),\\n            var(--fadeFour)\\n        );\\n        background-image: -ms-linear-gradient(\\n            var(--fadeOne),\\n            var(--fadeTwo),\\n            var(--fadeThree),\\n            var(--fadeFour)\\n        );\\n    }\\n\\n    :global(.body-text p) {\\n        margin-top: 0;\\n    }\\n\\n    :global(.body-text a) {\\n        margin-top: 0;\\n        word-break: break-word;\\n    }\\n\\n    :global(.body-text blockquote) {\\n        margin-top: 0;\\n    }\\n\\n    :global(.body-text div) {\\n        overflow-x: scroll;\\n    }\\n\\n    .date {\\n        font-style: italic;\\n        color: #888;\\n    }\\n</style>\\n\\n\\n<Paper class=\\"article\\" elevation=3>\\n    <Title class=\\"article-title\\">\\n        <img class=\\"icon\\" src=\\"{article.icon}\\" alt=\\"article thumbnial\\" />\\n        {#if article.link}\\n            <a href=\\"{article.link}\\" target=\\"_blank\\" class=\\"title-link\\">{article.title}</a>\\n        {:else}\\n            {article.title}\\n        {/if}\\n    </Title>\\n    <Content>\\n        <div class=\\"body\\">\\n            <div class=\\"body-text\\">{@html article.article}</div>\\n        </div>\\n        <hr />\\n        {#if article.author}\\n            <span class=\\"author\\">\\n                {article.author}\\n            </span>\\n        {/if}\\n        <span class=\\"date\\">{article.date}</span>\\n    </Content>\\n</Paper>"],"names":[],"mappings":"AAOY,kBAAkB,AAAE,CAAC,AACzB,eAAe,CAAE,KAAK,AAC1B,CAAC,AAEQ,cAAc,AAAE,CAAC,AACtB,OAAO,CAAE,IAAI,CACb,MAAM,CAAE,GAAG,CAAC,CAAC,CAAC,KAAK,AACvB,CAAC,AAED,WAAW,cAAC,CAAC,AACT,WAAW,CAAE,GAAG,CAChB,KAAK,CAAE,IAAI,SAAS,CAAC,CACrB,eAAe,CAAE,IAAI,CACrB,UAAU,CAAE,MAAM,CAClB,UAAU,CAAE,IAAI,CAChB,MAAM,CAAE,CAAC,CAAC,IAAI,CACd,QAAQ,CAAE,MAAM,CAChB,aAAa,CAAE,QAAQ,CACvB,kBAAkB,CAAE,CAAC,CACrB,OAAO,CAAE,WAAW,CACpB,kBAAkB,CAAE,QAAQ,AAChC,CAAC,AAED,yBAAW,MAAM,AAAC,CAAC,AACf,KAAK,CAAE,OAAO,AAClB,CAAC,AAED,KAAK,cAAC,CAAC,AACH,OAAO,CAAE,IAAI,CACb,MAAM,CAAE,GAAG,CAAC,CAAC,CAAC,GAAG,AACrB,CAAC,AAED,KAAK,cAAC,CAAC,AACH,MAAM,CAAE,IAAI,CACZ,KAAK,CAAE,IAAI,AACf,CAAC,AAED,UAAU,cAAC,CAAC,AACR,QAAQ,CAAE,QAAQ,CAClB,SAAS,CAAE,CAAC,CACZ,SAAS,CAAE,CAAC,CACZ,UAAU,CAAE,KAAK,CACjB,MAAM,CAAE,CAAC,CAAC,IAAI,CACd,QAAQ,CAAE,MAAM,AACpB,CAAC,AAED,wBAAU,OAAO,AAAC,CAAC,AACf,OAAO,CAAE,EAAE,CACX,QAAQ,CAAE,QAAQ,CAClB,KAAK,CAAE,IAAI,CACX,MAAM,CAAE,IAAI,CACZ,GAAG,CAAE,KAAK,CACV,UAAU,CAAE;YACR,IAAI,SAAS,CAAC,CAAC;YACf,IAAI,SAAS,CAAC,CAAC;YACf,IAAI,WAAW,CAAC,CAAC;YACjB,IAAI,UAAU,CAAC;SAClB,CACD,gBAAgB,CAAE;YACd,IAAI,SAAS,CAAC,CAAC;YACf,IAAI,SAAS,CAAC,CAAC;YACf,IAAI,WAAW,CAAC,CAAC;YACjB,IAAI,UAAU,CAAC;SAClB,CACD,gBAAgB,CAAE;YACd,IAAI,SAAS,CAAC,CAAC;YACf,IAAI,SAAS,CAAC,CAAC;YACf,IAAI,WAAW,CAAC,CAAC;YACjB,IAAI,UAAU,CAAC;SAClB,CACD,gBAAgB,CAAE;YACd,IAAI,SAAS,CAAC,CAAC;YACf,IAAI,SAAS,CAAC,CAAC;YACf,IAAI,WAAW,CAAC,CAAC;YACjB,IAAI,UAAU,CAAC;SAClB,CACD,gBAAgB,CAAE;YACd,IAAI,SAAS,CAAC,CAAC;YACf,IAAI,SAAS,CAAC,CAAC;YACf,IAAI,WAAW,CAAC,CAAC;YACjB,IAAI,UAAU,CAAC;SAClB,AACL,CAAC,AAEO,YAAY,AAAE,CAAC,AACnB,UAAU,CAAE,CAAC,AACjB,CAAC,AAEO,YAAY,AAAE,CAAC,AACnB,UAAU,CAAE,CAAC,CACb,UAAU,CAAE,UAAU,AAC1B,CAAC,AAEO,qBAAqB,AAAE,CAAC,AAC5B,UAAU,CAAE,CAAC,AACjB,CAAC,AAEO,cAAc,AAAE,CAAC,AACrB,UAAU,CAAE,MAAM,AACtB,CAAC,AAED,KAAK,cAAC,CAAC,AACH,UAAU,CAAE,MAAM,CAClB,KAAK,CAAE,IAAI,AACf,CAAC"}`
};
var SingleNews = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let { article } = $$props;
  if ($$props.article === void 0 && $$bindings.article && article !== void 0)
    $$bindings.article(article);
  $$result.css.add(css$E);
  return `${validate_component(Paper, "Paper").$$render($$result, { class: "article", elevation: "3" }, {}, {
    default: () => `${validate_component(Title, "Title").$$render($$result, { class: "article-title" }, {}, {
      default: () => `<img class="${"icon svelte-z26sd2"}"${add_attribute("src", article.icon, 0)} alt="${"article thumbnial"}">
        ${article.link ? `<a${add_attribute("href", article.link, 0)} target="${"_blank"}" class="${"title-link svelte-z26sd2"}">${escape(article.title)}</a>` : `${escape(article.title)}`}`
    })}
    ${validate_component(Content, "Content").$$render($$result, {}, {}, {
      default: () => `<div class="${"body svelte-z26sd2"}"><div class="${"body-text svelte-z26sd2"}"><!-- HTML_TAG_START -->${article.article}<!-- HTML_TAG_END --></div></div>
        <hr>
        ${article.author ? `<span class="${"author"}">${escape(article.author)}</span>` : ``}
        <span class="${"date svelte-z26sd2"}">${escape(article.date)}</span>`
    })}`
  })}`;
});
var css$D = {
  code: ".button{color:#aaa;cursor:pointer;vertical-align:sub}.button:hover{color:#0082c3}.paginationBar.svelte-113z42p{display:flex;justify-content:space-between;width:100%;max-width:550px;margin:10px auto;text-align:center}.pg.svelte-113z42p{font-size:1.2em;padding:.4em;color:#aaa}.spacer.svelte-113z42p{padding:.4em 0;cursor:default;user-select:none}.dest.svelte-113z42p{cursor:pointer}.dest.svelte-113z42p:hover{color:#0082c3}.selected.svelte-113z42p{color:var(--blueOne);cursor:default;user-select:none}.placeholder.svelte-113z42p{width:24px}.totals.svelte-113z42p{font-style:italic;cursor:default;user-select:none;color:#bbb;font-size:0.8em;text-align:center}",
  map: `{"version":3,"file":"Pagination.svelte","sources":["Pagination.svelte"],"sourcesContent":["<script>\\n\\timport { Icon } from '@smui/tab';\\n    export let total, perPage, page, target, scroll = true;\\n\\n    let pageLabels = [];\\n\\n    $: totPages = Math.ceil(total / perPage);\\n\\n    const computePages = (curPage, pages) => {\\n        let tempPageLabels = []\\n        let before = false;\\n        let after = false;\\n        for(let i = 0; i < pages; i++) {\\n            if(i == 0 || i == (pages - 1) || ((curPage - 3) < i && i < (curPage +  3))) {\\n                tempPageLabels.push(i + 1);\\n            } else if(!before && (curPage - 3) < i) {\\n                before = true;\\n                tempPageLabels.push(\\"...\\");\\n            } else if(!after && i < (curPage +  3)) {\\n                after = true;\\n                tempPageLabels.push(\\"...\\");\\n            }\\n        }\\n        pageLabels = tempPageLabels;\\n    }\\n\\n    const changePage = (dest) => {\\n        if(scroll) {\\n            window.scrollTo({left: 0, top: target, behavior: 'smooth'});\\n        }\\n        page = dest;\\n    }\\n\\n    $: computePages(page, totPages);\\n<\/script>\\n\\n<style>\\n    :global(.button) {\\n        color: #aaa;\\n        cursor: pointer;\\n        vertical-align: sub;\\n    }\\n\\n    :global(.button:hover) {\\n        color: #0082c3;\\n    }\\n\\n    .paginationBar {\\n        display: flex;\\n        justify-content: space-between;\\n        width: 100%;\\n        max-width: 550px;\\n        margin: 10px auto;\\n        text-align: center;\\n    }\\n\\n    .pg {\\n        font-size: 1.2em;\\n        padding: .4em;\\n        color: #aaa;\\n    }\\n    \\n    .spacer {\\n        padding: .4em 0;\\n        cursor: default;\\n        user-select: none;\\n    }\\n\\n    .dest {\\n        cursor: pointer;\\n    }\\n\\n    .dest:hover {\\n        color: #0082c3;\\n    }\\n\\n    .selected {\\n        color: var(--blueOne);\\n        cursor: default;\\n        user-select: none;\\n    }\\n\\n    .placeholder {\\n        width: 24px;\\n    }\\n\\n    .totals {\\n        font-style: italic;\\n        cursor: default;\\n        user-select: none;\\n        color: #bbb;\\n        font-size: 0.8em;\\n        text-align: center;\\n    }\\n</style>\\n{#if total > 0 && totPages > 1 }\\n    <div class=\\"paginationBar\\">\\n        {#if page > 0}\\n            <Icon class=\\"material-icons button\\" on:click={() => changePage(page - 1)}>chevron_left</Icon>\\n        {:else}\\n            <span class=\\"placeholder\\" />\\n        {/if}\\n        <div class=\\"numbers\\">\\n            {#each pageLabels as pageLabel}\\n                {#if pageLabel == page + 1}\\n                    <span class=\\"selected pg\\">{pageLabel}</span>\\n                {:else if pageLabel == \\"...\\"}\\n                    <span class=\\"pg spacer\\">{pageLabel}</span>\\n                {:else}\\n                    <span class=\\"dest pg\\" on:click={() => changePage(pageLabel - 1)}>{pageLabel}</span>\\n                {/if}\\n            {/each}\\n        </div>\\n        {#if page < totPages - 1}\\n            <Icon class=\\"material-icons button\\" on:click={() => changePage(page + 1)}>chevron_right</Icon>\\n        {:else}\\n            <span class=\\"placeholder\\" />\\n        {/if}\\n    </div>\\n    <div class=\\"totals\\">{page * perPage + 1} - {page + 1 == totPages ? total : (page + 1) * perPage} of {total}</div>\\n{/if}\\n"],"names":[],"mappings":"AAqCY,OAAO,AAAE,CAAC,AACd,KAAK,CAAE,IAAI,CACX,MAAM,CAAE,OAAO,CACf,cAAc,CAAE,GAAG,AACvB,CAAC,AAEO,aAAa,AAAE,CAAC,AACpB,KAAK,CAAE,OAAO,AAClB,CAAC,AAED,cAAc,eAAC,CAAC,AACZ,OAAO,CAAE,IAAI,CACb,eAAe,CAAE,aAAa,CAC9B,KAAK,CAAE,IAAI,CACX,SAAS,CAAE,KAAK,CAChB,MAAM,CAAE,IAAI,CAAC,IAAI,CACjB,UAAU,CAAE,MAAM,AACtB,CAAC,AAED,GAAG,eAAC,CAAC,AACD,SAAS,CAAE,KAAK,CAChB,OAAO,CAAE,IAAI,CACb,KAAK,CAAE,IAAI,AACf,CAAC,AAED,OAAO,eAAC,CAAC,AACL,OAAO,CAAE,IAAI,CAAC,CAAC,CACf,MAAM,CAAE,OAAO,CACf,WAAW,CAAE,IAAI,AACrB,CAAC,AAED,KAAK,eAAC,CAAC,AACH,MAAM,CAAE,OAAO,AACnB,CAAC,AAED,oBAAK,MAAM,AAAC,CAAC,AACT,KAAK,CAAE,OAAO,AAClB,CAAC,AAED,SAAS,eAAC,CAAC,AACP,KAAK,CAAE,IAAI,SAAS,CAAC,CACrB,MAAM,CAAE,OAAO,CACf,WAAW,CAAE,IAAI,AACrB,CAAC,AAED,YAAY,eAAC,CAAC,AACV,KAAK,CAAE,IAAI,AACf,CAAC,AAED,OAAO,eAAC,CAAC,AACL,UAAU,CAAE,MAAM,CAClB,MAAM,CAAE,OAAO,CACf,WAAW,CAAE,IAAI,CACjB,KAAK,CAAE,IAAI,CACX,SAAS,CAAE,KAAK,CAChB,UAAU,CAAE,MAAM,AACtB,CAAC"}`
};
var Pagination = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let totPages;
  let { total, perPage: perPage2, page, target, scroll = true } = $$props;
  let pageLabels = [];
  const computePages = (curPage, pages) => {
    let tempPageLabels = [];
    let before = false;
    let after = false;
    for (let i = 0; i < pages; i++) {
      if (i == 0 || i == pages - 1 || curPage - 3 < i && i < curPage + 3) {
        tempPageLabels.push(i + 1);
      } else if (!before && curPage - 3 < i) {
        before = true;
        tempPageLabels.push("...");
      } else if (!after && i < curPage + 3) {
        after = true;
        tempPageLabels.push("...");
      }
    }
    pageLabels = tempPageLabels;
  };
  if ($$props.total === void 0 && $$bindings.total && total !== void 0)
    $$bindings.total(total);
  if ($$props.perPage === void 0 && $$bindings.perPage && perPage2 !== void 0)
    $$bindings.perPage(perPage2);
  if ($$props.page === void 0 && $$bindings.page && page !== void 0)
    $$bindings.page(page);
  if ($$props.target === void 0 && $$bindings.target && target !== void 0)
    $$bindings.target(target);
  if ($$props.scroll === void 0 && $$bindings.scroll && scroll !== void 0)
    $$bindings.scroll(scroll);
  $$result.css.add(css$D);
  totPages = Math.ceil(total / perPage2);
  {
    computePages(page, totPages);
  }
  return `${total > 0 && totPages > 1 ? `<div class="${"paginationBar svelte-113z42p"}">${page > 0 ? `${validate_component(CommonIcon, "Icon").$$render($$result, { class: "material-icons button" }, {}, { default: () => `chevron_left` })}` : `<span class="${"placeholder svelte-113z42p"}"></span>`}
        <div class="${"numbers"}">${each(pageLabels, (pageLabel) => `${pageLabel == page + 1 ? `<span class="${"selected pg svelte-113z42p"}">${escape(pageLabel)}</span>` : `${pageLabel == "..." ? `<span class="${"pg spacer svelte-113z42p"}">${escape(pageLabel)}</span>` : `<span class="${"dest pg svelte-113z42p"}">${escape(pageLabel)}</span>`}`}`)}</div>
        ${page < totPages - 1 ? `${validate_component(CommonIcon, "Icon").$$render($$result, { class: "material-icons button" }, {}, { default: () => `chevron_right` })}` : `<span class="${"placeholder svelte-113z42p"}"></span>`}</div>
    <div class="${"totals svelte-113z42p"}">${escape(page * perPage2 + 1)} - ${escape(page + 1 == totPages ? total : (page + 1) * perPage2)} of ${escape(total)}</div>` : ``}`;
});
var css$C = {
  code: ".pageBody.svelte-csdux7{position:relative;z-index:1;margin-bottom:60px}h4.svelte-csdux7{text-align:center}.articles.svelte-csdux7{width:85%;margin:0 auto;max-width:800px}.article{margin:20px auto}",
  map: '{"version":3,"file":"index.svelte","sources":["index.svelte"],"sourcesContent":["<script>\\n\\timport SingleNews from \\"./SingleNews.svelte\\"\\n\\timport Pagination from \\"../Pagination.svelte\\"\\n    import { getNews } from \\"$lib/utils/helper\\";\\n\\n    export let news;\\n    let {articles, fresh} = news;\\n\\n    const getFreshNews = async () => {\\n        const newNews = await getNews(true);\\n        articles = newNews.articles;\\n    }\\n\\n    if(!fresh) {\\n        getFreshNews();\\n    }\\n\\n    const perPage = 10;\\n    let total = 0;\\n    let page = 0;\\n    let displayArticles = [];\\n\\n    const calculateTotal = (a) => {\\n        total = a.length;\\n    }\\n\\n    $: calculateTotal(articles);\\n\\n    const changePage = (dest) => {\\n        const start = dest * perPage;\\n        const end = (dest + 1) * perPage;\\n        displayArticles = articles.slice(start, end);\\n        page = dest;\\n    }\\n\\n    $: changePage(page);\\n\\n    let el;\\n\\n    $: top = el?.getBoundingClientRect() ? el?.getBoundingClientRect().top  : 0;\\n<\/script>\\n\\n<style>\\n    .pageBody {\\n        position: relative;\\n        z-index: 1;\\n        margin-bottom: 60px;\\n    }\\n\\n    h4 {\\n        text-align: center;\\n    }\\n\\n    .articles {\\n        width: 85%;\\n        margin: 0 auto;\\n        max-width: 800px;\\n    }\\n\\n    :global(.article) {\\n        margin: 20px auto;\\n    }\\n</style>\\n\\n<div class=\\"pageBody\\">\\n    <div class=\\"banner\\" bind:this={el}>\\n        <h4>Fantasy Football News and Updates</h4>\\n    </div>\\n\\n    <div class=\\"articles\\">\\n        {#each displayArticles as article}\\n            <SingleNews {article} />\\n        {/each}\\n        <Pagination {perPage} {total} bind:page={page} target={top} />\\n    </div>\\n</div>"],"names":[],"mappings":"AA2CI,SAAS,cAAC,CAAC,AACP,QAAQ,CAAE,QAAQ,CAClB,OAAO,CAAE,CAAC,CACV,aAAa,CAAE,IAAI,AACvB,CAAC,AAED,EAAE,cAAC,CAAC,AACA,UAAU,CAAE,MAAM,AACtB,CAAC,AAED,SAAS,cAAC,CAAC,AACP,KAAK,CAAE,GAAG,CACV,MAAM,CAAE,CAAC,CAAC,IAAI,CACd,SAAS,CAAE,KAAK,AACpB,CAAC,AAEO,QAAQ,AAAE,CAAC,AACf,MAAM,CAAE,IAAI,CAAC,IAAI,AACrB,CAAC"}'
};
var perPage$2 = 10;
var News = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let top;
  let { news: news2 } = $$props;
  let { articles, fresh } = news2;
  const getFreshNews = async () => {
    const newNews = await getNews(true);
    articles = newNews.articles;
  };
  if (!fresh) {
    getFreshNews();
  }
  let total = 0;
  let page = 0;
  let displayArticles = [];
  const calculateTotal = (a) => {
    total = a.length;
  };
  const changePage = (dest) => {
    const start = dest * perPage$2;
    const end = (dest + 1) * perPage$2;
    displayArticles = articles.slice(start, end);
    page = dest;
  };
  let el;
  if ($$props.news === void 0 && $$bindings.news && news2 !== void 0)
    $$bindings.news(news2);
  $$result.css.add(css$C);
  let $$settled;
  let $$rendered;
  do {
    $$settled = true;
    {
      calculateTotal(articles);
    }
    {
      changePage(page);
    }
    top = (el == null ? void 0 : el.getBoundingClientRect()) ? el == null ? void 0 : el.getBoundingClientRect().top : 0;
    $$rendered = `<div class="${"pageBody svelte-csdux7"}"><div class="${"banner"}"${add_attribute("this", el, 0)}><h4 class="${"svelte-csdux7"}">Fantasy Football News and Updates</h4></div>

    <div class="${"articles svelte-csdux7"}">${each(displayArticles, (article) => `${validate_component(SingleNews, "SingleNews").$$render($$result, { article }, {}, {})}`)}
        ${validate_component(Pagination, "Pagination").$$render($$result, { perPage: perPage$2, total, target: top, page }, {
      page: ($$value) => {
        page = $$value;
        $$settled = false;
      }
    }, {})}</div></div>`;
  } while (!$$settled);
  return $$rendered;
});
var css$B = {
  code: ".pageBody.svelte-11v79lo{position:relative;z-index:1}.list{width:90%;max-width:800px;border:1px solid\n        var(--mdc-theme-text-hint-on-background, var(--d7d7d7));margin:15px auto;padding:0 !important;box-shadow:0px 3px 3px -2px var(--boxShadowOne), 0px 3px 4px 0px var(--boxShadowTwo), 0px 1px 8px 0px var(--boxShadowThree)}.linkText{font-size:1.1em}a.svelte-11v79lo{color:var(--g555);font-size:1.1em;text-decoration:none}h4.svelte-11v79lo{text-align:center}.disclaimer.svelte-11v79lo{color:#888;text-align:center}",
  map: '{"version":3,"file":"Resources.svelte","sources":["Resources.svelte"],"sourcesContent":["<script>\\n    import List, { Item, Graphic, Separator, Text } from \'@smui/list\';\\nimport { dynasty } from \'./utils/helper\';\\n\\n    const today = new Date();\\n    const resources = [\\n        {\\n            name: \\"FTN Fantasy\\",\\n            url: \\"https://www.ftnfantasy.com/nfl\\",\\n            icon: \\"insights\\",\\n            premium: true,\\n            separator: true,\\n        },\\n        {\\n            name: \\"The Fantasy Footballers\\",\\n            url: \\"https://www.thefantasyfootballers.com/\\",\\n            icon: \\"podcasts\\",\\n            premium: true,\\n            separator: true,\\n        },\\n        {\\n            name: \\"FantasyPros Dynasty Trade Value Chart\\",\\n            url: `https://www.fantasypros.com/${today.getFullYear()}/${today.getMonth() + 1}/fantasy-football-rankings-dynasty-trade-value-chart-${today.toLocaleString(\'default\', { month: \'long\' }).toLowerCase()}-${today.getFullYear()}-update/`,\\n            icon: \\"assessment\\",\\n            premium: false,\\n            separator: true,\\n            dynastyOnly: true,\\n        },\\n        {\\n            name: \\"DynastyProcess Trade Calculator\\",\\n            url: \\"https://apps.dynastyprocess.com/calculator/\\",\\n            icon: \\"calculate\\",\\n            premium: false,\\n            separator: true,\\n            dynastyOnly: true,\\n        },\\n        {\\n            name: \\"Dynasty League Football\\",\\n            url: \\"https://dynastyleaguefootball.com/\\",\\n            icon: \\"insights\\",\\n            premium: true,\\n            separator: true,\\n            dynastyOnly: true,\\n        },\\n        {\\n            name: \\"Reddit Dynasty Fantasy Football\\",\\n            url: \\"https://www.reddit.com/r/DynastyFF/\\",\\n            icon: \\"article\\",\\n            premium: false,\\n            separator: true,\\n            dynastyOnly: true,\\n        },\\n        {\\n            name: \\"Reddit Fantasy Football\\",\\n            url: \\"https://www.reddit.com/r/fantasyfootball/\\",\\n            icon: \\"article\\",\\n            premium: false,\\n            separator: true,\\n            redraftOnly: true,\\n        },\\n        {\\n            name: \\"Dynasty 101 Trade Calculator\\",\\n            url: \\"https://dynasty101.com/trade-calculator/\\",\\n            icon: \\"calculate\\",\\n            premium: false,\\n            separator: true,\\n            dynastyOnly: true,\\n        },\\n        {\\n            name: \\"Dynasty Nerds GM\\",\\n            url: \\"https://gm.dynastynerds.com/\\",\\n            icon: \\"insights\\",\\n            premium: true,\\n            separator: true,\\n            dynastyOnly: true,\\n        },\\n        {\\n            name: \\"Fantasy Football Trade Analyzer\\",\\n            url: `https://fantasyfootballcalculator.com/trade-analyzer`,\\n            icon: \\"calculate\\",\\n            premium: false,\\n            separator: true,\\n            redraftOnly: true,\\n        },\\n        {\\n            name: \\"Reddit FF Trade Analyzer\\",\\n            url: \\"https://www.reddit.com/r/TradeAnalyzerFF/\\",\\n            icon: \\"assessment\\",\\n            premium: false,\\n            separator: false,\\n        },\\n    ];\\n<\/script>\\n\\n<style>\\n    .pageBody {\\n        position: relative;\\n        z-index: 1;\\n    }\\n\\n    :global(.list) {\\n        width: 90%;\\n        max-width: 800px;\\n        border: 1px solid\\n        var(--mdc-theme-text-hint-on-background, var(--d7d7d7));\\n        margin: 15px auto;\\n        padding: 0 !important;\\n        box-shadow: 0px 3px 3px -2px var(--boxShadowOne), 0px 3px 4px 0px var(--boxShadowTwo), 0px 1px 8px 0px var(--boxShadowThree);\\n    }\\n\\n\\n    :global(.linkText) {\\n        font-size: 1.1em;\\n    }\\n\\n    a {\\n        color: var(--g555);\\n        font-size: 1.1em;\\n        text-decoration: none;\\n    }\\n\\n    h4 {\\n        text-align: center;\\n    }\\n\\n    .disclaimer {\\n        color: #888;\\n        text-align: center;\\n    }\\n</style>\\n\\n<div class=\\"pageBody\\">\\n    <div class=\\"banner\\">\\n        <h4>Helpful Dynasty Resources</h4>\\n    </div>\\n\\n    <List class=\\"list\\" dense>\\n        {#each resources as resource}\\n            {#if resource.dynastyOnly && dynasty}\\n                <a target=\\"_blank\\" href=\\"{resource.url}\\">\\n                    <Item>\\n                        {#if resource.icon}\\n                            <Graphic class=\\"material-icons\\">{resource.icon}</Graphic>\\n                        {/if}\\n                        <Text class=\\"linkText\\">{resource.name}{resource.premium ? \\"*\\" : \\"\\"}</Text>\\n                    </Item>\\n                    {#if resource.separator}\\n                        <Separator />\\n                    {/if}\\n                </a>\\n            {:else if resource.redraftOnly && !dynasty}\\n                <a target=\\"_blank\\" href=\\"{resource.url}\\">\\n                    <Item>\\n                        {#if resource.icon}\\n                            <Graphic class=\\"material-icons\\">{resource.icon}</Graphic>\\n                        {/if}\\n                        <Text class=\\"linkText\\">{resource.name}{resource.premium ? \\"*\\" : \\"\\"}</Text>\\n                    </Item>\\n                    {#if resource.separator}\\n                        <Separator />\\n                    {/if}\\n                </a>\\n            {:else if !resource.redraftOnly && !resource.dynastyOnly}\\n                <a target=\\"_blank\\" href=\\"{resource.url}\\">\\n                    <Item>\\n                        {#if resource.icon}\\n                            <Graphic class=\\"material-icons\\">{resource.icon}</Graphic>\\n                        {/if}\\n                        <Text class=\\"linkText\\">{resource.name}{resource.premium ? \\"*\\" : \\"\\"}</Text>\\n                    </Item>\\n                    {#if resource.separator}\\n                        <Separator />\\n                    {/if}\\n                </a>\\n            {/if}\\n        {/each}\\n    </List>\\n    <p class=\\"disclaimer\\">*Some or all content is behind a paywall</p>\\n</div>"],"names":[],"mappings":"AA+FI,SAAS,eAAC,CAAC,AACP,QAAQ,CAAE,QAAQ,CAClB,OAAO,CAAE,CAAC,AACd,CAAC,AAEO,KAAK,AAAE,CAAC,AACZ,KAAK,CAAE,GAAG,CACV,SAAS,CAAE,KAAK,CAChB,MAAM,CAAE,GAAG,CAAC,KAAK;QACjB,IAAI,mCAAmC,CAAC,cAAc,CAAC,CACvD,MAAM,CAAE,IAAI,CAAC,IAAI,CACjB,OAAO,CAAE,CAAC,CAAC,UAAU,CACrB,UAAU,CAAE,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI,CAAC,IAAI,cAAc,CAAC,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI,cAAc,CAAC,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI,gBAAgB,CAAC,AAChI,CAAC,AAGO,SAAS,AAAE,CAAC,AAChB,SAAS,CAAE,KAAK,AACpB,CAAC,AAED,CAAC,eAAC,CAAC,AACC,KAAK,CAAE,IAAI,MAAM,CAAC,CAClB,SAAS,CAAE,KAAK,CAChB,eAAe,CAAE,IAAI,AACzB,CAAC,AAED,EAAE,eAAC,CAAC,AACA,UAAU,CAAE,MAAM,AACtB,CAAC,AAED,WAAW,eAAC,CAAC,AACT,KAAK,CAAE,IAAI,CACX,UAAU,CAAE,MAAM,AACtB,CAAC"}'
};
var Resources = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  const today = new Date();
  const resources = [
    {
      name: "FTN Fantasy",
      url: "https://www.ftnfantasy.com/nfl",
      icon: "insights",
      premium: true,
      separator: true
    },
    {
      name: "The Fantasy Footballers",
      url: "https://www.thefantasyfootballers.com/",
      icon: "podcasts",
      premium: true,
      separator: true
    },
    {
      name: "FantasyPros Dynasty Trade Value Chart",
      url: `https://www.fantasypros.com/${today.getFullYear()}/${today.getMonth() + 1}/fantasy-football-rankings-dynasty-trade-value-chart-${today.toLocaleString("default", { month: "long" }).toLowerCase()}-${today.getFullYear()}-update/`,
      icon: "assessment",
      premium: false,
      separator: true,
      dynastyOnly: true
    },
    {
      name: "DynastyProcess Trade Calculator",
      url: "https://apps.dynastyprocess.com/calculator/",
      icon: "calculate",
      premium: false,
      separator: true,
      dynastyOnly: true
    },
    {
      name: "Dynasty League Football",
      url: "https://dynastyleaguefootball.com/",
      icon: "insights",
      premium: true,
      separator: true,
      dynastyOnly: true
    },
    {
      name: "Reddit Dynasty Fantasy Football",
      url: "https://www.reddit.com/r/DynastyFF/",
      icon: "article",
      premium: false,
      separator: true,
      dynastyOnly: true
    },
    {
      name: "Reddit Fantasy Football",
      url: "https://www.reddit.com/r/fantasyfootball/",
      icon: "article",
      premium: false,
      separator: true,
      redraftOnly: true
    },
    {
      name: "Dynasty 101 Trade Calculator",
      url: "https://dynasty101.com/trade-calculator/",
      icon: "calculate",
      premium: false,
      separator: true,
      dynastyOnly: true
    },
    {
      name: "Dynasty Nerds GM",
      url: "https://gm.dynastynerds.com/",
      icon: "insights",
      premium: true,
      separator: true,
      dynastyOnly: true
    },
    {
      name: "Fantasy Football Trade Analyzer",
      url: `https://fantasyfootballcalculator.com/trade-analyzer`,
      icon: "calculate",
      premium: false,
      separator: true,
      redraftOnly: true
    },
    {
      name: "Reddit FF Trade Analyzer",
      url: "https://www.reddit.com/r/TradeAnalyzerFF/",
      icon: "assessment",
      premium: false,
      separator: false
    }
  ];
  $$result.css.add(css$B);
  return `<div class="${"pageBody svelte-11v79lo"}"><div class="${"banner"}"><h4 class="${"svelte-11v79lo"}">Helpful Dynasty Resources</h4></div>

    ${validate_component(List, "List").$$render($$result, { class: "list", dense: true }, {}, {
    default: () => `${each(resources, (resource) => `${resource.dynastyOnly && dynasty ? `<a target="${"_blank"}"${add_attribute("href", resource.url, 0)} class="${"svelte-11v79lo"}">${validate_component(Item, "Item").$$render($$result, {}, {}, {
      default: () => `${resource.icon ? `${validate_component(Graphic, "Graphic").$$render($$result, { class: "material-icons" }, {}, {
        default: () => `${escape(resource.icon)}`
      })}` : ``}
                        ${validate_component(Text, "Text").$$render($$result, { class: "linkText" }, {}, {
        default: () => `${escape(resource.name)}${escape(resource.premium ? "*" : "")}`
      })}
                    `
    })}
                    ${resource.separator ? `${validate_component(Separator, "Separator").$$render($$result, {}, {}, {})}` : ``}
                </a>` : `${resource.redraftOnly && !dynasty ? `<a target="${"_blank"}"${add_attribute("href", resource.url, 0)} class="${"svelte-11v79lo"}">${validate_component(Item, "Item").$$render($$result, {}, {}, {
      default: () => `${resource.icon ? `${validate_component(Graphic, "Graphic").$$render($$result, { class: "material-icons" }, {}, {
        default: () => `${escape(resource.icon)}`
      })}` : ``}
                        ${validate_component(Text, "Text").$$render($$result, { class: "linkText" }, {}, {
        default: () => `${escape(resource.name)}${escape(resource.premium ? "*" : "")}`
      })}
                    `
    })}
                    ${resource.separator ? `${validate_component(Separator, "Separator").$$render($$result, {}, {}, {})}` : ``}
                </a>` : `${!resource.redraftOnly && !resource.dynastyOnly ? `<a target="${"_blank"}"${add_attribute("href", resource.url, 0)} class="${"svelte-11v79lo"}">${validate_component(Item, "Item").$$render($$result, {}, {}, {
      default: () => `${resource.icon ? `${validate_component(Graphic, "Graphic").$$render($$result, { class: "material-icons" }, {}, {
        default: () => `${escape(resource.icon)}`
      })}` : ``}
                        ${validate_component(Text, "Text").$$render($$result, { class: "linkText" }, {}, {
        default: () => `${escape(resource.name)}${escape(resource.premium ? "*" : "")}`
      })}
                    `
    })}
                    ${resource.separator ? `${validate_component(Separator, "Separator").$$render($$result, {}, {}, {})}` : ``}
                </a>` : ``}`}`}`)}`
  })}
    <p class="${"disclaimer svelte-11v79lo"}">*Some or all content is behind a paywall</p></div>`;
});
var css$A = {
  code: ".svelte-zcagvz{color:var(--g555)}h3.svelte-zcagvz{margin:2.5em 0 1.5em}.awards.svelte-zcagvz{display:block;position:relative;width:100%;z-index:1}#podium.svelte-zcagvz{width:600px;height:500px;position:relative;margin:10px auto 30px}.podiumImage.svelte-zcagvz{position:absolute;bottom:0;left:0;width:100%;height:auto;z-index:3}.champ.svelte-zcagvz{position:absolute;width:20%;height:auto;transform:translate(-50%, -50%);border-radius:100%;border:1px solid var(--bbb);background-color:var(--fff)}.laurel.svelte-zcagvz{position:absolute;width:33%;height:auto;transform:translate(-50%, -50%);bottom:56.6%;left:50%;pointer-events:none}.first.svelte-zcagvz{bottom:70%;left:50%}.second.svelte-zcagvz{bottom:43%;left:20%}.third.svelte-zcagvz{bottom:39%;left:80%}h3.svelte-zcagvz{text-align:center}.leaderBlock.svelte-zcagvz{position:relative;width:80px;height:119px;margin:15px auto}.divisions.svelte-zcagvz{display:flex;justify-content:space-around}.divisionLeader.svelte-zcagvz{position:absolute;width:70px;height:70px;transform:translate(-50%, 0%);top:0;left:50%;border-radius:100%;border:1px solid var(--bbb);z-index:3}.medal.svelte-zcagvz{position:absolute;width:40px;height:auto;transform:translate(-50%, 0%);bottom:0;left:50%;z-index:2}.toiletBowl.svelte-zcagvz{position:relative;width:215px;height:190px;margin:10px auto}.toiletWinner.svelte-zcagvz{position:absolute;width:65px;height:65px;transform:translate(-50%, 0%);top:20px;left:55%;border-radius:100%;border:1px solid var(--bbb);z-index:3}.toilet.svelte-zcagvz{position:absolute;width:100%;height:auto;transform:translate(-50%, 0%);bottom:0;left:50%}.label.svelte-zcagvz{white-space:nowrap;line-height:1.1em;text-align:center;min-height:34px;display:flex;flex-direction:column;justify-content:center;position:absolute;transform:translate(-50%, -50%);padding:6px 30px;background-color:var(--fff);border:1px solid var(--bbb);box-shadow:0px 3px 3px -2px var(--boxShadowOne), 0px 3px 4px 0px var(--boxShadowTwo), 0px 1px 8px 0px var(--boxShadowThree)}.firstLabel.svelte-zcagvz{bottom:60%;left:50%}.secondLabel.svelte-zcagvz{bottom:40%;left:20%}.thirdLabel.svelte-zcagvz{bottom:36%;left:80%}.genLabel.svelte-zcagvz{white-space:nowrap;line-height:1.1em;min-height:34px;display:inline-flex;flex-direction:column;justify-content:center;text-align:center;margin:15px auto 20px;padding:6px 30px;background-color:var(--fff);border:1px solid var(--bbb);box-shadow:0px 3px 3px -2px var(--boxShadowOne), 0px 3px 4px 0px var(--boxShadowTwo), 0px 1px 8px 0px var(--boxShadowThree)}.division.svelte-zcagvz{text-align:center}.toiletParent.svelte-zcagvz{width:100%;text-align:center;padding:25px 0 40px;margin-top:30px;box-shadow:0 12px 9px -12px rgba(0,0,0,0.4)}.banner.svelte-zcagvz{display:block;width:65%;max-width:450px;margin:20px auto 0}.toilet-banner.svelte-zcagvz{display:block;width:50%;max-width:350px;margin:20px auto 0}.clickable.svelte-zcagvz{cursor:pointer}.curOwner{font-size:0.75em;color:var(--bbb);font-style:italic}@media(max-width: 680px){.label.svelte-zcagvz{padding:6px 8px}.genLabel.svelte-zcagvz{padding:6px 8px}}@media(max-width: 630px){.label.svelte-zcagvz{font-size:0.9em}.genLabel.svelte-zcagvz{font-size:0.9em}}@media(max-width: 610px){#podium.svelte-zcagvz{width:500px;height:417px;position:relative;margin:10px auto 30px}.firstLabel.svelte-zcagvz{bottom:58%}.secondLabel.svelte-zcagvz{bottom:35%}.thirdLabel.svelte-zcagvz{bottom:31%}}@media(max-width: 535px){.label.svelte-zcagvz{font-size:0.8em}.genLabel.svelte-zcagvz{font-size:0.8em}}@media(max-width: 520px){.label.svelte-zcagvz{font-size:0.7em;padding:2px 4px}.genLabel.svelte-zcagvz{font-size:0.7em;padding:2px 4px}}@media(max-width: 510px){#podium.svelte-zcagvz{width:400px;height:333px}}@media(max-width: 425px){.label.svelte-zcagvz{font-size:0.6em}.genLabel.svelte-zcagvz{font-size:0.6em}}@media(max-width: 410px){#podium.svelte-zcagvz{width:300px;height:250px}.firstLabel.svelte-zcagvz{bottom:53%}.secondLabel.svelte-zcagvz{bottom:31%}.thirdLabel.svelte-zcagvz{bottom:27%}}@media(max-width: 329px){.label.svelte-zcagvz{font-size:0.5em}.genLabel.svelte-zcagvz{font-size:0.5em}}",
  map: '{"version":3,"file":"Awards.svelte","sources":["Awards.svelte"],"sourcesContent":["<script>\\n\\timport {cleanName, gotoManager} from \'$lib/utils/helper\';\\n\\texport let podium, currentManagers;\\n\\n\\tconst { year, champion, second, third, divisions, toilet } = podium;\\n\\n\\tconst getNames = (name, rosterID) => {\\n\\t\\tif(cleanName(name) != cleanName(currentManagers[rosterID].name)) {\\n\\t\\t\\treturn `${name}<div class=\\"curOwner\\">(${currentManagers[rosterID].name})</div>`;\\n\\t\\t}\\n\\t\\treturn name;\\n\\t}\\n<\/script>\\n\\n<style>\\n\\t* {\\n\\t\\tcolor: var(--g555);\\n\\t}\\n\\n\\th3 {\\n\\t\\tmargin: 2.5em 0 1.5em;\\n\\t}\\n\\n\\t.awards {\\n\\t\\tdisplay: block;\\n\\t\\tposition: relative;\\n\\t\\twidth: 100%;\\n\\t\\tz-index: 1;\\n\\t}\\n\\n\\t#podium {\\n\\t\\twidth: 600px;\\n\\t\\theight: 500px;\\n\\t\\tposition: relative;\\n\\t\\tmargin: 10px auto 30px;\\n\\t}\\n\\n\\t.podiumImage {\\n\\t\\tposition: absolute;\\n\\t\\tbottom: 0;\\n\\t\\tleft: 0;\\n\\t\\twidth: 100%;\\n\\t\\theight: auto;\\n\\t\\tz-index: 3;\\n\\t}\\n\\n\\t.champ {\\n\\t\\tposition: absolute;\\n\\t\\twidth: 20%;\\n\\t\\theight: auto;\\n\\t\\ttransform: translate(-50%, -50%);\\n\\t\\tborder-radius: 100%;\\n\\t\\tborder: 1px solid var(--bbb);\\n\\t\\tbackground-color: var(--fff);\\n\\t}\\n\\n\\t.laurel {\\n\\t\\tposition: absolute;\\n\\t\\twidth: 33%;\\n\\t\\theight: auto;\\n\\t\\ttransform: translate(-50%, -50%);\\n\\t\\tbottom: 56.6%;\\n\\t\\tleft: 50%;\\n\\t\\tpointer-events: none;\\n\\t}\\n\\n\\t.first {\\n\\t\\tbottom: 70%;\\n\\t\\tleft: 50%;\\n\\t}\\n\\n\\t.second {\\n\\t\\tbottom: 43%;\\n\\t\\tleft: 20%;\\n\\t}\\n\\n\\t.third {\\n\\t\\tbottom: 39%;\\n\\t\\tleft: 80%;\\n\\t}\\n\\n\\th3 {\\n\\t\\ttext-align: center;\\n\\t}\\n\\n\\t.leaderBlock {\\n\\t\\tposition: relative;\\n\\t\\twidth: 80px;\\n\\t\\theight: 119px;\\n\\t\\tmargin: 15px auto;\\n\\t}\\n\\n\\t.divisions {\\n\\t\\tdisplay: flex;\\n\\t\\tjustify-content: space-around;\\n\\t}\\n\\n\\t.divisionLeader {\\n\\t\\tposition: absolute;\\n\\t\\twidth: 70px;\\n\\t\\theight: 70px;\\n\\t\\ttransform: translate(-50%, 0%);\\n\\t\\ttop: 0;\\n\\t\\tleft: 50%;\\n\\t\\tborder-radius: 100%;\\n\\t\\tborder: 1px solid var(--bbb);\\n\\t\\tz-index: 3;\\n\\t}\\n\\n\\t.medal {\\n\\t\\tposition: absolute;\\n\\t\\twidth: 40px;\\n\\t\\theight: auto;\\n\\t\\ttransform: translate(-50%, 0%);\\n\\t\\tbottom: 0;\\n\\t\\tleft: 50%;\\n\\t\\tz-index: 2;\\n\\t}\\n\\n\\t.toiletBowl {\\n\\t\\tposition: relative;\\n\\t\\twidth: 215px;\\n\\t\\theight: 190px;\\n\\t\\tmargin: 10px auto;\\n\\t}\\n\\n\\t.toiletWinner {\\n\\t\\tposition: absolute;\\n\\t\\twidth: 65px;\\n\\t\\theight: 65px;\\n\\t\\ttransform: translate(-50%, 0%);\\n\\t\\ttop: 20px;\\n\\t\\tleft: 55%;\\n\\t\\tborder-radius: 100%;\\n\\t\\tborder: 1px solid var(--bbb);\\n\\t\\tz-index: 3;\\n\\t}\\n\\n\\t.toilet {\\n\\t\\tposition: absolute;\\n\\t\\twidth: 100%;\\n\\t\\theight: auto;\\n\\t\\ttransform: translate(-50%, 0%);\\n\\t\\tbottom: 0;\\n\\t\\tleft: 50%;\\n\\t}\\n\\n\\t.label {\\n\\t\\twhite-space: nowrap;\\n\\t\\tline-height: 1.1em;\\n\\t\\ttext-align: center;\\n\\t\\tmin-height: 34px;\\n\\t\\tdisplay: flex;\\n\\t\\tflex-direction: column;\\n\\t\\tjustify-content: center;\\n\\t\\tposition: absolute;\\n\\t\\ttransform: translate(-50%, -50%);\\n\\t\\tpadding: 6px 30px;\\n\\t\\tbackground-color: var(--fff);\\n\\t\\tborder: 1px solid var(--bbb);\\n        box-shadow: 0px 3px 3px -2px var(--boxShadowOne), 0px 3px 4px 0px var(--boxShadowTwo), 0px 1px 8px 0px var(--boxShadowThree);\\n\\t}\\n\\n\\t.firstLabel {\\n\\t\\tbottom: 60%;\\n\\t\\tleft: 50%;\\n\\t}\\n\\n\\t.secondLabel {\\n\\t\\tbottom: 40%;\\n\\t\\tleft: 20%;\\n\\t}\\n\\n\\t.thirdLabel {\\n\\t\\tbottom: 36%;\\n\\t\\tleft: 80%;\\n\\t}\\n\\n\\t.genLabel {\\n\\t\\twhite-space: nowrap;\\n\\t\\tline-height: 1.1em;\\n\\t\\tmin-height: 34px;\\n\\t\\tdisplay: inline-flex;\\n\\t\\tflex-direction: column;\\n\\t\\tjustify-content: center;\\n\\t\\ttext-align: center;\\n\\t\\tmargin: 15px auto 20px;\\n\\t\\tpadding: 6px 30px;\\n\\t\\tbackground-color: var(--fff);\\n\\t\\tborder: 1px solid var(--bbb);\\n\\t\\tbox-shadow: 0px 3px 3px -2px var(--boxShadowOne), 0px 3px 4px 0px var(--boxShadowTwo), 0px 1px 8px 0px var(--boxShadowThree);\\n\\t}\\n\\n\\t.division {\\n\\t\\ttext-align: center;\\n\\t}\\n\\n\\t.toiletParent {\\n\\t\\twidth: 100%;\\n\\t\\ttext-align: center;\\n\\t\\tpadding: 25px 0 40px;\\n\\t\\tmargin-top: 30px;\\n\\t\\tbox-shadow: 0 12px 9px -12px rgba(0,0,0,0.4);\\n\\t}\\n\\n\\t.banner {\\n\\t\\tdisplay: block;\\n\\t\\twidth: 65%;\\n\\t\\tmax-width: 450px;\\n\\t\\tmargin: 20px auto 0;\\n\\t}\\n\\n\\t.toilet-banner {\\n\\t\\tdisplay: block;\\n\\t\\twidth: 50%;\\n\\t\\tmax-width: 350px;\\n\\t\\tmargin: 20px auto 0;\\n\\t}\\n\\n\\t.clickable {\\n\\t\\tcursor: pointer;\\n\\t}\\n\\n\\t:global(.curOwner) {\\n\\t\\tfont-size: 0.75em;\\n\\t\\tcolor: var(--bbb);\\n\\t\\tfont-style: italic;\\n\\t}\\n\\n\\t@media (max-width: 680px) {\\n\\t\\t.label {\\n\\t\\t\\tpadding: 6px 8px;\\n\\t\\t}\\n\\t\\t.genLabel {\\n\\t\\t\\tpadding: 6px 8px;\\n\\t\\t}\\n\\t}\\n\\n\\t@media (max-width: 630px) {\\n\\t\\t.label {\\n\\t\\t\\tfont-size: 0.9em;\\n\\t\\t}\\n\\t\\t.genLabel {\\n\\t\\t\\tfont-size: 0.9em;\\n\\t\\t}\\n\\t}\\n\\n\\t@media (max-width: 610px) {\\n\\t\\t#podium {\\n\\t\\t\\twidth: 500px;\\n\\t\\t\\theight: 417px;\\n\\t\\t\\tposition: relative;\\n\\t\\t\\tmargin: 10px auto 30px;\\n\\t\\t}\\n\\n\\t\\t.firstLabel {\\n\\t\\t\\tbottom: 58%;\\n\\t\\t}\\n\\n\\t\\t.secondLabel {\\n\\t\\t\\tbottom: 35%;\\n\\t\\t}\\n\\n\\t\\t.thirdLabel {\\n\\t\\t\\tbottom: 31%;\\n\\t\\t}\\n\\t}\\n\\n\\t@media (max-width: 535px) {\\n\\t\\t.label {\\n\\t\\t\\tfont-size: 0.8em;\\n\\t\\t}\\n\\t\\t.genLabel {\\n\\t\\t\\tfont-size: 0.8em;\\n\\t\\t}\\n\\t}\\n\\n\\t@media (max-width: 520px) {\\n\\t\\t.label {\\n\\t\\t\\tfont-size: 0.7em;\\n\\t\\t\\tpadding: 2px 4px;\\n\\t\\t}\\n\\t\\t.genLabel {\\n\\t\\t\\tfont-size: 0.7em;\\n\\t\\t\\tpadding: 2px 4px;\\n\\t\\t}\\n\\t}\\n\\n\\t@media (max-width: 510px) {\\n\\t\\t#podium {\\n\\t\\t\\twidth: 400px;\\n\\t\\t\\theight: 333px;\\n\\t\\t}\\n\\t}\\n\\n\\t@media (max-width: 425px) {\\n\\t\\t.label {\\n\\t\\t\\tfont-size: 0.6em;\\n\\t\\t}\\n\\t\\t.genLabel {\\n\\t\\t\\tfont-size: 0.6em;\\n\\t\\t}\\n\\t}\\n\\n\\t@media (max-width: 410px) {\\n\\t\\t#podium {\\n\\t\\t\\twidth: 300px;\\n\\t\\t\\theight: 250px;\\n\\t\\t}\\n\\n\\t\\t.firstLabel {\\n\\t\\t\\tbottom: 53%;\\n\\t\\t}\\n\\n\\t\\t.secondLabel {\\n\\t\\t\\tbottom: 31%;\\n\\t\\t}\\n\\n\\t\\t.thirdLabel {\\n\\t\\t\\tbottom: 27%;\\n\\t\\t}\\n\\t}\\n\\n\\t@media (max-width: 329px) {\\n\\t\\t.label {\\n\\t\\t\\tfont-size: 0.5em;\\n\\t\\t}\\n\\t\\t.genLabel {\\n\\t\\t\\tfont-size: 0.5em;\\n\\t\\t}\\n\\t}\\n</style>\\n\\n<div class=\\"awards\\">\\n\\t<h3>{year} Awards</h3>\\n\\n\\t<img src=\\"./banner.png\\" class=\\"banner\\" alt=\\"The Champion\'s Cup\\" />\\n\\n\\t<div id=\\"podium\\">\\n\\t\\t<img src=\\"./podium.png\\" class=\\"podiumImage\\" alt=\\"podium\\" />\\n\\n\\t\\t<!-- champs -->\\n\\t\\t<img src=\\"{champion.avatar}\\" class=\\"first champ clickable\\" on:click={() => gotoManager(champion.rosterID)} alt=\\"champion\\" />\\n\\t\\t<img src=\\"./laurel.png\\" class=\\"laurel\\" alt=\\"laurel\\" />\\n\\t\\t<span class=\\"label firstLabel clickable\\" on:click={() => gotoManager(champion.rosterID)}>{@html getNames(champion.name, champion.rosterID)}</span>\\n\\n\\t\\t<img src=\\"{second.avatar}\\" class=\\"second champ clickable\\" on:click={() => gotoManager(second.rosterID)} alt=\\"2nd\\" />\\n\\t\\t<span class=\\"label secondLabel clickable\\" on:click={() => gotoManager(second.rosterID)}>{@html getNames(second.name, second.rosterID)}</span>\\n\\n\\t\\t<img src=\\"{third.avatar}\\" class=\\"third champ clickable\\" on:click={() => gotoManager(third.rosterID)} alt=\\"3rd\\" />\\n\\t\\t<span class=\\"label thirdLabel clickable\\" on:click={() => gotoManager(third.rosterID)}>{@html getNames(third.name, third.rosterID)}</span>\\n\\t</div>\\n\\t<div class=\\"divisions\\">\\n\\t\\t{#each divisions as division}\\n\\t\\t\\t{#if division.manager}\\n\\t\\t\\t\\t<div class=\\"division\\">\\n\\t\\t\\t\\t\\t{#if division.name}\\n\\t\\t\\t\\t\\t\\t<h6>{division.name} Division</h6>\\n\\t\\t\\t\\t\\t{:else}\\n\\t\\t\\t\\t\\t\\t<h6>Regular Season Champion</h6>\\n\\t\\t\\t\\t\\t{/if}\\n\\t\\t\\t\\t\\t<div class=\\"leaderBlock\\">\\n\\t\\t\\t\\t\\t\\t<img src=\\"{division.manager.avatar}\\" class=\\"divisionLeader clickable\\" on:click={() => gotoManager(division.manager.rosterID)} alt=\\"{division.name} champion\\" />\\n\\t\\t\\t\\t\\t\\t<img src=\\"./medal.png\\" class=\\"medal\\" alt=\\"champion\\" />\\n\\t\\t\\t\\t\\t</div>\\n\\t\\t\\t\\t\\t<span class=\\"genLabel clickable\\" on:click={() => gotoManager(division.manager.rosterID)}>{@html getNames(division.manager.name, division.manager.rosterID)}</span>\\n\\t\\t\\t\\t</div>\\n\\t\\t\\t{/if}\\n\\t\\t{/each}\\n\\t</div>\\n\\n\\t\\t<!-- Toilet Bowl -->\\n\\t{#if toilet}\\n\\t\\t<div class=\\"toiletParent\\">\\n\\t\\t\\t\\n\\t\\t\\t<img src=\\"./toilet-banner.png\\" class=\\"toilet-banner\\" alt=\\"The Toilet Bowl\\" />\\n\\n\\t\\t\\t<div class=\\"toiletBowl\\">\\n\\t\\t\\t\\t<img src=\\"{toilet.avatar}\\" class=\\"toiletWinner clickable\\" on:click={() => gotoManager(toilet.rosterID)} alt=\\"toilet bowl winner\\" />\\n\\t\\t\\t\\t<img src=\\"./toilet-bowl-2.png\\" class=\\"toilet\\" alt=\\"toilet bowl\\" />\\n\\t\\t\\t</div>\\n\\t\\t\\t<span class=\\"genLabel clickable\\" on:click={() => gotoManager(toilet.rosterID)}>{@html getNames(toilet.name, toilet.rosterID)}</span>\\n\\t\\t</div>\\n\\t{/if}\\n</div>"],"names":[],"mappings":"AAeC,cAAE,CAAC,AACF,KAAK,CAAE,IAAI,MAAM,CAAC,AACnB,CAAC,AAED,EAAE,cAAC,CAAC,AACH,MAAM,CAAE,KAAK,CAAC,CAAC,CAAC,KAAK,AACtB,CAAC,AAED,OAAO,cAAC,CAAC,AACR,OAAO,CAAE,KAAK,CACd,QAAQ,CAAE,QAAQ,CAClB,KAAK,CAAE,IAAI,CACX,OAAO,CAAE,CAAC,AACX,CAAC,AAED,OAAO,cAAC,CAAC,AACR,KAAK,CAAE,KAAK,CACZ,MAAM,CAAE,KAAK,CACb,QAAQ,CAAE,QAAQ,CAClB,MAAM,CAAE,IAAI,CAAC,IAAI,CAAC,IAAI,AACvB,CAAC,AAED,YAAY,cAAC,CAAC,AACb,QAAQ,CAAE,QAAQ,CAClB,MAAM,CAAE,CAAC,CACT,IAAI,CAAE,CAAC,CACP,KAAK,CAAE,IAAI,CACX,MAAM,CAAE,IAAI,CACZ,OAAO,CAAE,CAAC,AACX,CAAC,AAED,MAAM,cAAC,CAAC,AACP,QAAQ,CAAE,QAAQ,CAClB,KAAK,CAAE,GAAG,CACV,MAAM,CAAE,IAAI,CACZ,SAAS,CAAE,UAAU,IAAI,CAAC,CAAC,IAAI,CAAC,CAChC,aAAa,CAAE,IAAI,CACnB,MAAM,CAAE,GAAG,CAAC,KAAK,CAAC,IAAI,KAAK,CAAC,CAC5B,gBAAgB,CAAE,IAAI,KAAK,CAAC,AAC7B,CAAC,AAED,OAAO,cAAC,CAAC,AACR,QAAQ,CAAE,QAAQ,CAClB,KAAK,CAAE,GAAG,CACV,MAAM,CAAE,IAAI,CACZ,SAAS,CAAE,UAAU,IAAI,CAAC,CAAC,IAAI,CAAC,CAChC,MAAM,CAAE,KAAK,CACb,IAAI,CAAE,GAAG,CACT,cAAc,CAAE,IAAI,AACrB,CAAC,AAED,MAAM,cAAC,CAAC,AACP,MAAM,CAAE,GAAG,CACX,IAAI,CAAE,GAAG,AACV,CAAC,AAED,OAAO,cAAC,CAAC,AACR,MAAM,CAAE,GAAG,CACX,IAAI,CAAE,GAAG,AACV,CAAC,AAED,MAAM,cAAC,CAAC,AACP,MAAM,CAAE,GAAG,CACX,IAAI,CAAE,GAAG,AACV,CAAC,AAED,EAAE,cAAC,CAAC,AACH,UAAU,CAAE,MAAM,AACnB,CAAC,AAED,YAAY,cAAC,CAAC,AACb,QAAQ,CAAE,QAAQ,CAClB,KAAK,CAAE,IAAI,CACX,MAAM,CAAE,KAAK,CACb,MAAM,CAAE,IAAI,CAAC,IAAI,AAClB,CAAC,AAED,UAAU,cAAC,CAAC,AACX,OAAO,CAAE,IAAI,CACb,eAAe,CAAE,YAAY,AAC9B,CAAC,AAED,eAAe,cAAC,CAAC,AAChB,QAAQ,CAAE,QAAQ,CAClB,KAAK,CAAE,IAAI,CACX,MAAM,CAAE,IAAI,CACZ,SAAS,CAAE,UAAU,IAAI,CAAC,CAAC,EAAE,CAAC,CAC9B,GAAG,CAAE,CAAC,CACN,IAAI,CAAE,GAAG,CACT,aAAa,CAAE,IAAI,CACnB,MAAM,CAAE,GAAG,CAAC,KAAK,CAAC,IAAI,KAAK,CAAC,CAC5B,OAAO,CAAE,CAAC,AACX,CAAC,AAED,MAAM,cAAC,CAAC,AACP,QAAQ,CAAE,QAAQ,CAClB,KAAK,CAAE,IAAI,CACX,MAAM,CAAE,IAAI,CACZ,SAAS,CAAE,UAAU,IAAI,CAAC,CAAC,EAAE,CAAC,CAC9B,MAAM,CAAE,CAAC,CACT,IAAI,CAAE,GAAG,CACT,OAAO,CAAE,CAAC,AACX,CAAC,AAED,WAAW,cAAC,CAAC,AACZ,QAAQ,CAAE,QAAQ,CAClB,KAAK,CAAE,KAAK,CACZ,MAAM,CAAE,KAAK,CACb,MAAM,CAAE,IAAI,CAAC,IAAI,AAClB,CAAC,AAED,aAAa,cAAC,CAAC,AACd,QAAQ,CAAE,QAAQ,CAClB,KAAK,CAAE,IAAI,CACX,MAAM,CAAE,IAAI,CACZ,SAAS,CAAE,UAAU,IAAI,CAAC,CAAC,EAAE,CAAC,CAC9B,GAAG,CAAE,IAAI,CACT,IAAI,CAAE,GAAG,CACT,aAAa,CAAE,IAAI,CACnB,MAAM,CAAE,GAAG,CAAC,KAAK,CAAC,IAAI,KAAK,CAAC,CAC5B,OAAO,CAAE,CAAC,AACX,CAAC,AAED,OAAO,cAAC,CAAC,AACR,QAAQ,CAAE,QAAQ,CAClB,KAAK,CAAE,IAAI,CACX,MAAM,CAAE,IAAI,CACZ,SAAS,CAAE,UAAU,IAAI,CAAC,CAAC,EAAE,CAAC,CAC9B,MAAM,CAAE,CAAC,CACT,IAAI,CAAE,GAAG,AACV,CAAC,AAED,MAAM,cAAC,CAAC,AACP,WAAW,CAAE,MAAM,CACnB,WAAW,CAAE,KAAK,CAClB,UAAU,CAAE,MAAM,CAClB,UAAU,CAAE,IAAI,CAChB,OAAO,CAAE,IAAI,CACb,cAAc,CAAE,MAAM,CACtB,eAAe,CAAE,MAAM,CACvB,QAAQ,CAAE,QAAQ,CAClB,SAAS,CAAE,UAAU,IAAI,CAAC,CAAC,IAAI,CAAC,CAChC,OAAO,CAAE,GAAG,CAAC,IAAI,CACjB,gBAAgB,CAAE,IAAI,KAAK,CAAC,CAC5B,MAAM,CAAE,GAAG,CAAC,KAAK,CAAC,IAAI,KAAK,CAAC,CACtB,UAAU,CAAE,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI,CAAC,IAAI,cAAc,CAAC,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI,cAAc,CAAC,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI,gBAAgB,CAAC,AACnI,CAAC,AAED,WAAW,cAAC,CAAC,AACZ,MAAM,CAAE,GAAG,CACX,IAAI,CAAE,GAAG,AACV,CAAC,AAED,YAAY,cAAC,CAAC,AACb,MAAM,CAAE,GAAG,CACX,IAAI,CAAE,GAAG,AACV,CAAC,AAED,WAAW,cAAC,CAAC,AACZ,MAAM,CAAE,GAAG,CACX,IAAI,CAAE,GAAG,AACV,CAAC,AAED,SAAS,cAAC,CAAC,AACV,WAAW,CAAE,MAAM,CACnB,WAAW,CAAE,KAAK,CAClB,UAAU,CAAE,IAAI,CAChB,OAAO,CAAE,WAAW,CACpB,cAAc,CAAE,MAAM,CACtB,eAAe,CAAE,MAAM,CACvB,UAAU,CAAE,MAAM,CAClB,MAAM,CAAE,IAAI,CAAC,IAAI,CAAC,IAAI,CACtB,OAAO,CAAE,GAAG,CAAC,IAAI,CACjB,gBAAgB,CAAE,IAAI,KAAK,CAAC,CAC5B,MAAM,CAAE,GAAG,CAAC,KAAK,CAAC,IAAI,KAAK,CAAC,CAC5B,UAAU,CAAE,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI,CAAC,IAAI,cAAc,CAAC,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI,cAAc,CAAC,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI,gBAAgB,CAAC,AAC7H,CAAC,AAED,SAAS,cAAC,CAAC,AACV,UAAU,CAAE,MAAM,AACnB,CAAC,AAED,aAAa,cAAC,CAAC,AACd,KAAK,CAAE,IAAI,CACX,UAAU,CAAE,MAAM,CAClB,OAAO,CAAE,IAAI,CAAC,CAAC,CAAC,IAAI,CACpB,UAAU,CAAE,IAAI,CAChB,UAAU,CAAE,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,AAC7C,CAAC,AAED,OAAO,cAAC,CAAC,AACR,OAAO,CAAE,KAAK,CACd,KAAK,CAAE,GAAG,CACV,SAAS,CAAE,KAAK,CAChB,MAAM,CAAE,IAAI,CAAC,IAAI,CAAC,CAAC,AACpB,CAAC,AAED,cAAc,cAAC,CAAC,AACf,OAAO,CAAE,KAAK,CACd,KAAK,CAAE,GAAG,CACV,SAAS,CAAE,KAAK,CAChB,MAAM,CAAE,IAAI,CAAC,IAAI,CAAC,CAAC,AACpB,CAAC,AAED,UAAU,cAAC,CAAC,AACX,MAAM,CAAE,OAAO,AAChB,CAAC,AAEO,SAAS,AAAE,CAAC,AACnB,SAAS,CAAE,MAAM,CACjB,KAAK,CAAE,IAAI,KAAK,CAAC,CACjB,UAAU,CAAE,MAAM,AACnB,CAAC,AAED,MAAM,AAAC,YAAY,KAAK,CAAC,AAAC,CAAC,AAC1B,MAAM,cAAC,CAAC,AACP,OAAO,CAAE,GAAG,CAAC,GAAG,AACjB,CAAC,AACD,SAAS,cAAC,CAAC,AACV,OAAO,CAAE,GAAG,CAAC,GAAG,AACjB,CAAC,AACF,CAAC,AAED,MAAM,AAAC,YAAY,KAAK,CAAC,AAAC,CAAC,AAC1B,MAAM,cAAC,CAAC,AACP,SAAS,CAAE,KAAK,AACjB,CAAC,AACD,SAAS,cAAC,CAAC,AACV,SAAS,CAAE,KAAK,AACjB,CAAC,AACF,CAAC,AAED,MAAM,AAAC,YAAY,KAAK,CAAC,AAAC,CAAC,AAC1B,OAAO,cAAC,CAAC,AACR,KAAK,CAAE,KAAK,CACZ,MAAM,CAAE,KAAK,CACb,QAAQ,CAAE,QAAQ,CAClB,MAAM,CAAE,IAAI,CAAC,IAAI,CAAC,IAAI,AACvB,CAAC,AAED,WAAW,cAAC,CAAC,AACZ,MAAM,CAAE,GAAG,AACZ,CAAC,AAED,YAAY,cAAC,CAAC,AACb,MAAM,CAAE,GAAG,AACZ,CAAC,AAED,WAAW,cAAC,CAAC,AACZ,MAAM,CAAE,GAAG,AACZ,CAAC,AACF,CAAC,AAED,MAAM,AAAC,YAAY,KAAK,CAAC,AAAC,CAAC,AAC1B,MAAM,cAAC,CAAC,AACP,SAAS,CAAE,KAAK,AACjB,CAAC,AACD,SAAS,cAAC,CAAC,AACV,SAAS,CAAE,KAAK,AACjB,CAAC,AACF,CAAC,AAED,MAAM,AAAC,YAAY,KAAK,CAAC,AAAC,CAAC,AAC1B,MAAM,cAAC,CAAC,AACP,SAAS,CAAE,KAAK,CAChB,OAAO,CAAE,GAAG,CAAC,GAAG,AACjB,CAAC,AACD,SAAS,cAAC,CAAC,AACV,SAAS,CAAE,KAAK,CAChB,OAAO,CAAE,GAAG,CAAC,GAAG,AACjB,CAAC,AACF,CAAC,AAED,MAAM,AAAC,YAAY,KAAK,CAAC,AAAC,CAAC,AAC1B,OAAO,cAAC,CAAC,AACR,KAAK,CAAE,KAAK,CACZ,MAAM,CAAE,KAAK,AACd,CAAC,AACF,CAAC,AAED,MAAM,AAAC,YAAY,KAAK,CAAC,AAAC,CAAC,AAC1B,MAAM,cAAC,CAAC,AACP,SAAS,CAAE,KAAK,AACjB,CAAC,AACD,SAAS,cAAC,CAAC,AACV,SAAS,CAAE,KAAK,AACjB,CAAC,AACF,CAAC,AAED,MAAM,AAAC,YAAY,KAAK,CAAC,AAAC,CAAC,AAC1B,OAAO,cAAC,CAAC,AACR,KAAK,CAAE,KAAK,CACZ,MAAM,CAAE,KAAK,AACd,CAAC,AAED,WAAW,cAAC,CAAC,AACZ,MAAM,CAAE,GAAG,AACZ,CAAC,AAED,YAAY,cAAC,CAAC,AACb,MAAM,CAAE,GAAG,AACZ,CAAC,AAED,WAAW,cAAC,CAAC,AACZ,MAAM,CAAE,GAAG,AACZ,CAAC,AACF,CAAC,AAED,MAAM,AAAC,YAAY,KAAK,CAAC,AAAC,CAAC,AAC1B,MAAM,cAAC,CAAC,AACP,SAAS,CAAE,KAAK,AACjB,CAAC,AACD,SAAS,cAAC,CAAC,AACV,SAAS,CAAE,KAAK,AACjB,CAAC,AACF,CAAC"}'
};
var Awards = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let { podium, currentManagers } = $$props;
  const { year, champion, second, third, divisions, toilet } = podium;
  const getNames = (name, rosterID) => {
    if (cleanName(name) != cleanName(currentManagers[rosterID].name)) {
      return `${name}<div class="curOwner">(${currentManagers[rosterID].name})</div>`;
    }
    return name;
  };
  if ($$props.podium === void 0 && $$bindings.podium && podium !== void 0)
    $$bindings.podium(podium);
  if ($$props.currentManagers === void 0 && $$bindings.currentManagers && currentManagers !== void 0)
    $$bindings.currentManagers(currentManagers);
  $$result.css.add(css$A);
  return `<div class="${"awards svelte-zcagvz"}"><h3 class="${"svelte-zcagvz"}">${escape(year)} Awards</h3>

	<img src="${"./banner.png"}" class="${"banner svelte-zcagvz"}" alt="${"The Champion's Cup"}">

	<div id="${"podium"}" class="${"svelte-zcagvz"}"><img src="${"./podium.png"}" class="${"podiumImage svelte-zcagvz"}" alt="${"podium"}">

		
		<img${add_attribute("src", champion.avatar, 0)} class="${"first champ clickable svelte-zcagvz"}" alt="${"champion"}">
		<img src="${"./laurel.png"}" class="${"laurel svelte-zcagvz"}" alt="${"laurel"}">
		<span class="${"label firstLabel clickable svelte-zcagvz"}"><!-- HTML_TAG_START -->${getNames(champion.name, champion.rosterID)}<!-- HTML_TAG_END --></span>

		<img${add_attribute("src", second.avatar, 0)} class="${"second champ clickable svelte-zcagvz"}" alt="${"2nd"}">
		<span class="${"label secondLabel clickable svelte-zcagvz"}"><!-- HTML_TAG_START -->${getNames(second.name, second.rosterID)}<!-- HTML_TAG_END --></span>

		<img${add_attribute("src", third.avatar, 0)} class="${"third champ clickable svelte-zcagvz"}" alt="${"3rd"}">
		<span class="${"label thirdLabel clickable svelte-zcagvz"}"><!-- HTML_TAG_START -->${getNames(third.name, third.rosterID)}<!-- HTML_TAG_END --></span></div>
	<div class="${"divisions svelte-zcagvz"}">${each(divisions, (division) => `${division.manager ? `<div class="${"division svelte-zcagvz"}">${division.name ? `<h6 class="${"svelte-zcagvz"}">${escape(division.name)} Division</h6>` : `<h6 class="${"svelte-zcagvz"}">Regular Season Champion</h6>`}
					<div class="${"leaderBlock svelte-zcagvz"}"><img${add_attribute("src", division.manager.avatar, 0)} class="${"divisionLeader clickable svelte-zcagvz"}" alt="${escape(division.name) + " champion"}">
						<img src="${"./medal.png"}" class="${"medal svelte-zcagvz"}" alt="${"champion"}"></div>
					<span class="${"genLabel clickable svelte-zcagvz"}"><!-- HTML_TAG_START -->${getNames(division.manager.name, division.manager.rosterID)}<!-- HTML_TAG_END --></span>
				</div>` : ``}`)}</div>

		
	${toilet ? `<div class="${"toiletParent svelte-zcagvz"}"><img src="${"./toilet-banner.png"}" class="${"toilet-banner svelte-zcagvz"}" alt="${"The Toilet Bowl"}">

			<div class="${"toiletBowl svelte-zcagvz"}"><img${add_attribute("src", toilet.avatar, 0)} class="${"toiletWinner clickable svelte-zcagvz"}" alt="${"toilet bowl winner"}">
				<img src="${"./toilet-bowl-2.png"}" class="${"toilet svelte-zcagvz"}" alt="${"toilet bowl"}"></div>
			<span class="${"genLabel clickable svelte-zcagvz"}"><!-- HTML_TAG_START -->${getNames(toilet.name, toilet.rosterID)}<!-- HTML_TAG_END --></span></div>` : ``}</div>`;
});
var { Object: Object_1$1 } = globals;
var Button_1 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let actionProp;
  let defaultProp;
  let secondaryProp;
  let $$restProps = compute_rest_props($$props, [
    "use",
    "class",
    "style",
    "ripple",
    "color",
    "variant",
    "touch",
    "href",
    "action",
    "default",
    "secondary",
    "component",
    "getElement"
  ]);
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { use = [] } = $$props;
  let { class: className = "" } = $$props;
  let { style = "" } = $$props;
  let { ripple = true } = $$props;
  let { color = "primary" } = $$props;
  let { variant = "text" } = $$props;
  let { touch = false } = $$props;
  let { href = null } = $$props;
  let { action = "close" } = $$props;
  let { default: defaultAction = false } = $$props;
  let { secondary = false } = $$props;
  let element;
  let internalClasses = {};
  let internalStyles = {};
  let context = getContext("SMUI:button:context");
  let { component = href == null ? Button : A } = $$props;
  setContext("SMUI:label:context", "button");
  setContext("SMUI:icon:context", "button");
  function addClass(className2) {
    if (!internalClasses[className2]) {
      internalClasses[className2] = true;
    }
  }
  function removeClass(className2) {
    if (!(className2 in internalClasses) || internalClasses[className2]) {
      internalClasses[className2] = false;
    }
  }
  function addStyle(name, value) {
    if (internalStyles[name] != value) {
      if (value === "" || value == null) {
        delete internalStyles[name];
        internalStyles = internalStyles;
      } else {
        internalStyles[name] = value;
      }
    }
  }
  function getElement() {
    return element.getElement();
  }
  if ($$props.use === void 0 && $$bindings.use && use !== void 0)
    $$bindings.use(use);
  if ($$props.class === void 0 && $$bindings.class && className !== void 0)
    $$bindings.class(className);
  if ($$props.style === void 0 && $$bindings.style && style !== void 0)
    $$bindings.style(style);
  if ($$props.ripple === void 0 && $$bindings.ripple && ripple !== void 0)
    $$bindings.ripple(ripple);
  if ($$props.color === void 0 && $$bindings.color && color !== void 0)
    $$bindings.color(color);
  if ($$props.variant === void 0 && $$bindings.variant && variant !== void 0)
    $$bindings.variant(variant);
  if ($$props.touch === void 0 && $$bindings.touch && touch !== void 0)
    $$bindings.touch(touch);
  if ($$props.href === void 0 && $$bindings.href && href !== void 0)
    $$bindings.href(href);
  if ($$props.action === void 0 && $$bindings.action && action !== void 0)
    $$bindings.action(action);
  if ($$props.default === void 0 && $$bindings.default && defaultAction !== void 0)
    $$bindings.default(defaultAction);
  if ($$props.secondary === void 0 && $$bindings.secondary && secondary !== void 0)
    $$bindings.secondary(secondary);
  if ($$props.component === void 0 && $$bindings.component && component !== void 0)
    $$bindings.component(component);
  if ($$props.getElement === void 0 && $$bindings.getElement && getElement !== void 0)
    $$bindings.getElement(getElement);
  let $$settled;
  let $$rendered;
  do {
    $$settled = true;
    actionProp = context === "dialog:action" && action != null ? { "data-mdc-dialog-action": action } : { action: $$props.action };
    defaultProp = context === "dialog:action" && defaultAction ? { "data-mdc-dialog-button-default": "" } : { default: $$props.default };
    secondaryProp = context === "banner" ? {} : { secondary: $$props.secondary };
    $$rendered = `${validate_component(component || missing_component, "svelte:component").$$render($$result, Object_1$1.assign({
      use: [
        [
          Ripple,
          {
            ripple,
            unbounded: false,
            color,
            disabled: !!$$restProps.disabled,
            addClass,
            removeClass,
            addStyle
          }
        ],
        forwardEvents,
        ...use
      ]
    }, {
      class: classMap({
        [className]: true,
        "mdc-button": true,
        "mdc-button--raised": variant === "raised",
        "mdc-button--unelevated": variant === "unelevated",
        "mdc-button--outlined": variant === "outlined",
        "smui-button--color-secondary": color === "secondary",
        "mdc-button--touch": touch,
        "mdc-card__action": context === "card:action",
        "mdc-card__action--button": context === "card:action",
        "mdc-dialog__button": context === "dialog:action",
        "mdc-top-app-bar__navigation-icon": context === "top-app-bar:navigation",
        "mdc-top-app-bar__action-item": context === "top-app-bar:action",
        "mdc-snackbar__action": context === "snackbar:actions",
        "mdc-banner__secondary-action": context === "banner" && secondary,
        "mdc-banner__primary-action": context === "banner" && !secondary,
        "mdc-tooltip__action": context === "tooltip:rich-actions",
        ...internalClasses
      })
    }, {
      style: Object.entries(internalStyles).map(([name, value]) => `${name}: ${value};`).concat([style]).join(" ")
    }, actionProp, defaultProp, secondaryProp, { href }, $$restProps, { this: element }), {
      this: ($$value) => {
        element = $$value;
        $$settled = false;
      }
    }, {
      default: () => `<div class="${"mdc-button__ripple"}"></div>
  ${slots.default ? slots.default({}) : ``}${touch ? `<div class="${"mdc-button__touch"}"></div>` : ``}`
    })}`;
  } while (!$$settled);
  return $$rendered;
});
var Group = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let $$restProps = compute_rest_props($$props, ["use", "class", "variant", "getElement"]);
  forwardEventsBuilder(get_current_component());
  let { use = [] } = $$props;
  let { class: className = "" } = $$props;
  let { variant = "text" } = $$props;
  let element;
  function getElement() {
    return element;
  }
  if ($$props.use === void 0 && $$bindings.use && use !== void 0)
    $$bindings.use(use);
  if ($$props.class === void 0 && $$bindings.class && className !== void 0)
    $$bindings.class(className);
  if ($$props.variant === void 0 && $$bindings.variant && variant !== void 0)
    $$bindings.variant(variant);
  if ($$props.getElement === void 0 && $$bindings.getElement && getElement !== void 0)
    $$bindings.getElement(getElement);
  return `<div${spread([
    {
      class: escape_attribute_value(classMap({
        [className]: true,
        "smui-button__group": true,
        "smui-button__group--raised": variant === "raised"
      }))
    },
    escape_object($$restProps)
  ])}${add_attribute("this", element, 0)}>${slots.default ? slots.default({}) : ``}
</div>`;
});
var DataTable = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let $$restProps = compute_rest_props($$props, [
    "use",
    "class",
    "stickyHeader",
    "sortable",
    "sort",
    "sortDirection",
    "sortAscendingAriaLabel",
    "sortDescendingAriaLabel",
    "container$use",
    "container$class",
    "table$use",
    "table$class",
    "layout",
    "getElement"
  ]);
  let $$slots = compute_slots(slots);
  let $progressClosed, $$unsubscribe_progressClosed;
  let $sortDirectionStore, $$unsubscribe_sortDirectionStore;
  let $sortStore, $$unsubscribe_sortStore;
  forwardEventsBuilder(get_current_component());
  let { use = [] } = $$props;
  let { class: className = "" } = $$props;
  let { stickyHeader = false } = $$props;
  let { sortable = false } = $$props;
  let { sort = null } = $$props;
  let { sortDirection = "ascending" } = $$props;
  let { sortAscendingAriaLabel = "sorted, ascending" } = $$props;
  let { sortDescendingAriaLabel = "sorted, descending" } = $$props;
  let { container$use = [] } = $$props;
  let { container$class = "" } = $$props;
  let { table$use = [] } = $$props;
  let { table$class = "" } = $$props;
  let element;
  let instance;
  let container;
  let internalClasses = {};
  let progressIndicatorStyles = {};
  let addLayoutListener = getContext("SMUI:addLayoutListener");
  let removeLayoutListener;
  let progressClosed = writable(false);
  $$unsubscribe_progressClosed = subscribe(progressClosed, (value) => $progressClosed = value);
  let sortStore = writable(sort);
  $$unsubscribe_sortStore = subscribe(sortStore, (value) => $sortStore = value);
  let sortDirectionStore = writable(sortDirection);
  $$unsubscribe_sortDirectionStore = subscribe(sortDirectionStore, (value) => $sortDirectionStore = value);
  setContext("SMUI:checkbox:context", "data-table");
  setContext("SMUI:linear-progress:context", "data-table");
  setContext("SMUI:linear-progress:closed", progressClosed);
  setContext("SMUI:data-table:sortable", sortable);
  setContext("SMUI:data-table:sort", sortStore);
  setContext("SMUI:data-table:sortDirection", sortDirectionStore);
  setContext("SMUI:data-table:sortAscendingAriaLabel", sortAscendingAriaLabel);
  setContext("SMUI:data-table:sortDescendingAriaLabel", sortDescendingAriaLabel);
  if (addLayoutListener) {
    removeLayoutListener = addLayoutListener(layout);
  }
  let previousProgressClosed = null;
  onDestroy(() => {
    if (removeLayoutListener) {
      removeLayoutListener();
    }
  });
  function layout() {
    return instance.layout();
  }
  function getElement() {
    return element;
  }
  if ($$props.use === void 0 && $$bindings.use && use !== void 0)
    $$bindings.use(use);
  if ($$props.class === void 0 && $$bindings.class && className !== void 0)
    $$bindings.class(className);
  if ($$props.stickyHeader === void 0 && $$bindings.stickyHeader && stickyHeader !== void 0)
    $$bindings.stickyHeader(stickyHeader);
  if ($$props.sortable === void 0 && $$bindings.sortable && sortable !== void 0)
    $$bindings.sortable(sortable);
  if ($$props.sort === void 0 && $$bindings.sort && sort !== void 0)
    $$bindings.sort(sort);
  if ($$props.sortDirection === void 0 && $$bindings.sortDirection && sortDirection !== void 0)
    $$bindings.sortDirection(sortDirection);
  if ($$props.sortAscendingAriaLabel === void 0 && $$bindings.sortAscendingAriaLabel && sortAscendingAriaLabel !== void 0)
    $$bindings.sortAscendingAriaLabel(sortAscendingAriaLabel);
  if ($$props.sortDescendingAriaLabel === void 0 && $$bindings.sortDescendingAriaLabel && sortDescendingAriaLabel !== void 0)
    $$bindings.sortDescendingAriaLabel(sortDescendingAriaLabel);
  if ($$props.container$use === void 0 && $$bindings.container$use && container$use !== void 0)
    $$bindings.container$use(container$use);
  if ($$props.container$class === void 0 && $$bindings.container$class && container$class !== void 0)
    $$bindings.container$class(container$class);
  if ($$props.table$use === void 0 && $$bindings.table$use && table$use !== void 0)
    $$bindings.table$use(table$use);
  if ($$props.table$class === void 0 && $$bindings.table$class && table$class !== void 0)
    $$bindings.table$class(table$class);
  if ($$props.layout === void 0 && $$bindings.layout && layout !== void 0)
    $$bindings.layout(layout);
  if ($$props.getElement === void 0 && $$bindings.getElement && getElement !== void 0)
    $$bindings.getElement(getElement);
  set_store_value(sortStore, $sortStore = sort, $sortStore);
  set_store_value(sortDirectionStore, $sortDirectionStore = sortDirection, $sortDirectionStore);
  {
    if ($$slots.progress && instance && previousProgressClosed !== $progressClosed) {
      previousProgressClosed = $progressClosed;
      if ($progressClosed) {
        instance.hideProgress();
      } else {
        instance.showProgress();
      }
    }
  }
  $$unsubscribe_progressClosed();
  $$unsubscribe_sortDirectionStore();
  $$unsubscribe_sortStore();
  return `<div${spread([
    {
      class: escape_attribute_value(classMap({
        [className]: true,
        "mdc-data-table": true,
        "mdc-data-table--sticky-header": stickyHeader,
        ...internalClasses
      }))
    },
    escape_object(exclude($$restProps, ["container$", "table$"]))
  ])}${add_attribute("this", element, 0)}><div${spread([
    {
      class: escape_attribute_value(classMap({
        [container$class]: true,
        "mdc-data-table__table-container": true
      }))
    },
    escape_object(prefixFilter($$restProps, "container$"))
  ])}${add_attribute("this", container, 0)}><table${spread([
    {
      class: escape_attribute_value(classMap({
        [table$class]: true,
        "mdc-data-table__table": true
      }))
    },
    escape_object(prefixFilter($$restProps, "table$"))
  ])}>${slots.default ? slots.default({}) : ``}</table></div>

  ${$$slots.progress ? `<div class="${"mdc-data-table__progress-indicator"}"${add_attribute("style", Object.entries(progressIndicatorStyles).map(([name, value]) => `${name}: ${value};`).join(" "), 0)}><div class="${"mdc-data-table__scrim"}"></div>
      ${slots.progress ? slots.progress({}) : ``}</div>` : ``}

  ${slots.paginate ? slots.paginate({}) : ``}
</div>`;
});
var Head = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let $$restProps = compute_rest_props($$props, ["use", "getElement"]);
  forwardEventsBuilder(get_current_component());
  let { use = [] } = $$props;
  let element;
  setContext("SMUI:data-table:row:header", true);
  function getElement() {
    return element;
  }
  if ($$props.use === void 0 && $$bindings.use && use !== void 0)
    $$bindings.use(use);
  if ($$props.getElement === void 0 && $$bindings.getElement && getElement !== void 0)
    $$bindings.getElement(getElement);
  return `<thead${spread([escape_object($$restProps)])}${add_attribute("this", element, 0)}>${slots.default ? slots.default({}) : ``}</thead>`;
});
var Body2 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let $$restProps = compute_rest_props($$props, ["use", "class", "getElement"]);
  forwardEventsBuilder(get_current_component());
  let { use = [] } = $$props;
  let { class: className = "" } = $$props;
  let element;
  setContext("SMUI:data-table:row:header", false);
  function getElement() {
    return element;
  }
  if ($$props.use === void 0 && $$bindings.use && use !== void 0)
    $$bindings.use(use);
  if ($$props.class === void 0 && $$bindings.class && className !== void 0)
    $$bindings.class(className);
  if ($$props.getElement === void 0 && $$bindings.getElement && getElement !== void 0)
    $$bindings.getElement(getElement);
  return `<tbody${spread([
    {
      class: escape_attribute_value(classMap({
        [className]: true,
        "mdc-data-table__content": true
      }))
    },
    escape_object($$restProps)
  ])}${add_attribute("this", element, 0)}>${slots.default ? slots.default({}) : ``}</tbody>`;
});
var counter$1 = 0;
var Row = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let $$restProps = compute_rest_props($$props, ["use", "class", "rowId", "getElement"]);
  forwardEventsBuilder(get_current_component());
  let { use = [] } = $$props;
  let { class: className = "" } = $$props;
  let { rowId = "SMUI-data-table-row-" + counter$1++ } = $$props;
  let element;
  let checkbox;
  let internalClasses = {};
  let internalAttrs = {};
  let header = getContext("SMUI:data-table:row:header");
  function getElement() {
    return element;
  }
  if ($$props.use === void 0 && $$bindings.use && use !== void 0)
    $$bindings.use(use);
  if ($$props.class === void 0 && $$bindings.class && className !== void 0)
    $$bindings.class(className);
  if ($$props.rowId === void 0 && $$bindings.rowId && rowId !== void 0)
    $$bindings.rowId(rowId);
  if ($$props.getElement === void 0 && $$bindings.getElement && getElement !== void 0)
    $$bindings.getElement(getElement);
  return `<tr${spread([
    {
      class: escape_attribute_value(classMap({
        [className]: true,
        "mdc-data-table__header-row": header,
        "mdc-data-table__row": !header,
        "mdc-data-table__row--selected": !header && checkbox && checkbox.checked,
        ...internalClasses
      }))
    },
    {
      "aria-selected": escape_attribute_value(null)
    },
    escape_object(internalAttrs),
    escape_object($$restProps)
  ])}${add_attribute("this", element, 0)}>${slots.default ? slots.default({}) : ``}</tr>`;
});
var counter = 0;
var Cell = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let $$restProps = compute_rest_props($$props, ["use", "class", "numeric", "checkbox", "columnId", "sortable", "getElement"]);
  let $sort, $$unsubscribe_sort;
  let $sortDirection, $$unsubscribe_sortDirection;
  forwardEventsBuilder(get_current_component());
  let header = getContext("SMUI:data-table:row:header");
  let { use = [] } = $$props;
  let { class: className = "" } = $$props;
  let { numeric = false } = $$props;
  let { checkbox = false } = $$props;
  let { columnId = header ? "SMUI-data-table-column-" + counter++ : null } = $$props;
  let { sortable = getContext("SMUI:data-table:sortable") } = $$props;
  let element;
  let internalClasses = {};
  let internalAttrs = {};
  let sort = getContext("SMUI:data-table:sort");
  $$unsubscribe_sort = subscribe(sort, (value) => $sort = value);
  let sortDirection = getContext("SMUI:data-table:sortDirection");
  $$unsubscribe_sortDirection = subscribe(sortDirection, (value) => $sortDirection = value);
  let sortAscendingAriaLabel = getContext("SMUI:data-table:sortAscendingAriaLabel");
  let sortDescendingAriaLabel = getContext("SMUI:data-table:sortDescendingAriaLabel");
  if (sortable) {
    setContext("SMUI:label:context", "data-table:sortable-header-cell");
    setContext("SMUI:icon-button:context", "data-table:sortable-header-cell");
    setContext("SMUI:icon-button:aria-describedby", columnId + "-status-label");
  }
  function getElement() {
    return element;
  }
  if ($$props.use === void 0 && $$bindings.use && use !== void 0)
    $$bindings.use(use);
  if ($$props.class === void 0 && $$bindings.class && className !== void 0)
    $$bindings.class(className);
  if ($$props.numeric === void 0 && $$bindings.numeric && numeric !== void 0)
    $$bindings.numeric(numeric);
  if ($$props.checkbox === void 0 && $$bindings.checkbox && checkbox !== void 0)
    $$bindings.checkbox(checkbox);
  if ($$props.columnId === void 0 && $$bindings.columnId && columnId !== void 0)
    $$bindings.columnId(columnId);
  if ($$props.sortable === void 0 && $$bindings.sortable && sortable !== void 0)
    $$bindings.sortable(sortable);
  if ($$props.getElement === void 0 && $$bindings.getElement && getElement !== void 0)
    $$bindings.getElement(getElement);
  $$unsubscribe_sort();
  $$unsubscribe_sortDirection();
  return `${header ? `<th${spread([
    {
      class: escape_attribute_value(classMap({
        [className]: true,
        "mdc-data-table__header-cell": true,
        "mdc-data-table__header-cell--numeric": numeric,
        "mdc-data-table__header-cell--checkbox": checkbox,
        "mdc-data-table__header-cell--with-sort": sortable,
        "mdc-data-table__header-cell--sorted": sortable && $sort === columnId,
        ...internalClasses
      }))
    },
    { role: "columnheader" },
    { scope: "col" },
    {
      "data-column-id": escape_attribute_value(columnId)
    },
    {
      "aria-sort": escape_attribute_value(sortable ? $sort === columnId ? $sortDirection : "none" : null)
    },
    escape_object(internalAttrs),
    escape_object($$restProps)
  ])}${add_attribute("this", element, 0)}>${sortable ? `
      <div class="${"mdc-data-table__header-cell-wrapper"}">${slots.default ? slots.default({}) : ``}
        <div class="${"mdc-data-table__sort-status-label"}" aria-hidden="${"true"}" id="${escape(columnId) + "-status-label"}">${escape($sort === columnId ? $sortDirection === "ascending" ? sortAscendingAriaLabel : sortDescendingAriaLabel : "")}</div></div>
    ` : `${slots.default ? slots.default({}) : ``}`}</th>` : `<td${spread([
    {
      class: escape_attribute_value(classMap({
        [className]: true,
        "mdc-data-table__cell": true,
        "mdc-data-table__cell--numeric": numeric,
        "mdc-data-table__cell--checkbox": checkbox,
        ...internalClasses
      }))
    },
    escape_object(internalAttrs),
    escape_object($$restProps)
  ])}${add_attribute("this", element, 0)}>${slots.default ? slots.default({}) : ``}</td>`}`;
});
var css$z = {
  code: ".playerAvatar.svelte-17wj27k{vertical-align:middle;height:45px;width:45px;background-position:center;background-repeat:no-repeat;background-size:auto 45px}.pos.svelte-17wj27k{display:inline-flex;align-items:center;justify-content:center;border-radius:8px;width:46px;height:32px}.QB.svelte-17wj27k{background-color:var(--QB)}.WR.svelte-17wj27k{background-color:var(--WR)}.RB.svelte-17wj27k{background-color:var(--RB)}.TE.svelte-17wj27k{background-color:var(--TE)}.FLEX.svelte-17wj27k{background:linear-gradient(to right, var(--WR), var(--WR) 33.33%, var(--RB) 33.33%, var(--RB) 66.66%, var(--TE) 66.66%)}.WRRB.svelte-17wj27k{background:linear-gradient(to right, var(--WR), var(--WR) 50%, var(--RB) 50%)}.K.svelte-17wj27k{background-color:var(--K)}.S-FLEX.svelte-17wj27k{background:linear-gradient(to right, var(--WR), var(--WR) 25%, var(--RB) 25%, var(--RB) 50%, var(--TE) 50%, var(--TE) 75%, var(--QB));background-color:#8f66ff}.R-FLEX.svelte-17wj27k{background:linear-gradient(to right, var(--WR), var(--WR) 50%, var(--TE) 50%)}.DEF.svelte-17wj27k{background-color:var(--DEF)}.DL.svelte-17wj27k{background-color:var(--DL)}.LB.svelte-17wj27k{background-color:var(--LB)}.DB.svelte-17wj27k{background-color:var(--DB)}.IDP.svelte-17wj27k{background:linear-gradient(to right, var(--DL), var(--DL) 33.33%, var(--LB) 33.33%, var(--LB) 66.66%, var(--DB) 66.66%)}.BN.svelte-17wj27k{background-color:var(--BN)}.slot{width:22px !important;padding:1px 6px 1px 8px !important}.avatar{width:45px}.playerCell{height:45px !important;overflow-y:hidden !important}.teamCell{max-width:40px !important;padding:0 5px}.nameCell{padding:0 5px}span.nickname{color:#888;font-style:italic;font-size:0.8em}.injury{font-style:italic;font-weight:700;font-size:0.7em;margin-left:0.5em;vertical-align:super}.Q{color:#c09111}.OUT{color:#851313}.IR{color:#851313}.PUP{color:#851313}@media(max-width: 460px){.nameCell{font-size:0.9em}}",
  map: `{"version":3,"file":"RosterRow.svelte","sources":["RosterRow.svelte"],"sourcesContent":["<script>\\n\\timport { Row, Cell } from '@smui/data-table';\\n\\t\\n\\texport let player;\\n\\n\\tconst playerSLotClass = player.slot.replace('/', '').replace('SUPER_', 'S-').replace('REC_', 'R-');\\n\\tconst playerSlot = player.slot.replace('SUPER_', 'S ').replace('REC_', 'R ');\\n<\/script>\\n\\n<style>\\n\\t.playerAvatar {\\n\\t\\tvertical-align: middle;\\n\\t\\theight: 45px;\\n\\t\\twidth: 45px;\\n\\t\\tbackground-position: center;\\n\\t\\tbackground-repeat: no-repeat;\\n\\t\\tbackground-size: auto 45px;\\n\\t}\\n\\t.pos {\\n\\t\\tdisplay: inline-flex;\\n\\t\\talign-items: center;\\n\\t\\tjustify-content: center;\\n\\t\\tborder-radius: 8px;\\n\\t\\twidth: 46px;\\n\\t\\theight: 32px;\\n\\t}\\n\\n\\t.QB {\\n\\t\\tbackground-color: var(--QB);\\n\\t}\\n\\n\\t.WR {\\n\\t\\tbackground-color: var(--WR);\\n\\t}\\n\\n\\t.RB {\\n\\t\\tbackground-color: var(--RB);\\n\\t}\\n\\n\\t.TE {\\n\\t\\tbackground-color: var(--TE);\\n\\t}\\n\\n\\t.FLEX {\\n\\t\\tbackground: linear-gradient(to right, var(--WR), var(--WR) 33.33%, var(--RB) 33.33%, var(--RB) 66.66%, var(--TE) 66.66%);\\n\\t}\\n\\n\\t.WRRB {\\n\\t\\tbackground: linear-gradient(to right, var(--WR), var(--WR) 50%, var(--RB) 50%);\\n\\t}\\n\\n\\t.K {\\n\\t\\tbackground-color: var(--K);\\n\\t}\\n\\n\\t.S-FLEX {\\n\\t\\tbackground: linear-gradient(to right, var(--WR), var(--WR) 25%, var(--RB) 25%, var(--RB) 50%, var(--TE) 50%, var(--TE) 75%, var(--QB));\\n\\t\\tbackground-color: #8f66ff;\\n\\t}\\n\\n\\t.R-FLEX {\\n\\t\\tbackground: linear-gradient(to right, var(--WR), var(--WR) 50%, var(--TE) 50%);\\n\\t}\\n\\n\\t.DEF {\\n\\t\\tbackground-color: var(--DEF);\\n\\t}\\n\\n\\t.DL {\\n\\t\\tbackground-color: var(--DL);\\n\\t}\\n\\n\\t.LB {\\n\\t\\tbackground-color: var(--LB);\\n\\t}\\n\\n\\t.DB {\\n\\t\\tbackground-color: var(--DB);\\n\\t}\\n\\n\\t.IDP {\\n\\t\\tbackground: linear-gradient(to right, var(--DL), var(--DL) 33.33%, var(--LB) 33.33%, var(--LB) 66.66%, var(--DB) 66.66%);\\n\\t}\\n\\n\\t.BN {\\n\\t\\tbackground-color: var(--BN);\\n\\t}\\n\\n\\t:global(.slot) {\\n\\t\\twidth: 22px !important;\\n    \\tpadding: 1px 6px 1px 8px !important;\\n\\t}\\n\\t:global(.avatar) {\\n\\t\\twidth: 45px;\\n\\t}\\n\\t:global(.playerCell) {\\n\\t\\theight: 45px !important;\\n\\t\\toverflow-y: hidden !important;\\n\\t}\\n\\t:global(.teamCell) {\\n\\t\\tmax-width: 40px !important;\\n    \\tpadding: 0 5px;\\n\\t}\\n\\n\\t:global(.nameCell) {\\n    \\tpadding: 0 5px;\\n\\t}\\n\\n\\t:global(span.nickname) {\\n\\t\\tcolor: #888;\\n\\t\\tfont-style: italic;\\n\\t\\tfont-size: 0.8em;\\n\\t}\\n\\n\\t:global(.injury) {\\n\\t\\tfont-style: italic;\\n\\t\\tfont-weight: 700;\\n\\t\\tfont-size: 0.7em;\\n\\t\\tmargin-left: 0.5em;\\n\\t\\tvertical-align:super;\\n\\t}\\n\\n\\t:global(.Q) {\\n\\t\\tcolor: #c09111;\\n\\t}\\n\\n\\t:global(.OUT) {\\n\\t\\tcolor: #851313;\\n\\t}\\n\\n\\t:global(.IR) {\\n\\t\\tcolor: #851313;\\n\\t}\\n\\n\\t:global(.PUP) {\\n\\t\\tcolor: #851313;\\n\\t}\\n\\n\\t@media (max-width: 460px) {\\n\\t\\t:global(.nameCell) {\\n\\t\\t\\tfont-size: 0.9em;\\n\\t\\t}\\n\\t}\\n\\n</style>\\n\\n<Row>\\n\\t<Cell class=\\"slot playerCell\\"><span class=\\"pos {playerSLotClass}\\">{playerSlot}</span></Cell>\\n\\t{#if player.avatar}\\n\\t\\t<Cell class=\\"avatar playerCell\\"><div class=\\"playerAvatar\\" style=\\"{player.avatar}\\" /></Cell>\\n\\t{/if}\\n\\t{#if player.poss != \\"DEF\\"}\\n\\t\\t<Cell class=\\"playerCell teamCell\\">{player.team || ''}</Cell>\\n\\t{/if}\\n\\t<Cell class=\\"playerCell nameCell\\" colspan={player.name != \\"Empty\\" ? (player.poss == \\"DEF\\" ? 2 : 1) : 3}>{@html player.name}</Cell>\\n</Row>"],"names":[],"mappings":"AAUC,aAAa,eAAC,CAAC,AACd,cAAc,CAAE,MAAM,CACtB,MAAM,CAAE,IAAI,CACZ,KAAK,CAAE,IAAI,CACX,mBAAmB,CAAE,MAAM,CAC3B,iBAAiB,CAAE,SAAS,CAC5B,eAAe,CAAE,IAAI,CAAC,IAAI,AAC3B,CAAC,AACD,IAAI,eAAC,CAAC,AACL,OAAO,CAAE,WAAW,CACpB,WAAW,CAAE,MAAM,CACnB,eAAe,CAAE,MAAM,CACvB,aAAa,CAAE,GAAG,CAClB,KAAK,CAAE,IAAI,CACX,MAAM,CAAE,IAAI,AACb,CAAC,AAED,GAAG,eAAC,CAAC,AACJ,gBAAgB,CAAE,IAAI,IAAI,CAAC,AAC5B,CAAC,AAED,GAAG,eAAC,CAAC,AACJ,gBAAgB,CAAE,IAAI,IAAI,CAAC,AAC5B,CAAC,AAED,GAAG,eAAC,CAAC,AACJ,gBAAgB,CAAE,IAAI,IAAI,CAAC,AAC5B,CAAC,AAED,GAAG,eAAC,CAAC,AACJ,gBAAgB,CAAE,IAAI,IAAI,CAAC,AAC5B,CAAC,AAED,KAAK,eAAC,CAAC,AACN,UAAU,CAAE,gBAAgB,EAAE,CAAC,KAAK,CAAC,CAAC,IAAI,IAAI,CAAC,CAAC,CAAC,IAAI,IAAI,CAAC,CAAC,MAAM,CAAC,CAAC,IAAI,IAAI,CAAC,CAAC,MAAM,CAAC,CAAC,IAAI,IAAI,CAAC,CAAC,MAAM,CAAC,CAAC,IAAI,IAAI,CAAC,CAAC,MAAM,CAAC,AACzH,CAAC,AAED,KAAK,eAAC,CAAC,AACN,UAAU,CAAE,gBAAgB,EAAE,CAAC,KAAK,CAAC,CAAC,IAAI,IAAI,CAAC,CAAC,CAAC,IAAI,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC,IAAI,IAAI,CAAC,CAAC,GAAG,CAAC,AAC/E,CAAC,AAED,EAAE,eAAC,CAAC,AACH,gBAAgB,CAAE,IAAI,GAAG,CAAC,AAC3B,CAAC,AAED,OAAO,eAAC,CAAC,AACR,UAAU,CAAE,gBAAgB,EAAE,CAAC,KAAK,CAAC,CAAC,IAAI,IAAI,CAAC,CAAC,CAAC,IAAI,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC,IAAI,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC,IAAI,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC,IAAI,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC,IAAI,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC,IAAI,IAAI,CAAC,CAAC,CACtI,gBAAgB,CAAE,OAAO,AAC1B,CAAC,AAED,OAAO,eAAC,CAAC,AACR,UAAU,CAAE,gBAAgB,EAAE,CAAC,KAAK,CAAC,CAAC,IAAI,IAAI,CAAC,CAAC,CAAC,IAAI,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC,IAAI,IAAI,CAAC,CAAC,GAAG,CAAC,AAC/E,CAAC,AAED,IAAI,eAAC,CAAC,AACL,gBAAgB,CAAE,IAAI,KAAK,CAAC,AAC7B,CAAC,AAED,GAAG,eAAC,CAAC,AACJ,gBAAgB,CAAE,IAAI,IAAI,CAAC,AAC5B,CAAC,AAED,GAAG,eAAC,CAAC,AACJ,gBAAgB,CAAE,IAAI,IAAI,CAAC,AAC5B,CAAC,AAED,GAAG,eAAC,CAAC,AACJ,gBAAgB,CAAE,IAAI,IAAI,CAAC,AAC5B,CAAC,AAED,IAAI,eAAC,CAAC,AACL,UAAU,CAAE,gBAAgB,EAAE,CAAC,KAAK,CAAC,CAAC,IAAI,IAAI,CAAC,CAAC,CAAC,IAAI,IAAI,CAAC,CAAC,MAAM,CAAC,CAAC,IAAI,IAAI,CAAC,CAAC,MAAM,CAAC,CAAC,IAAI,IAAI,CAAC,CAAC,MAAM,CAAC,CAAC,IAAI,IAAI,CAAC,CAAC,MAAM,CAAC,AACzH,CAAC,AAED,GAAG,eAAC,CAAC,AACJ,gBAAgB,CAAE,IAAI,IAAI,CAAC,AAC5B,CAAC,AAEO,KAAK,AAAE,CAAC,AACf,KAAK,CAAE,IAAI,CAAC,UAAU,CACnB,OAAO,CAAE,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,UAAU,AACvC,CAAC,AACO,OAAO,AAAE,CAAC,AACjB,KAAK,CAAE,IAAI,AACZ,CAAC,AACO,WAAW,AAAE,CAAC,AACrB,MAAM,CAAE,IAAI,CAAC,UAAU,CACvB,UAAU,CAAE,MAAM,CAAC,UAAU,AAC9B,CAAC,AACO,SAAS,AAAE,CAAC,AACnB,SAAS,CAAE,IAAI,CAAC,UAAU,CACvB,OAAO,CAAE,CAAC,CAAC,GAAG,AAClB,CAAC,AAEO,SAAS,AAAE,CAAC,AAChB,OAAO,CAAE,CAAC,CAAC,GAAG,AAClB,CAAC,AAEO,aAAa,AAAE,CAAC,AACvB,KAAK,CAAE,IAAI,CACX,UAAU,CAAE,MAAM,CAClB,SAAS,CAAE,KAAK,AACjB,CAAC,AAEO,OAAO,AAAE,CAAC,AACjB,UAAU,CAAE,MAAM,CAClB,WAAW,CAAE,GAAG,CAChB,SAAS,CAAE,KAAK,CAChB,WAAW,CAAE,KAAK,CAClB,eAAe,KAAK,AACrB,CAAC,AAEO,EAAE,AAAE,CAAC,AACZ,KAAK,CAAE,OAAO,AACf,CAAC,AAEO,IAAI,AAAE,CAAC,AACd,KAAK,CAAE,OAAO,AACf,CAAC,AAEO,GAAG,AAAE,CAAC,AACb,KAAK,CAAE,OAAO,AACf,CAAC,AAEO,IAAI,AAAE,CAAC,AACd,KAAK,CAAE,OAAO,AACf,CAAC,AAED,MAAM,AAAC,YAAY,KAAK,CAAC,AAAC,CAAC,AAClB,SAAS,AAAE,CAAC,AACnB,SAAS,CAAE,KAAK,AACjB,CAAC,AACF,CAAC"}`
};
var RosterRow = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let { player } = $$props;
  const playerSLotClass = player.slot.replace("/", "").replace("SUPER_", "S-").replace("REC_", "R-");
  const playerSlot = player.slot.replace("SUPER_", "S ").replace("REC_", "R ");
  if ($$props.player === void 0 && $$bindings.player && player !== void 0)
    $$bindings.player(player);
  $$result.css.add(css$z);
  return `${validate_component(Row, "Row").$$render($$result, {}, {}, {
    default: () => `${validate_component(Cell, "Cell").$$render($$result, { class: "slot playerCell" }, {}, {
      default: () => `<span class="${"pos " + escape(playerSLotClass) + " svelte-17wj27k"}">${escape(playerSlot)}</span>`
    })}
	${player.avatar ? `${validate_component(Cell, "Cell").$$render($$result, { class: "avatar playerCell" }, {}, {
      default: () => `<div class="${"playerAvatar svelte-17wj27k"}"${add_attribute("style", player.avatar, 0)}></div>`
    })}` : ``}
	${player.poss != "DEF" ? `${validate_component(Cell, "Cell").$$render($$result, { class: "playerCell teamCell" }, {}, {
      default: () => `${escape(player.team || "")}`
    })}` : ``}
	${validate_component(Cell, "Cell").$$render($$result, {
      class: "playerCell nameCell",
      colspan: player.name != "Empty" ? player.poss == "DEF" ? 2 : 1 : 3
    }, {}, {
      default: () => `<!-- HTML_TAG_START -->${player.name}<!-- HTML_TAG_END -->`
    })}`
  })}`;
});
var css$y = {
  code: "h5.svelte-pesiwv{text-align:center;margin:0.2em auto}.teamAvatar.svelte-pesiwv{vertical-align:middle;border-radius:50%;height:40px;margin-right:15px;border:0.25px solid #777}.team.svelte-pesiwv{margin:4px 10px 10px}.clickable{cursor:pointer}.teamInner{box-shadow:0px 3px 3px -2px var(--boxShadowOne), 0px 3px 4px 0px var(--boxShadowTwo), 0px 1px 8px 0px var(--boxShadowThree);display:block;margin:0 auto}.rosterBench.svelte-pesiwv{overflow:hidden;width:100%;display:block;transition:max-height 0.7s ease-in-out}.r_1{text-align:center;background-color:var(--r1)}.r_2{text-align:center;background-color:var(--r2)}.r_3{text-align:center;background-color:var(--r3)}.record.svelte-pesiwv{width:100%;margin-bottom:5px;display:flex;justify-content:space-around}.result.svelte-pesiwv{width:11px}h3.svelte-pesiwv{font-size:1.5em;font-weight:500;margin:12px 0}h5.svelte-pesiwv{font-size:1.2em;text-align:center}@media(max-width: 500px){.team.svelte-pesiwv{font-size:0.9em}.result.svelte-pesiwv{width:9px}h3.svelte-pesiwv{font-size:1.3em;margin:3px 0}h5.svelte-pesiwv{font-size:1.1em}}@media(max-width: 340px){h3.svelte-pesiwv{font-size:1.1em;margin:6px 0}h5.svelte-pesiwv{font-size:1em}}@media(max-width: 400px){.team.svelte-pesiwv{margin:4px auto 10px}}.icon{vertical-align:middle}.italic.svelte-pesiwv{color:#aaa;font-style:italic}.interactive{vertical-align:middle;cursor:pointer}.bench{background-color:var(--ir)}",
  map: '{"version":3,"file":"Roster.svelte","sources":["Roster.svelte"],"sourcesContent":["<script>\\n\\timport { gotoManager } from \'$lib/utils/helper\';\\n  \\timport DataTable, { Head, Body, Row, Cell } from \'@smui/data-table\';\\n\\timport { Icon } from \'@smui/icon-button\';\\n\\timport RosterRow from \\"./RosterRow.svelte\\"\\n\\t\\n\\texport let roster, users, startersAndReserve, players, rosterPositions, division, expanded;\\n\\n\\t$: user = users[roster.owner_id];\\n\\n\\tlet i = 0;\\n\\n\\tconst digestData = (passedPlayers, rawPlayers, startingPlayers = false, reserve = false) => {\\n\\t\\tlet digestedRoster = [];\\n\\t\\n\\t\\tfor(const singlePlayer of rawPlayers) {\\n\\t\\t\\tif(!startingPlayers && !reserve && startersAndReserve.includes(singlePlayer)) {\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\t\\t\\tlet player = {};\\n\\t\\t\\tlet slot = \\"BN\\"\\n\\t\\t\\tif(startingPlayers) {\\n\\t\\t\\t\\tslot = rosterPositions[i] == \\"WRRB_FLEX\\" ? \\"WR/RB\\" : rosterPositions[i];\\n\\t\\t\\t}\\n\\n\\t\\t\\tif(singlePlayer == \\"0\\") {\\n\\t\\t\\t\\tplayer = {\\n\\t\\t\\t\\t\\tname: \\"Empty\\",\\n\\t\\t\\t\\t\\tposs: null,\\n\\t\\t\\t\\t\\tteam: null,\\n\\t\\t\\t\\t\\tavatar: null,\\n\\t\\t\\t\\t\\tslot: slot\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t\\tdigestedRoster.push(player);\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\n\\t\\t\\tlet injury = null;\\n\\t\\t\\tswitch (passedPlayers[singlePlayer].is) {\\n\\t\\t\\t\\tcase \\"Questionable\\":\\n\\t\\t\\t\\t\\tinjury = \\"Q\\";\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tcase \\"Out\\":\\n\\t\\t\\t\\t\\tinjury = \\"OUT\\";\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tcase \\"PUP\\":\\n\\t\\t\\t\\t\\tinjury = \\"PUP\\";\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tcase \\"IR\\":\\n\\t\\t\\t\\t\\tinjury = \\"IR\\";\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\n\\t\\t\\t\\tdefault:\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tplayer = {\\n\\t\\t\\t\\tname: `${passedPlayers[singlePlayer].fn} ${passedPlayers[singlePlayer].ln}${injury ? `<span class=\\"injury ${injury}\\">${injury}</span>` : \\"\\"}${roster.metadata && roster.metadata[`p_nick_${singlePlayer}`] ? `<br /><span class=\\"nickname\\">\\"${roster.metadata[`p_nick_${singlePlayer}`]}\\"</span>` : \\"\\"}`,\\n\\t\\t\\t\\tposs: passedPlayers[singlePlayer].pos,\\n\\t\\t\\t\\tteam: passedPlayers[singlePlayer].t,\\n\\t\\t\\t\\tavatar: passedPlayers[singlePlayer].pos == \\"DEF\\" ? `background-image: url(https://sleepercdn.com/images/team_logos/nfl/${singlePlayer.toLowerCase()}.png)` : `background-image: url(https://sleepercdn.com/content/nfl/players/thumb/${singlePlayer}.jpg), url(https://sleepercdn.com/images/v2/icons/player_default.webp)`,\\n\\t\\t\\t\\tslot: slot\\n\\t\\t\\t}\\n\\t\\t\\ti++;\\n\\t\\t\\tdigestedRoster.push(player);\\n\\t\\t}\\n\\t\\ti = 0;\\n\\n\\t\\treturn digestedRoster;\\n\\t}\\n\\n\\t$: finalStarters = digestData(players, roster.starters, true);\\n\\tlet finalBench = [];\\n\\t$: if(roster.players) {\\n\\t\\tfinalBench = digestData(players, roster.players);\\n\\t}\\n\\tlet finalIR = null;\\n\\tif(roster.reserve) {\\n\\t\\tfinalIR = digestData(players, roster.reserve, false, true);\\n\\t}\\n\\n\\tconst buildRecord = (newRoster) => {\\n\\t\\tconst innerRecord = [];\\n\\t\\t// Check to make sure that record exists\\n\\t\\tif(!newRoster.metadata || !newRoster.metadata.record) return innerRecord;\\n\\t\\t// simplify record\\n\\t\\tfor (const c of newRoster.metadata.record) {\\n\\t\\t\\tswitch (c) {\\n\\t\\t\\t\\tcase \\"W\\":\\n\\t\\t\\t\\t\\tinnerRecord.push(\\"green\\");\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tcase \\"L\\":\\n\\t\\t\\t\\t\\tinnerRecord.push(\\"red\\");\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\n\\t\\t\\t\\tdefault:\\n\\t\\t\\t\\t\\tinnerRecord.push(\\"gray\\");\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn innerRecord;\\n\\t}\\n\\n\\t$: record = buildRecord(roster);\\n\\n\\tlet selected = \\"0px\\";\\n\\tlet status = \\"minimized\\";\\n\\tconst toggleSelected = () => {\\n\\t\\tselected = selected == \\"0px\\" ? calcHeight() + \\"px\\" : \\"0px\\";\\n\\t\\tstatus = status == \\"minimized\\" ? \\"expanded\\" : \\"minimized\\";\\n\\t}\\n\\n\\tlet innerWidth;\\n\\n\\tconst calcHeight = () => {\\n\\t\\tconst multiplier = 48;\\n\\t\\tconst benchLength = finalBench.length * multiplier + 53;\\n\\t\\tlet irLength = 0;\\n\\t\\tif(finalIR) {\\n\\t\\t\\tirLength = finalIR.length * multiplier + 52;\\n\\t\\t}\\n\\t\\treturn benchLength + irLength;\\n\\t}\\n\\n\\t$: {\\n\\t\\tselected = expanded ? calcHeight() + \\"px\\" : \\"0px\\";\\n\\t\\tstatus = expanded ? \\"expanded\\" : \\"minimized\\";\\n\\t}\\n\\n<\/script>\\n\\n<svelte:window bind:innerWidth={innerWidth} />\\n\\n<style>\\n\\th5 {\\n    text-align: center;\\n\\t\\tmargin: 0.2em auto;\\n\\t}\\n\\t\\n\\t.teamAvatar {\\n\\t\\tvertical-align: middle;\\n\\t\\tborder-radius: 50%;\\n\\t\\theight: 40px;\\n\\t\\tmargin-right: 15px;\\n\\t\\tborder: 0.25px solid #777;\\n\\t}\\n\\n\\t.team {\\n\\t\\tmargin: 4px 10px 10px;\\n\\t}\\n\\n\\t:global(.clickable) {\\n\\t\\tcursor: pointer;\\n\\t}\\n\\n\\t:global(.teamInner) {\\n\\t\\tbox-shadow: 0px 3px 3px -2px var(--boxShadowOne), 0px 3px 4px 0px var(--boxShadowTwo), 0px 1px 8px 0px var(--boxShadowThree);\\n\\t\\tdisplay: block;\\n\\t    margin: 0 auto;\\n\\t}\\n\\n\\t.rosterBench{\\n\\t\\toverflow: hidden;\\n\\t\\twidth: 100%;\\n\\t\\tdisplay: block;\\n\\t\\ttransition: max-height 0.7s ease-in-out;\\n\\t}\\n\\n\\t:global(.r_1) {\\n\\t\\ttext-align: center;\\n\\t\\tbackground-color: var(--r1);\\n\\t}\\n\\n\\t:global(.r_2) {\\n\\t\\ttext-align: center;\\n\\t\\tbackground-color: var(--r2);\\n\\t}\\n\\n\\t:global(.r_3) {\\n\\t\\ttext-align: center;\\n\\t\\tbackground-color: var(--r3);\\n\\t}\\n\\n\\t.record {\\n\\t\\twidth: 100%;\\n\\t\\tmargin-bottom: 5px;\\n\\t\\tdisplay: flex;\\n\\t\\tjustify-content: space-around;\\n\\t}\\n\\n\\t.result {\\n\\t\\twidth: 11px;\\n\\t}\\n\\n\\th3 {\\n\\t\\tfont-size: 1.5em;\\n\\t\\tfont-weight: 500;\\n\\t\\tmargin: 12px 0;\\n\\t}\\n\\n\\th5 {\\n\\t\\tfont-size: 1.2em;\\n\\t\\ttext-align: center;\\n\\t}\\n\\n\\t@media (max-width: 500px) {\\n\\t\\t.team {\\n\\t\\t\\tfont-size: 0.9em;\\n\\t\\t}\\n\\t\\t.result {\\n\\t\\t\\twidth: 9px;\\n\\t\\t}\\n\\n\\t\\th3 {\\n\\t\\t\\tfont-size: 1.3em;\\n\\t\\t\\tmargin: 3px 0;\\n\\t\\t}\\n\\n\\t\\th5 {\\n\\t\\t\\tfont-size: 1.1em;\\n\\t\\t}\\n\\t}\\n\\n\\t@media (max-width: 340px) {\\n\\t\\th3 {\\n\\t\\t\\tfont-size: 1.1em;\\n\\t\\t\\tmargin: 6px 0;\\n\\t\\t}\\n\\n\\t\\th5 {\\n\\t\\t\\tfont-size: 1em;\\n\\t\\t}\\n\\t}\\n\\n\\t@media (max-width: 400px) {\\n\\t\\t.team {\\n\\t\\t\\tmargin: 4px auto 10px;\\n\\t\\t}\\n\\t}\\n\\n\\t:global(.icon) {\\n\\t\\tvertical-align: middle;\\n\\t}\\n\\n\\t.italic {\\n\\t\\tcolor: #aaa;\\n\\t\\tfont-style: italic;\\n\\t}\\n\\n\\t:global(.interactive) {\\n\\t\\tvertical-align: middle;\\n\\t\\tcursor: pointer;\\n\\t}\\n\\n\\t:global(.bench) {\\n\\t\\tbackground-color: var(--ir);\\n\\t}\\n</style>\\n\\n<div class=\\"team\\">\\n\\t<DataTable class=\\"teamInner\\" table$aria-label=\\"Team Name\\" style=\\"width: {innerWidth * 0.95 > 380 ? 380 : innerWidth * 0.95}px;\\" >\\n\\t\\t<Head> <!-- Team name  -->\\n\\t\\t\\t<Row>\\n\\t\\t\\t\\t<Cell colspan=4 class=\\"r_{division} clickable\\">\\n\\t\\t\\t\\t\\t<h3 on:click={() => gotoManager(roster.roster_id)}>\\n\\t\\t\\t\\t\\t\\t<img alt=\\"team avatar\\" class=\\"teamAvatar\\" src=\\"https://sleepercdn.com/avatars/thumbs/{user.avatar}\\" />\\n\\t\\t\\t\\t\\t\\t{user.metadata.team_name ? user.metadata.team_name : user.display_name}\\n\\t\\t\\t\\t\\t</h3>\\n\\n\\t\\t\\t\\t\\t<div class=\\"record\\">\\n\\t\\t\\t\\t\\t\\t{#each record as result}\\n\\t\\t\\t\\t\\t\\t\\t<img alt=\\"match result\\" class=\\"result\\" src=\\"./{result}.png\\" />\\n\\t\\t\\t\\t\\t\\t{/each}\\n\\t\\t\\t\\t\\t</div>\\n\\t\\t\\t\\t</Cell>\\n\\t\\t\\t</Row>\\n\\t\\t</Head>\\n\\t\\t<Body>\\n\\t\\t\\t<!-- \\tStarters\\t -->\\n\\t\\t\\t{#each finalStarters as starter}\\n\\t\\t\\t\\t<RosterRow player={starter} />\\n\\t\\t\\t{/each}\\n\\t\\t\\t<Row class=\\"interactive\\" on:click={toggleSelected}>\\n\\t\\t\\t\\t<Cell colspan=4 class=\\"{division}\\"><h5><Icon class=\\"material-icons icon\\">king_bed</Icon> Bench <span class=\\"italic\\">({status})</span></h5></Cell>\\n\\t\\t\\t</Row>\\n\\t\\t</Body>\\n\\t</DataTable>\\n\\t<div class=\\"rosterBench\\" style=\\"max-height: {selected}\\">\\n\\t\\t<DataTable class=\\"teamInner\\" style=\\"width: 380px\\" >\\n\\t\\t\\t<Body class=\\"bench\\">\\n\\t\\t\\t\\t<!-- \\tBench\\t -->\\n\\t\\t\\t\\t{#each finalBench as bench}\\n\\t\\t\\t\\t\\t<RosterRow player={bench} />\\n\\t\\t\\t\\t{/each}\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t<!-- \\tIR\\t -->\\n\\t\\t\\t\\t{#if finalIR}\\n\\t\\t\\t\\t\\t<Row>\\n\\t\\t\\t\\t\\t<Cell colspan=4 ><h5><Icon class=\\"material-icons icon\\">healing</Icon> Injured Reserve</h5></Cell>\\n\\t\\t\\t\\t\\t</Row>\\n\\t\\t\\t\\t\\t{#each finalIR as ir}\\n\\t\\t\\t\\t\\t\\t<RosterRow player={ir} />\\n\\t\\t\\t\\t\\t{/each}\\n\\t\\t\\t\\t{/if}\\n\\t\\t\\t\\t<Row class=\\"interactive\\" on:click={toggleSelected}>\\n\\t\\t\\t\\t\\t<Cell colspan=4 class=\\"{division}\\"><h5><Icon class=\\"material-icons icon\\">close_fullscreen</Icon>Close Bench</h5></Cell>\\n\\t\\t\\t\\t</Row>\\n\\t\\t\\t</Body>\\n\\t\\t</DataTable>\\n\\t</div>\\n</div>\\n"],"names":[],"mappings":"AAsIC,EAAE,cAAC,CAAC,AACD,UAAU,CAAE,MAAM,CACpB,MAAM,CAAE,KAAK,CAAC,IAAI,AACnB,CAAC,AAED,WAAW,cAAC,CAAC,AACZ,cAAc,CAAE,MAAM,CACtB,aAAa,CAAE,GAAG,CAClB,MAAM,CAAE,IAAI,CACZ,YAAY,CAAE,IAAI,CAClB,MAAM,CAAE,MAAM,CAAC,KAAK,CAAC,IAAI,AAC1B,CAAC,AAED,KAAK,cAAC,CAAC,AACN,MAAM,CAAE,GAAG,CAAC,IAAI,CAAC,IAAI,AACtB,CAAC,AAEO,UAAU,AAAE,CAAC,AACpB,MAAM,CAAE,OAAO,AAChB,CAAC,AAEO,UAAU,AAAE,CAAC,AACpB,UAAU,CAAE,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI,CAAC,IAAI,cAAc,CAAC,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI,cAAc,CAAC,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI,gBAAgB,CAAC,CAC5H,OAAO,CAAE,KAAK,CACX,MAAM,CAAE,CAAC,CAAC,IAAI,AAClB,CAAC,AAED,0BAAY,CAAC,AACZ,QAAQ,CAAE,MAAM,CAChB,KAAK,CAAE,IAAI,CACX,OAAO,CAAE,KAAK,CACd,UAAU,CAAE,UAAU,CAAC,IAAI,CAAC,WAAW,AACxC,CAAC,AAEO,IAAI,AAAE,CAAC,AACd,UAAU,CAAE,MAAM,CAClB,gBAAgB,CAAE,IAAI,IAAI,CAAC,AAC5B,CAAC,AAEO,IAAI,AAAE,CAAC,AACd,UAAU,CAAE,MAAM,CAClB,gBAAgB,CAAE,IAAI,IAAI,CAAC,AAC5B,CAAC,AAEO,IAAI,AAAE,CAAC,AACd,UAAU,CAAE,MAAM,CAClB,gBAAgB,CAAE,IAAI,IAAI,CAAC,AAC5B,CAAC,AAED,OAAO,cAAC,CAAC,AACR,KAAK,CAAE,IAAI,CACX,aAAa,CAAE,GAAG,CAClB,OAAO,CAAE,IAAI,CACb,eAAe,CAAE,YAAY,AAC9B,CAAC,AAED,OAAO,cAAC,CAAC,AACR,KAAK,CAAE,IAAI,AACZ,CAAC,AAED,EAAE,cAAC,CAAC,AACH,SAAS,CAAE,KAAK,CAChB,WAAW,CAAE,GAAG,CAChB,MAAM,CAAE,IAAI,CAAC,CAAC,AACf,CAAC,AAED,EAAE,cAAC,CAAC,AACH,SAAS,CAAE,KAAK,CAChB,UAAU,CAAE,MAAM,AACnB,CAAC,AAED,MAAM,AAAC,YAAY,KAAK,CAAC,AAAC,CAAC,AAC1B,KAAK,cAAC,CAAC,AACN,SAAS,CAAE,KAAK,AACjB,CAAC,AACD,OAAO,cAAC,CAAC,AACR,KAAK,CAAE,GAAG,AACX,CAAC,AAED,EAAE,cAAC,CAAC,AACH,SAAS,CAAE,KAAK,CAChB,MAAM,CAAE,GAAG,CAAC,CAAC,AACd,CAAC,AAED,EAAE,cAAC,CAAC,AACH,SAAS,CAAE,KAAK,AACjB,CAAC,AACF,CAAC,AAED,MAAM,AAAC,YAAY,KAAK,CAAC,AAAC,CAAC,AAC1B,EAAE,cAAC,CAAC,AACH,SAAS,CAAE,KAAK,CAChB,MAAM,CAAE,GAAG,CAAC,CAAC,AACd,CAAC,AAED,EAAE,cAAC,CAAC,AACH,SAAS,CAAE,GAAG,AACf,CAAC,AACF,CAAC,AAED,MAAM,AAAC,YAAY,KAAK,CAAC,AAAC,CAAC,AAC1B,KAAK,cAAC,CAAC,AACN,MAAM,CAAE,GAAG,CAAC,IAAI,CAAC,IAAI,AACtB,CAAC,AACF,CAAC,AAEO,KAAK,AAAE,CAAC,AACf,cAAc,CAAE,MAAM,AACvB,CAAC,AAED,OAAO,cAAC,CAAC,AACR,KAAK,CAAE,IAAI,CACX,UAAU,CAAE,MAAM,AACnB,CAAC,AAEO,YAAY,AAAE,CAAC,AACtB,cAAc,CAAE,MAAM,CACtB,MAAM,CAAE,OAAO,AAChB,CAAC,AAEO,MAAM,AAAE,CAAC,AAChB,gBAAgB,CAAE,IAAI,IAAI,CAAC,AAC5B,CAAC"}'
};
var Roster = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let user;
  let finalStarters;
  let record;
  let { roster, users: users2, startersAndReserve, players: players2, rosterPositions, division, expanded } = $$props;
  let i = 0;
  const digestData = (passedPlayers, rawPlayers, startingPlayers = false, reserve = false) => {
    let digestedRoster = [];
    for (const singlePlayer of rawPlayers) {
      if (!startingPlayers && !reserve && startersAndReserve.includes(singlePlayer)) {
        continue;
      }
      let player = {};
      let slot = "BN";
      if (startingPlayers) {
        slot = rosterPositions[i] == "WRRB_FLEX" ? "WR/RB" : rosterPositions[i];
      }
      if (singlePlayer == "0") {
        player = {
          name: "Empty",
          poss: null,
          team: null,
          avatar: null,
          slot
        };
        i++;
        digestedRoster.push(player);
        continue;
      }
      let injury = null;
      switch (passedPlayers[singlePlayer].is) {
        case "Questionable":
          injury = "Q";
          break;
        case "Out":
          injury = "OUT";
          break;
        case "PUP":
          injury = "PUP";
          break;
        case "IR":
          injury = "IR";
          break;
      }
      player = {
        name: `${passedPlayers[singlePlayer].fn} ${passedPlayers[singlePlayer].ln}${injury ? `<span class="injury ${injury}">${injury}</span>` : ""}${roster.metadata && roster.metadata[`p_nick_${singlePlayer}`] ? `<br /><span class="nickname">"${roster.metadata[`p_nick_${singlePlayer}`]}"</span>` : ""}`,
        poss: passedPlayers[singlePlayer].pos,
        team: passedPlayers[singlePlayer].t,
        avatar: passedPlayers[singlePlayer].pos == "DEF" ? `background-image: url(https://sleepercdn.com/images/team_logos/nfl/${singlePlayer.toLowerCase()}.png)` : `background-image: url(https://sleepercdn.com/content/nfl/players/thumb/${singlePlayer}.jpg), url(https://sleepercdn.com/images/v2/icons/player_default.webp)`,
        slot
      };
      i++;
      digestedRoster.push(player);
    }
    i = 0;
    return digestedRoster;
  };
  let finalBench = [];
  let finalIR = null;
  if (roster.reserve) {
    finalIR = digestData(players2, roster.reserve, false, true);
  }
  const buildRecord = (newRoster) => {
    const innerRecord = [];
    if (!newRoster.metadata || !newRoster.metadata.record)
      return innerRecord;
    for (const c of newRoster.metadata.record) {
      switch (c) {
        case "W":
          innerRecord.push("green");
          break;
        case "L":
          innerRecord.push("red");
          break;
        default:
          innerRecord.push("gray");
          break;
      }
    }
    return innerRecord;
  };
  let selected = "0px";
  let status = "minimized";
  let innerWidth;
  const calcHeight = () => {
    const multiplier = 48;
    const benchLength = finalBench.length * multiplier + 53;
    let irLength = 0;
    if (finalIR) {
      irLength = finalIR.length * multiplier + 52;
    }
    return benchLength + irLength;
  };
  if ($$props.roster === void 0 && $$bindings.roster && roster !== void 0)
    $$bindings.roster(roster);
  if ($$props.users === void 0 && $$bindings.users && users2 !== void 0)
    $$bindings.users(users2);
  if ($$props.startersAndReserve === void 0 && $$bindings.startersAndReserve && startersAndReserve !== void 0)
    $$bindings.startersAndReserve(startersAndReserve);
  if ($$props.players === void 0 && $$bindings.players && players2 !== void 0)
    $$bindings.players(players2);
  if ($$props.rosterPositions === void 0 && $$bindings.rosterPositions && rosterPositions !== void 0)
    $$bindings.rosterPositions(rosterPositions);
  if ($$props.division === void 0 && $$bindings.division && division !== void 0)
    $$bindings.division(division);
  if ($$props.expanded === void 0 && $$bindings.expanded && expanded !== void 0)
    $$bindings.expanded(expanded);
  $$result.css.add(css$y);
  user = users2[roster.owner_id];
  finalStarters = digestData(players2, roster.starters, true);
  {
    if (roster.players) {
      finalBench = digestData(players2, roster.players);
    }
  }
  record = buildRecord(roster);
  {
    {
      selected = expanded ? calcHeight() + "px" : "0px";
      status = expanded ? "expanded" : "minimized";
    }
  }
  return `



<div class="${"team svelte-pesiwv"}">${validate_component(DataTable, "DataTable").$$render($$result, {
    class: "teamInner",
    "table$aria-label": "Team Name",
    style: "width: " + innerWidth * 0.95 + "px;"
  }, {}, {
    default: () => `${validate_component(Head, "Head").$$render($$result, {}, {}, {
      default: () => `
			${validate_component(Row, "Row").$$render($$result, {}, {}, {
        default: () => `${validate_component(Cell, "Cell").$$render($$result, {
          colspan: "4",
          class: "r_" + division + " clickable"
        }, {}, {
          default: () => `<h3 class="${"svelte-pesiwv"}"><img alt="${"team avatar"}" class="${"teamAvatar svelte-pesiwv"}" src="${"https://sleepercdn.com/avatars/thumbs/" + escape(user.avatar)}">
						${escape(user.metadata.team_name ? user.metadata.team_name : user.display_name)}</h3>

					<div class="${"record svelte-pesiwv"}">${each(record, (result) => `<img alt="${"match result"}" class="${"result svelte-pesiwv"}" src="${"./" + escape(result) + ".png"}">`)}</div>`
        })}`
      })}`
    })}
		${validate_component(Body2, "Body").$$render($$result, {}, {}, {
      default: () => `
			${each(finalStarters, (starter) => `${validate_component(RosterRow, "RosterRow").$$render($$result, { player: starter }, {}, {})}`)}
			${validate_component(Row, "Row").$$render($$result, { class: "interactive" }, {}, {
        default: () => `${validate_component(Cell, "Cell").$$render($$result, { colspan: "4", class: division }, {}, {
          default: () => `<h5 class="${"svelte-pesiwv"}">${validate_component(CommonIcon, "Icon").$$render($$result, { class: "material-icons icon" }, {}, { default: () => `king_bed` })} Bench <span class="${"italic svelte-pesiwv"}">(${escape(status)})</span></h5>`
        })}`
      })}`
    })}`
  })}
	<div class="${"rosterBench svelte-pesiwv"}" style="${"max-height: " + escape(selected)}">${validate_component(DataTable, "DataTable").$$render($$result, {
    class: "teamInner",
    style: "width: 380px"
  }, {}, {
    default: () => `${validate_component(Body2, "Body").$$render($$result, { class: "bench" }, {}, {
      default: () => `
				${each(finalBench, (bench) => `${validate_component(RosterRow, "RosterRow").$$render($$result, { player: bench }, {}, {})}`)}
				
				
				${finalIR ? `${validate_component(Row, "Row").$$render($$result, {}, {}, {
        default: () => `${validate_component(Cell, "Cell").$$render($$result, { colspan: "4" }, {}, {
          default: () => `<h5 class="${"svelte-pesiwv"}">${validate_component(CommonIcon, "Icon").$$render($$result, { class: "material-icons icon" }, {}, { default: () => `healing` })} Injured Reserve</h5>`
        })}`
      })}
					${each(finalIR, (ir) => `${validate_component(RosterRow, "RosterRow").$$render($$result, { player: ir }, {}, {})}`)}` : ``}
				${validate_component(Row, "Row").$$render($$result, { class: "interactive" }, {}, {
        default: () => `${validate_component(Cell, "Cell").$$render($$result, { colspan: "4", class: division }, {}, {
          default: () => `<h5 class="${"svelte-pesiwv"}">${validate_component(CommonIcon, "Icon").$$render($$result, { class: "material-icons icon" }, {}, { default: () => `close_fullscreen` })}Close Bench</h5>`
        })}`
      })}`
    })}`
  })}</div></div>`;
});
var css$x = {
  code: '.division.svelte-1pygyj4.svelte-1pygyj4{display:flex;justify-content:space-around;flex-wrap:wrap;margin:10px auto 20px;width:95%}.banner.svelte-1pygyj4.svelte-1pygyj4{display:flex;align-items:center;justify-content:center;height:140px;width:400px;border-radius:40px;margin:10px auto;background-repeat:no-repeat;background-size:auto 140px}.banner-D-1.svelte-1pygyj4.svelte-1pygyj4{background-image:url("/division-1-banner.png");background-position:left}.banner-D-2.svelte-1pygyj4.svelte-1pygyj4{background-image:url("/division-2-banner.png");background-position:right}.banner-D-3.svelte-1pygyj4.svelte-1pygyj4{background-image:url("/division-3-banner.png");background-position:left}h2.svelte-1pygyj4.svelte-1pygyj4{text-align:center;font-size:3em}@media(max-width: 460px){.banner.svelte-1pygyj4.svelte-1pygyj4{height:110px;width:315px;background-repeat:no-repeat;background-size:auto 110px}h2.svelte-1pygyj4.svelte-1pygyj4{font-size:2.5em}}@media(max-width: 360px){.banner.svelte-1pygyj4.svelte-1pygyj4{height:90px;width:258px;background-repeat:no-repeat;background-size:auto 90px}h2.svelte-1pygyj4.svelte-1pygyj4{font-size:2em}}.banner.svelte-1pygyj4 h2.svelte-1pygyj4{text-shadow:var(--fff) 0px 0px 3px, var(--fff) 0px 0px 3px, var(--fff) 0px 0px 3px,\n            		 var(--fff) 0px 0px 3px, var(--fff) 0px 0px 3px, var(--fff) 0px 0px 3px;-webkit-font-smoothing:antialiased}.minExp.svelte-1pygyj4.svelte-1pygyj4{display:block;text-align:center;margin:10px 0;cursor:pointer}.loading.svelte-1pygyj4.svelte-1pygyj4{display:block;width:85%;max-width:500px;margin:80px auto}.expandButton.svelte-1pygyj4.svelte-1pygyj4{margin:5em auto 2em;text-align:center}',
  map: `{"version":3,"file":"RosterSorter.svelte","sources":["RosterSorter.svelte"],"sourcesContent":["<script>\\n    import Button, { Label } from '@smui/button';\\n\\timport Roster from './Roster.svelte';\\n\\t\\n\\texport let rosters, users, startersAndReserve, leagueData, players;\\n\\n\\tconst rosterPositions = leagueData.roster_positions;\\n\\n\\n\\tconst numDivisions = leagueData.settings.divisions || 1;\\n\\n\\tconst divisions = [];\\n\\n\\tfor(let i = 0; i < numDivisions; i++) {\\n\\t\\tdivisions.push({\\n\\t\\t\\tname: leagueData.metadata ? leagueData.metadata[\`division_\${i + 1}\`] : null,\\n\\t\\t\\trosters: [],\\n\\t\\t})\\n\\t}\\n\\n\\tfor(const roster of rosters) {\\n\\t\\tdivisions[roster.settings.division ? roster.settings.division - 1 : 0].rosters.push(roster);\\n\\t}\\n\\n\\tlet expanded = false;\\n<\/script>\\n\\n<style>\\n\\t.division {\\n\\t\\tdisplay: flex;\\n\\t\\tjustify-content: space-around;\\n\\t\\tflex-wrap: wrap;\\n\\t\\tmargin: 10px auto 20px;\\n\\t\\twidth: 95%;\\n\\t}\\n\\n\\t.banner {\\n\\t\\tdisplay: flex;\\n\\t\\talign-items: center;\\n\\t\\tjustify-content: center;\\n\\t\\theight: 140px;\\n\\t\\twidth: 400px;\\n\\t\\tborder-radius: 40px;\\n\\t\\tmargin: 10px auto;\\n\\t\\tbackground-repeat: no-repeat;\\n\\t\\tbackground-size: auto 140px;\\n\\t}\\n\\n\\t.banner-D-1 {\\n\\t\\tbackground-image: url(\\"/division-1-banner.png\\");\\n\\t\\tbackground-position: left; \\n\\t}\\n\\n\\t.banner-D-2 {\\n\\t\\tbackground-image: url(\\"/division-2-banner.png\\");\\n\\t\\tbackground-position: right; \\n\\t}\\n\\n\\t.banner-D-3 {\\n\\t\\tbackground-image: url(\\"/division-3-banner.png\\");\\n\\t\\tbackground-position: left; \\n\\t}\\n\\n\\th2 {\\n\\t\\ttext-align: center;\\n\\t\\tfont-size: 3em;\\n\\t}\\n\\n\\t@media (max-width: 460px) {\\n\\t\\t.banner {\\n\\t\\t\\theight: 110px;\\n\\t\\t\\twidth: 315px;\\n\\t\\t\\tbackground-repeat: no-repeat;\\n\\t\\t\\tbackground-size: auto 110px;\\n\\t\\t}\\n\\n\\t\\th2 {\\n\\t\\t\\tfont-size: 2.5em;\\n\\t\\t}\\n\\t}\\n\\n\\t@media (max-width: 360px) {\\n\\t\\t.banner {\\n\\t\\t\\theight: 90px;\\n\\t\\t\\twidth: 258px;\\n\\t\\t\\tbackground-repeat: no-repeat;\\n\\t\\t\\tbackground-size: auto 90px;\\n\\t\\t}\\n\\n\\t\\th2 {\\n\\t\\t\\tfont-size: 2em;\\n\\t\\t}\\n\\t}\\n\\n\\t.banner h2 {\\n\\t\\ttext-shadow: var(--fff) 0px 0px 3px, var(--fff) 0px 0px 3px, var(--fff) 0px 0px 3px,\\n            \\t\\t var(--fff) 0px 0px 3px, var(--fff) 0px 0px 3px, var(--fff) 0px 0px 3px;\\n\\t\\t-webkit-font-smoothing: antialiased;\\n\\t}\\n\\n\\t.minExp {\\n\\t\\tdisplay: block;\\n\\t\\ttext-align: center;\\n\\t\\tmargin: 10px 0;\\n\\t\\tcursor: pointer;\\n\\t}\\n\\n\\t.loading {\\n\\t\\tdisplay: block;\\n\\t\\twidth: 85%;\\n\\t\\tmax-width: 500px;\\n\\t\\tmargin: 80px auto;\\n\\t}\\n\\n\\t.expandButton {\\n\\t\\tmargin: 5em auto 2em;\\n    \\ttext-align: center;\\n\\t}\\n</style>\\n\\n<div class=\\"expandButton\\">\\n\\t<Button on:click={() => {expanded = !expanded}} variant=\\"outlined\\">\\n\\t\\t<Label>{expanded ? \\"Minimize\\" : \\"Expand\\"} All Benches</Label>\\n\\t</Button>\\n</div>\\n\\n{#each divisions as division, ix}\\n\\t{#if division.name}\\n\\t\\t<div class=\\"banner banner-D-{ix + 1}\\">\\n\\t\\t\\t<h2>{division.name}</h2>\\n\\t\\t</div>\\n\\t{/if}\\n\\t<div class=\\"division\\">\\n\\t\\t{#each division.rosters as roster}\\n\\t\\t\\t<Roster division={ix + 1} {expanded} {rosterPositions} {roster} {users} {players} {startersAndReserve} />\\n\\t\\t{/each}\\n\\t</div>\\n{/each}\\n"],"names":[],"mappings":"AA4BC,SAAS,8BAAC,CAAC,AACV,OAAO,CAAE,IAAI,CACb,eAAe,CAAE,YAAY,CAC7B,SAAS,CAAE,IAAI,CACf,MAAM,CAAE,IAAI,CAAC,IAAI,CAAC,IAAI,CACtB,KAAK,CAAE,GAAG,AACX,CAAC,AAED,OAAO,8BAAC,CAAC,AACR,OAAO,CAAE,IAAI,CACb,WAAW,CAAE,MAAM,CACnB,eAAe,CAAE,MAAM,CACvB,MAAM,CAAE,KAAK,CACb,KAAK,CAAE,KAAK,CACZ,aAAa,CAAE,IAAI,CACnB,MAAM,CAAE,IAAI,CAAC,IAAI,CACjB,iBAAiB,CAAE,SAAS,CAC5B,eAAe,CAAE,IAAI,CAAC,KAAK,AAC5B,CAAC,AAED,WAAW,8BAAC,CAAC,AACZ,gBAAgB,CAAE,IAAI,wBAAwB,CAAC,CAC/C,mBAAmB,CAAE,IAAI,AAC1B,CAAC,AAED,WAAW,8BAAC,CAAC,AACZ,gBAAgB,CAAE,IAAI,wBAAwB,CAAC,CAC/C,mBAAmB,CAAE,KAAK,AAC3B,CAAC,AAED,WAAW,8BAAC,CAAC,AACZ,gBAAgB,CAAE,IAAI,wBAAwB,CAAC,CAC/C,mBAAmB,CAAE,IAAI,AAC1B,CAAC,AAED,EAAE,8BAAC,CAAC,AACH,UAAU,CAAE,MAAM,CAClB,SAAS,CAAE,GAAG,AACf,CAAC,AAED,MAAM,AAAC,YAAY,KAAK,CAAC,AAAC,CAAC,AAC1B,OAAO,8BAAC,CAAC,AACR,MAAM,CAAE,KAAK,CACb,KAAK,CAAE,KAAK,CACZ,iBAAiB,CAAE,SAAS,CAC5B,eAAe,CAAE,IAAI,CAAC,KAAK,AAC5B,CAAC,AAED,EAAE,8BAAC,CAAC,AACH,SAAS,CAAE,KAAK,AACjB,CAAC,AACF,CAAC,AAED,MAAM,AAAC,YAAY,KAAK,CAAC,AAAC,CAAC,AAC1B,OAAO,8BAAC,CAAC,AACR,MAAM,CAAE,IAAI,CACZ,KAAK,CAAE,KAAK,CACZ,iBAAiB,CAAE,SAAS,CAC5B,eAAe,CAAE,IAAI,CAAC,IAAI,AAC3B,CAAC,AAED,EAAE,8BAAC,CAAC,AACH,SAAS,CAAE,GAAG,AACf,CAAC,AACF,CAAC,AAED,sBAAO,CAAC,EAAE,eAAC,CAAC,AACX,WAAW,CAAE,IAAI,KAAK,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,IAAI,KAAK,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,IAAI,KAAK,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC;eACvE,IAAI,KAAK,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,IAAI,KAAK,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,IAAI,KAAK,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CACnF,sBAAsB,CAAE,WAAW,AACpC,CAAC,AAED,OAAO,8BAAC,CAAC,AACR,OAAO,CAAE,KAAK,CACd,UAAU,CAAE,MAAM,CAClB,MAAM,CAAE,IAAI,CAAC,CAAC,CACd,MAAM,CAAE,OAAO,AAChB,CAAC,AAED,QAAQ,8BAAC,CAAC,AACT,OAAO,CAAE,KAAK,CACd,KAAK,CAAE,GAAG,CACV,SAAS,CAAE,KAAK,CAChB,MAAM,CAAE,IAAI,CAAC,IAAI,AAClB,CAAC,AAED,aAAa,8BAAC,CAAC,AACd,MAAM,CAAE,GAAG,CAAC,IAAI,CAAC,GAAG,CACjB,UAAU,CAAE,MAAM,AACtB,CAAC"}`
};
var RosterSorter = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let { rosters, users: users2, startersAndReserve, leagueData: leagueData2, players: players2 } = $$props;
  const rosterPositions = leagueData2.roster_positions;
  const numDivisions = leagueData2.settings.divisions || 1;
  const divisions = [];
  for (let i = 0; i < numDivisions; i++) {
    divisions.push({
      name: leagueData2.metadata ? leagueData2.metadata[`division_${i + 1}`] : null,
      rosters: []
    });
  }
  for (const roster of rosters) {
    divisions[roster.settings.division ? roster.settings.division - 1 : 0].rosters.push(roster);
  }
  let expanded = false;
  if ($$props.rosters === void 0 && $$bindings.rosters && rosters !== void 0)
    $$bindings.rosters(rosters);
  if ($$props.users === void 0 && $$bindings.users && users2 !== void 0)
    $$bindings.users(users2);
  if ($$props.startersAndReserve === void 0 && $$bindings.startersAndReserve && startersAndReserve !== void 0)
    $$bindings.startersAndReserve(startersAndReserve);
  if ($$props.leagueData === void 0 && $$bindings.leagueData && leagueData2 !== void 0)
    $$bindings.leagueData(leagueData2);
  if ($$props.players === void 0 && $$bindings.players && players2 !== void 0)
    $$bindings.players(players2);
  $$result.css.add(css$x);
  return `<div class="${"expandButton svelte-1pygyj4"}">${validate_component(Button_1, "Button").$$render($$result, { variant: "outlined" }, {}, {
    default: () => `${validate_component(CommonLabel, "Label").$$render($$result, {}, {}, {
      default: () => `${escape("Expand")} All Benches`
    })}`
  })}</div>

${each(divisions, (division, ix) => `${division.name ? `<div class="${"banner banner-D-" + escape(ix + 1) + " svelte-1pygyj4"}"><h2 class="${"svelte-1pygyj4"}">${escape(division.name)}</h2>
		</div>` : ``}
	<div class="${"division svelte-1pygyj4"}">${each(division.rosters, (roster) => `${validate_component(Roster, "Roster").$$render($$result, {
    division: ix + 1,
    expanded,
    rosterPositions,
    roster,
    users: users2,
    players: players2,
    startersAndReserve
  }, {}, {})}`)}
	</div>`)}`;
});
var css$w = {
  code: ".rosters.svelte-kirxbm{position:relative;z-index:1}",
  map: `{"version":3,"file":"Rosters.svelte","sources":["Rosters.svelte"],"sourcesContent":["<script>\\n\\timport { loadPlayers } from '$lib/utils/helper';\\n\\timport RosterSorter from './RosterSorter.svelte'\\n\\n\\texport let leagueData, rosterData, users, playersInfo;\\n\\n\\tlet players = playersInfo.players;\\n\\n\\tconst refreshPlayers = async () => {\\n\\t\\tconst newPlayersInfo = await loadPlayers(true);\\n\\t\\tplayers = newPlayersInfo.players;\\n\\t}\\n\\n\\tif(playersInfo.stale) {\\n\\t\\trefreshPlayers();\\n\\t}\\n<\/script>\\n\\n<style>\\n\\t.rosters {\\n\\t\\tposition: relative;\\n\\t\\tz-index: 1;\\n\\t}\\n</style>\\n\\n<div class=\\"rosters\\">\\n\\t<RosterSorter rosters={rosterData.rosters} {players} {users} startersAndReserve={rosterData.startersAndReserve} {leagueData} />\\n</div>"],"names":[],"mappings":"AAmBC,QAAQ,cAAC,CAAC,AACT,QAAQ,CAAE,QAAQ,CAClB,OAAO,CAAE,CAAC,AACX,CAAC"}`
};
var Rosters = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let { leagueData: leagueData2, rosterData, users: users2, playersInfo } = $$props;
  let players2 = playersInfo.players;
  const refreshPlayers = async () => {
    const newPlayersInfo = await loadPlayers(true);
    players2 = newPlayersInfo.players;
  };
  if (playersInfo.stale) {
    refreshPlayers();
  }
  if ($$props.leagueData === void 0 && $$bindings.leagueData && leagueData2 !== void 0)
    $$bindings.leagueData(leagueData2);
  if ($$props.rosterData === void 0 && $$bindings.rosterData && rosterData !== void 0)
    $$bindings.rosterData(rosterData);
  if ($$props.users === void 0 && $$bindings.users && users2 !== void 0)
    $$bindings.users(users2);
  if ($$props.playersInfo === void 0 && $$bindings.playersInfo && playersInfo !== void 0)
    $$bindings.playersInfo(playersInfo);
  $$result.css.add(css$w);
  return `<div class="${"rosters svelte-kirxbm"}">${validate_component(RosterSorter, "RosterSorter").$$render($$result, {
    rosters: rosterData.rosters,
    players: players2,
    users: users2,
    startersAndReserve: rosterData.startersAndReserve,
    leagueData: leagueData2
  }, {}, {})}</div>`;
});
var LinearProgress = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let $$restProps = compute_rest_props($$props, [
    "use",
    "class",
    "style",
    "indeterminate",
    "closed",
    "progress",
    "buffer",
    "getElement"
  ]);
  let $closedStore, $$unsubscribe_closedStore;
  forwardEventsBuilder(get_current_component());
  let { use = [] } = $$props;
  let { class: className = "" } = $$props;
  let { style = "" } = $$props;
  let { indeterminate = false } = $$props;
  let { closed = false } = $$props;
  let { progress = 0 } = $$props;
  let { buffer = null } = $$props;
  let element;
  let internalClasses = {};
  let internalAttrs = {};
  let internalStyles = {};
  let bufferBarStyles = {};
  let primaryBarStyles = {};
  let context = getContext("SMUI:linear-progress:context");
  let closedStore = getContext("SMUI:linear-progress:closed");
  $$unsubscribe_closedStore = subscribe(closedStore, (value) => $closedStore = value);
  function getElement() {
    return element;
  }
  if ($$props.use === void 0 && $$bindings.use && use !== void 0)
    $$bindings.use(use);
  if ($$props.class === void 0 && $$bindings.class && className !== void 0)
    $$bindings.class(className);
  if ($$props.style === void 0 && $$bindings.style && style !== void 0)
    $$bindings.style(style);
  if ($$props.indeterminate === void 0 && $$bindings.indeterminate && indeterminate !== void 0)
    $$bindings.indeterminate(indeterminate);
  if ($$props.closed === void 0 && $$bindings.closed && closed !== void 0)
    $$bindings.closed(closed);
  if ($$props.progress === void 0 && $$bindings.progress && progress !== void 0)
    $$bindings.progress(progress);
  if ($$props.buffer === void 0 && $$bindings.buffer && buffer !== void 0)
    $$bindings.buffer(buffer);
  if ($$props.getElement === void 0 && $$bindings.getElement && getElement !== void 0)
    $$bindings.getElement(getElement);
  {
    if (closedStore) {
      set_store_value(closedStore, $closedStore = closed, $closedStore);
    }
  }
  $$unsubscribe_closedStore();
  return `<div${spread([
    {
      class: escape_attribute_value(classMap({
        [className]: true,
        "mdc-linear-progress": true,
        "mdc-linear-progress--indeterminate": indeterminate,
        "mdc-linear-progress--closed": closed,
        "mdc-data-table__linear-progress": context === "data-table",
        ...internalClasses
      }))
    },
    {
      style: escape_attribute_value(Object.entries(internalStyles).map(([name, value]) => `${name}: ${value};`).concat([style]).join(" "))
    },
    { role: "progressbar" },
    { "aria-valuemin": "0" },
    { "aria-valuemax": "1" },
    {
      "aria-valuenow": escape_attribute_value(indeterminate ? null : `${progress.toLocaleString()}`)
    },
    escape_object(internalAttrs),
    escape_object($$restProps)
  ])}${add_attribute("this", element, 0)}><div class="${"mdc-linear-progress__buffer"}"><div class="${"mdc-linear-progress__buffer-bar"}"${add_attribute("style", Object.entries(bufferBarStyles).map(([name, value]) => `${name}: ${value};`).join(" "), 0)}></div>
    <div class="${"mdc-linear-progress__buffer-dots"}"></div></div>
  <div class="${"mdc-linear-progress__bar mdc-linear-progress__primary-bar"}"${add_attribute("style", Object.entries(primaryBarStyles).map(([name, value]) => `${name}: ${value};`).join(" "), 0)}><span class="${"mdc-linear-progress__bar-inner"}"></span></div>
  <div class="${"mdc-linear-progress__bar mdc-linear-progress__secondary-bar"}"><span class="${"mdc-linear-progress__bar-inner"}"></span></div>
</div>`;
});
var css$v = {
  code: ".move{text-align:center}.originalOwner{color:#aaa;font-style:italic}.trade{background-color:var(--fff)}.Added{background-color:var(--waiverAdd)}.Dropped{background-color:var(--waiverDrop)}.lineParent.svelte-7kknhc{position:absolute;overflow:visible;width:1px;height:1px;pointer-events:none}.line.svelte-7kknhc{position:absolute;z-index:2}.playerAvatar.svelte-7kknhc{display:inline-block;vertical-align:middle;height:35px;width:35px;background-position:center;border-radius:100%;background-repeat:no-repeat;background-size:auto 35px}.name.svelte-7kknhc{white-space:normal}.pos.svelte-7kknhc{display:inline-flex;align-items:center;justify-content:center;border-radius:8px;width:32px;height:24px}.QB{background-color:var(--QB)}.WR{background-color:var(--WR)}.RB{background-color:var(--RB)}.TE{background-color:var(--TE)}.FLEX{background:linear-gradient(to right, var(--WR), var(--WR) 33.33%, var(--RB) 33.33%, var(--RB) 66.66%, var(--TE) 66.66%)}.WRRB{background:linear-gradient(to right, var(--WR), var(--WR) 50%, var(--RB) 50%)}.K{background-color:var(--K)}.DEF{background-color:var(--DEF)}.indicator{vertical-align:middle}.nameHolder.svelte-7kknhc{margin:6px 0;display:inline-block}.destination.svelte-7kknhc{display:block;margin:0 auto;width:0px;height:2px}",
  map: '{"version":3,"file":"TransactionMove.svelte","sources":["TransactionMove.svelte"],"sourcesContent":["<script>\\n\\timport {cleanName} from \'$lib/utils/helper\';\\n  \\timport { Row, Cell } from \'@smui/data-table\';\\n\\timport { Icon } from \'@smui/tab\';\\n\\n\\texport let move, type, masterOffset, currentManagers, players;\\n\\t\\n\\tlet trade = false;\\n\\t\\n\\tif(type == \\"trade\\") {\\n\\t\\ttrade = true;\\n\\t}\\n\\n\\tconst getAvatar = (pos, player) => {\\n\\t\\tif(pos == \'DEF\') {\\n\\t\\t\\treturn `background-image: url(https://sleepercdn.com/images/team_logos/nfl/${player.toLowerCase()}.png)`;\\n\\t\\t}\\n\\t\\treturn `background-image: url(https://sleepercdn.com/content/nfl/players/thumb/${player}.jpg), url(https://sleepercdn.com/images/v2/icons/player_default.webp)`;\\n\\t}\\n\\n\\tlet origin, destination;\\n\\n\\tconst offset = 18;\\n\\tconst originOffset = 10;\\n\\n\\n\\n\\tlet x1, x2;\\n    let innerWidth;\\n\\n    const resize = (width) => {\\n\\t\\tx1 = origin?.getBoundingClientRect() && destination?.getBoundingClientRect() ? (destination?.getBoundingClientRect().left > origin?.getBoundingClientRect().left ? origin?.getBoundingClientRect().right + originOffset - masterOffset : origin?.getBoundingClientRect().left - originOffset - masterOffset)  : 0;\\n\\t\\tx2 = origin?.getBoundingClientRect() && destination?.getBoundingClientRect() ? (destination?.getBoundingClientRect().left > origin?.getBoundingClientRect().left ? destination?.getBoundingClientRect().left - offset - masterOffset : destination?.getBoundingClientRect().right + offset - masterOffset)  : 0;\\n    }\\n\\n    $: resize(innerWidth);\\n    $: resize(masterOffset);\\n\\n\\tconst y = -28;\\n<\/script>\\n\\n<svelte:window bind:innerWidth={innerWidth} />\\n\\n<style>\\n\\t:global(.move) {\\n\\t\\ttext-align: center;\\n\\t}\\n\\n\\t:global(.originalOwner) {\\n\\t\\tcolor: #aaa;\\n\\t\\tfont-style: italic;\\n\\t}\\n\\n\\t:global(.trade) {\\n\\t\\tbackground-color: var(--fff);\\n\\t}\\n\\n\\t:global(.Added) {\\n\\t\\tbackground-color: var(--waiverAdd);\\n\\t}\\n\\n\\t:global(.Dropped) {\\n\\t\\tbackground-color: var(--waiverDrop);\\n\\t}\\n\\n\\t.lineParent {\\n\\t\\tposition: absolute;\\n\\t\\toverflow: visible;\\n\\t\\twidth: 1px;\\n\\t\\theight: 1px;\\n\\t\\tpointer-events: none;\\n\\t}\\n\\n\\t.line{\\n\\t\\tposition: absolute;\\n\\t\\tz-index: 2;\\n\\t}\\n\\n\\t.playerAvatar {\\n\\t\\tdisplay: inline-block;\\n\\t\\tvertical-align: middle;\\n\\t\\theight: 35px;\\n\\t\\twidth: 35px;\\n\\t\\tbackground-position: center;\\n\\t\\tborder-radius: 100%;\\n\\t\\tbackground-repeat: no-repeat;\\n\\t\\tbackground-size: auto 35px;\\n\\t}\\n\\n\\t.name {\\n\\t\\twhite-space: normal;\\n\\t}\\n\\n\\t.pos {\\n\\t\\tdisplay: inline-flex;\\n\\t\\talign-items: center;\\n\\t\\tjustify-content: center;\\n\\t\\tborder-radius: 8px;\\n\\t\\twidth: 32px;\\n\\t\\theight: 24px;\\n\\t}\\n\\n\\t:global(.QB) {\\n\\t\\tbackground-color: var(--QB);\\n\\t}\\n\\n\\t:global(.WR) {\\n\\t\\tbackground-color: var(--WR);\\n\\t}\\n\\n\\t:global(.RB) {\\n\\t\\tbackground-color: var(--RB);\\n\\t}\\n\\n\\t:global(.TE) {\\n\\t\\tbackground-color: var(--TE);\\n\\t}\\n\\n\\t:global(.FLEX) {\\n\\t\\tbackground: linear-gradient(to right, var(--WR), var(--WR) 33.33%, var(--RB) 33.33%, var(--RB) 66.66%, var(--TE) 66.66%);\\n\\t}\\n\\n\\t:global(.WRRB) {\\n\\t\\tbackground: linear-gradient(to right, var(--WR), var(--WR) 50%, var(--RB) 50%);\\n\\t}\\n\\n\\t:global(.K) {\\n\\t\\tbackground-color: var(--K);\\n\\t}\\n\\n\\t:global(.DEF) {\\n\\t\\tbackground-color: var(--DEF);\\n\\t}\\n\\n\\t:global(.indicator) {\\n\\t\\tvertical-align: middle;\\n\\t}\\n\\n\\t.nameHolder {\\n\\t\\tmargin: 6px 0;\\n    \\tdisplay: inline-block;\\n\\t}\\n\\n\\t.destination {\\n\\t\\tdisplay: block;\\n\\t\\tmargin: 0 auto;\\n\\t\\twidth: 0px;\\n\\t\\theight: 2px;\\n\\t}\\n</style>\\n\\n<Row>\\n\\t{#each move as cell}\\n\\t\\t{#if cell && cell.player}\\n\\t\\t\\t<Cell class=\\"move {cell.type}\\">\\n\\t\\t\\t\\t<span class=\\"nameHolder\\">\\n\\t\\t\\t\\t\\t{#if cell.type == \\"Added\\"}\\n\\t\\t\\t\\t\\t\\t<Icon class=\\"indicator material-icons\\">arrow_drop_up</Icon>\\n\\t\\t\\t\\t\\t{:else if cell.type == \\"Dropped\\"}\\n\\t\\t\\t\\t\\t\\t<Icon class=\\"indicator material-icons\\">arrow_drop_down</Icon>\\n\\t\\t\\t\\t\\t{/if}\\n\\t\\t\\t\\t\\t{cell.type == \\"Added\\" || cell.type == \\"Dropped\\" ?  cell.type + `${cell.bid ? \\" \\" + cell.bid + \\"$\\" : \\"\\"}` : \\"\\"}\\n\\t\\t\\t\\t\\t{#if cell.type == \\"Added\\"}\\n\\t\\t\\t\\t\\t\\t<Icon class=\\"indicator material-icons\\">arrow_drop_up</Icon><br />\\n\\t\\t\\t\\t\\t{:else if cell.type == \\"Dropped\\"}\\n\\t\\t\\t\\t\\t\\t<Icon class=\\"indicator material-icons\\">arrow_drop_down</Icon><br />\\n\\t\\t\\t\\t\\t{/if}\\n\\t\\t\\t\\t\\t<span class=\\"pos {players[cell.player].pos}\\">{players[cell.player].pos}</span> \\n\\t\\t\\t\\t\\t<div class=\\"playerAvatar\\" style=\\"{getAvatar(players[cell.player].pos, cell.player)}\\" />\\n\\t\\t\\t\\t\\t<br />\\n\\t\\t\\t\\t\\t<span class=\\"name\\" bind:this={origin}>{`${players[cell.player].fn} ${players[cell.player].ln}`}</span>\\n\\t\\t\\t\\t</span>\\n\\t\\t\\t</Cell>\\n\\t\\t{:else if cell && cell.pick}\\n\\t\\t\\t<Cell class=\\"move {cell.type}\\"><span bind:this={origin} class=\\"name\\">{cell.pick.season} Round {cell.pick.round}{@html cell.pick.original_owner ?  `<br /><span class=\\"originalOwner\\">(${cell.pick.original_owner.original && cleanName(cell.pick.original_owner.original) != cleanName(currentManagers[cell.pick.original_owner.current].name) ? `${cell.pick.original_owner.original} [` : \'\'}${currentManagers[cell.pick.original_owner.current].name}${cell.pick.original_owner.original && cleanName(cell.pick.original_owner.original) != cleanName(currentManagers[cell.pick.original_owner.current].name)  ? \']\' : \'\'})</span>` : \\"\\"}</span></Cell>\\n\\t\\t{:else if cell && cell.budget}\\n\\t\\t\\t<Cell class=\\"move {cell.type}\\"><span bind:this={origin} class=\\"name\\">{cell.budget.amount}</span></Cell>\\n\\t\\t{:else if cell && cell == \\"destination\\"}\\n\\t\\t\\t<Cell class=\\"move trade\\"><span class=\\"destination\\" bind:this={destination} /></Cell>\\n\\t\\t{:else}\\n\\t\\t\\t<Cell class=\\"trade\\"/>\\n\\t\\t{/if}\\n\\t{/each}\\n</Row>\\n\\n{#if trade}\\n\\t<svg class=\\"lineParent\\">\\n\\t\\t<defs>\\n\\t\\t  <marker id=\\"arrowhead\\" markerWidth=\\"10\\" markerHeight=\\"7\\" \\n\\t\\t  refX=\\"0\\" refY=\\"2.5\\" orient=\\"auto\\" fill=\\"#ccc\\">\\n\\t\\t\\t<polygon points=\\"0 0, 10 2.5, 0 5\\" />\\n\\t\\t  </marker>\\n\\t\\t</defs>\\n\\t\\t<line stroke-width=\\"2px\\" stroke=\\"#ccc\\"  x1=\\"{x1}\\" y1=\\"{y}\\" x2=\\"{x2}\\" y2=\\"{y}\\" class=\\"line\\" marker-end=\\"url(#arrowhead)\\"/>\\n\\t</svg>\\n{/if}\\n\\n\\n\\n\\n\\n\\n"],"names":[],"mappings":"AA4CS,KAAK,AAAE,CAAC,AACf,UAAU,CAAE,MAAM,AACnB,CAAC,AAEO,cAAc,AAAE,CAAC,AACxB,KAAK,CAAE,IAAI,CACX,UAAU,CAAE,MAAM,AACnB,CAAC,AAEO,MAAM,AAAE,CAAC,AAChB,gBAAgB,CAAE,IAAI,KAAK,CAAC,AAC7B,CAAC,AAEO,MAAM,AAAE,CAAC,AAChB,gBAAgB,CAAE,IAAI,WAAW,CAAC,AACnC,CAAC,AAEO,QAAQ,AAAE,CAAC,AAClB,gBAAgB,CAAE,IAAI,YAAY,CAAC,AACpC,CAAC,AAED,WAAW,cAAC,CAAC,AACZ,QAAQ,CAAE,QAAQ,CAClB,QAAQ,CAAE,OAAO,CACjB,KAAK,CAAE,GAAG,CACV,MAAM,CAAE,GAAG,CACX,cAAc,CAAE,IAAI,AACrB,CAAC,AAED,mBAAK,CAAC,AACL,QAAQ,CAAE,QAAQ,CAClB,OAAO,CAAE,CAAC,AACX,CAAC,AAED,aAAa,cAAC,CAAC,AACd,OAAO,CAAE,YAAY,CACrB,cAAc,CAAE,MAAM,CACtB,MAAM,CAAE,IAAI,CACZ,KAAK,CAAE,IAAI,CACX,mBAAmB,CAAE,MAAM,CAC3B,aAAa,CAAE,IAAI,CACnB,iBAAiB,CAAE,SAAS,CAC5B,eAAe,CAAE,IAAI,CAAC,IAAI,AAC3B,CAAC,AAED,KAAK,cAAC,CAAC,AACN,WAAW,CAAE,MAAM,AACpB,CAAC,AAED,IAAI,cAAC,CAAC,AACL,OAAO,CAAE,WAAW,CACpB,WAAW,CAAE,MAAM,CACnB,eAAe,CAAE,MAAM,CACvB,aAAa,CAAE,GAAG,CAClB,KAAK,CAAE,IAAI,CACX,MAAM,CAAE,IAAI,AACb,CAAC,AAEO,GAAG,AAAE,CAAC,AACb,gBAAgB,CAAE,IAAI,IAAI,CAAC,AAC5B,CAAC,AAEO,GAAG,AAAE,CAAC,AACb,gBAAgB,CAAE,IAAI,IAAI,CAAC,AAC5B,CAAC,AAEO,GAAG,AAAE,CAAC,AACb,gBAAgB,CAAE,IAAI,IAAI,CAAC,AAC5B,CAAC,AAEO,GAAG,AAAE,CAAC,AACb,gBAAgB,CAAE,IAAI,IAAI,CAAC,AAC5B,CAAC,AAEO,KAAK,AAAE,CAAC,AACf,UAAU,CAAE,gBAAgB,EAAE,CAAC,KAAK,CAAC,CAAC,IAAI,IAAI,CAAC,CAAC,CAAC,IAAI,IAAI,CAAC,CAAC,MAAM,CAAC,CAAC,IAAI,IAAI,CAAC,CAAC,MAAM,CAAC,CAAC,IAAI,IAAI,CAAC,CAAC,MAAM,CAAC,CAAC,IAAI,IAAI,CAAC,CAAC,MAAM,CAAC,AACzH,CAAC,AAEO,KAAK,AAAE,CAAC,AACf,UAAU,CAAE,gBAAgB,EAAE,CAAC,KAAK,CAAC,CAAC,IAAI,IAAI,CAAC,CAAC,CAAC,IAAI,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC,IAAI,IAAI,CAAC,CAAC,GAAG,CAAC,AAC/E,CAAC,AAEO,EAAE,AAAE,CAAC,AACZ,gBAAgB,CAAE,IAAI,GAAG,CAAC,AAC3B,CAAC,AAEO,IAAI,AAAE,CAAC,AACd,gBAAgB,CAAE,IAAI,KAAK,CAAC,AAC7B,CAAC,AAEO,UAAU,AAAE,CAAC,AACpB,cAAc,CAAE,MAAM,AACvB,CAAC,AAED,WAAW,cAAC,CAAC,AACZ,MAAM,CAAE,GAAG,CAAC,CAAC,CACV,OAAO,CAAE,YAAY,AACzB,CAAC,AAED,YAAY,cAAC,CAAC,AACb,OAAO,CAAE,KAAK,CACd,MAAM,CAAE,CAAC,CAAC,IAAI,CACd,KAAK,CAAE,GAAG,CACV,MAAM,CAAE,GAAG,AACZ,CAAC"}'
};
var offset = 18;
var originOffset = 10;
var TransactionMove = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let { move, type, masterOffset, currentManagers, players: players2 } = $$props;
  let trade = false;
  if (type == "trade") {
    trade = true;
  }
  const getAvatar = (pos, player) => {
    if (pos == "DEF") {
      return `background-image: url(https://sleepercdn.com/images/team_logos/nfl/${player.toLowerCase()}.png)`;
    }
    return `background-image: url(https://sleepercdn.com/content/nfl/players/thumb/${player}.jpg), url(https://sleepercdn.com/images/v2/icons/player_default.webp)`;
  };
  let origin, destination;
  let x1, x2;
  const resize = (width) => {
    x1 = (origin == null ? void 0 : origin.getBoundingClientRect()) && (destination == null ? void 0 : destination.getBoundingClientRect()) ? (destination == null ? void 0 : destination.getBoundingClientRect().left) > (origin == null ? void 0 : origin.getBoundingClientRect().left) ? (origin == null ? void 0 : origin.getBoundingClientRect().right) + originOffset - masterOffset : (origin == null ? void 0 : origin.getBoundingClientRect().left) - originOffset - masterOffset : 0;
    x2 = (origin == null ? void 0 : origin.getBoundingClientRect()) && (destination == null ? void 0 : destination.getBoundingClientRect()) ? (destination == null ? void 0 : destination.getBoundingClientRect().left) > (origin == null ? void 0 : origin.getBoundingClientRect().left) ? (destination == null ? void 0 : destination.getBoundingClientRect().left) - offset - masterOffset : (destination == null ? void 0 : destination.getBoundingClientRect().right) + offset - masterOffset : 0;
  };
  const y = -28;
  if ($$props.move === void 0 && $$bindings.move && move !== void 0)
    $$bindings.move(move);
  if ($$props.type === void 0 && $$bindings.type && type !== void 0)
    $$bindings.type(type);
  if ($$props.masterOffset === void 0 && $$bindings.masterOffset && masterOffset !== void 0)
    $$bindings.masterOffset(masterOffset);
  if ($$props.currentManagers === void 0 && $$bindings.currentManagers && currentManagers !== void 0)
    $$bindings.currentManagers(currentManagers);
  if ($$props.players === void 0 && $$bindings.players && players2 !== void 0)
    $$bindings.players(players2);
  $$result.css.add(css$v);
  {
    resize();
  }
  {
    resize();
  }
  return `



${validate_component(Row, "Row").$$render($$result, {}, {}, {
    default: () => `${each(move, (cell) => `${cell && cell.player ? `${validate_component(Cell, "Cell").$$render($$result, { class: "move " + cell.type }, {}, {
      default: () => `<span class="${"nameHolder svelte-7kknhc"}">${cell.type == "Added" ? `${validate_component(CommonIcon, "Icon").$$render($$result, { class: "indicator material-icons" }, {}, { default: () => `arrow_drop_up` })}` : `${cell.type == "Dropped" ? `${validate_component(CommonIcon, "Icon").$$render($$result, { class: "indicator material-icons" }, {}, { default: () => `arrow_drop_down` })}` : ``}`}
					${escape(cell.type == "Added" || cell.type == "Dropped" ? cell.type + `${cell.bid ? " " + cell.bid + "$" : ""}` : "")}
					${cell.type == "Added" ? `${validate_component(CommonIcon, "Icon").$$render($$result, { class: "indicator material-icons" }, {}, { default: () => `arrow_drop_up` })}<br>` : `${cell.type == "Dropped" ? `${validate_component(CommonIcon, "Icon").$$render($$result, { class: "indicator material-icons" }, {}, { default: () => `arrow_drop_down` })}<br>` : ``}`}
					<span class="${"pos " + escape(players2[cell.player].pos) + " svelte-7kknhc"}">${escape(players2[cell.player].pos)}</span> 
					<div class="${"playerAvatar svelte-7kknhc"}"${add_attribute("style", getAvatar(players2[cell.player].pos, cell.player), 0)}></div>
					<br>
					<span class="${"name svelte-7kknhc"}"${add_attribute("this", origin, 0)}>${escape(`${players2[cell.player].fn} ${players2[cell.player].ln}`)}</span></span>
			`
    })}` : `${cell && cell.pick ? `${validate_component(Cell, "Cell").$$render($$result, { class: "move " + cell.type }, {}, {
      default: () => `<span class="${"name svelte-7kknhc"}"${add_attribute("this", origin, 0)}>${escape(cell.pick.season)} Round ${escape(cell.pick.round)}<!-- HTML_TAG_START -->${cell.pick.original_owner ? `<br /><span class="originalOwner">(${cell.pick.original_owner.original && cleanName(cell.pick.original_owner.original) != cleanName(currentManagers[cell.pick.original_owner.current].name) ? `${cell.pick.original_owner.original} [` : ""}${currentManagers[cell.pick.original_owner.current].name}${cell.pick.original_owner.original && cleanName(cell.pick.original_owner.original) != cleanName(currentManagers[cell.pick.original_owner.current].name) ? "]" : ""})</span>` : ""}<!-- HTML_TAG_END --></span>`
    })}` : `${cell && cell.budget ? `${validate_component(Cell, "Cell").$$render($$result, { class: "move " + cell.type }, {}, {
      default: () => `<span class="${"name svelte-7kknhc"}"${add_attribute("this", origin, 0)}>${escape(cell.budget.amount)}</span>`
    })}` : `${cell && cell == "destination" ? `${validate_component(Cell, "Cell").$$render($$result, { class: "move trade" }, {}, {
      default: () => `<span class="${"destination svelte-7kknhc"}"${add_attribute("this", destination, 0)}></span>`
    })}` : `${validate_component(Cell, "Cell").$$render($$result, { class: "trade" }, {}, {})}`}`}`}`}`)}`
  })}

${trade ? `<svg class="${"lineParent svelte-7kknhc"}"><defs><marker id="${"arrowhead"}" markerWidth="${"10"}" markerHeight="${"7"}" refX="${"0"}" refY="${"2.5"}" orient="${"auto"}" fill="${"#ccc"}"><polygon points="${"0 0, 10 2.5, 0 5"}"></polygon></marker></defs><line stroke-width="${"2px"}" stroke="${"#ccc"}"${add_attribute("x1", x1, 0)}${add_attribute("y1", y, 0)}${add_attribute("x2", x2, 0)}${add_attribute("y2", y, 0)} class="${"line svelte-7kknhc"}" marker-end="${"url(#arrowhead)"}"></line></svg>` : ``}`;
});
var css$u = {
  code: ".transaction{display:block;width:100%;margin:15px auto;border:1px solid var(--ccc);box-shadow:0px 3px 3px -2px var(--boxShadowOne), 0px 3px 4px 0px var(--boxShadowTwo), 0px 1px 8px 0px var(--boxShadowThree)}.transaction table{table-layout:fixed !important;width:100%}.transactTeam{text-align:center;padding:5px 0;background-color:var(--transactHeader)}.transact-date{text-align:center;padding:5px 0;background-color:var(--transactHeader);color:#888;font-style:italic}.avatar.svelte-1kfy7jk{vertical-align:middle;border-radius:50%;height:25px;width:25px;margin:0;border:0.25px solid #777}.currentOwner.svelte-1kfy7jk{display:block;font-style:italic;font-size:0.8em;color:#aaa}.clickable.svelte-1kfy7jk{cursor:pointer}",
  map: `{"version":3,"file":"Transaction.svelte","sources":["Transaction.svelte"],"sourcesContent":["<script>\\n\\timport {cleanName, gotoManager} from '$lib/utils/helper';\\n  \\timport DataTable, { Head, Body, Row, Cell } from '@smui/data-table';\\n\\timport TransactionMove from './TransactionMove.svelte';\\n\\n\\texport let transaction, masterOffset, currentManagers, players;\\n<\/script>\\n\\n<style>\\n\\t:global(.transaction) {\\n\\t\\tdisplay: block;\\n\\t\\twidth: 100%;\\n\\t\\tmargin: 15px auto;\\n\\t\\tborder: 1px solid var(--ccc);\\n\\t\\tbox-shadow: 0px 3px 3px -2px var(--boxShadowOne), 0px 3px 4px 0px var(--boxShadowTwo), 0px 1px 8px 0px var(--boxShadowThree);\\n\\t}\\n\\n\\t:global(.transaction table) {\\n\\t\\ttable-layout:fixed !important;\\n\\t\\twidth: 100%;\\n\\t}\\n\\n\\t:global(.transactTeam) {\\n\\t\\ttext-align: center;\\n\\t\\tpadding: 5px 0;\\n\\t\\tbackground-color: var(--transactHeader);\\n\\t}\\n\\n\\t:global(.transact-date) {\\n\\t\\ttext-align: center;\\n\\t\\tpadding: 5px 0;\\n\\t\\tbackground-color: var(--transactHeader);\\n\\t\\tcolor: #888;\\n\\t\\tfont-style: italic;\\n\\t}\\n\\n\\t.avatar {\\n\\t\\tvertical-align: middle;\\n\\t\\tborder-radius: 50%;\\n\\t\\theight: 25px;\\n\\t\\twidth: 25px;\\n\\t\\tmargin: 0;\\n\\t\\tborder: 0.25px solid #777;\\n\\t}\\n\\n\\t.currentOwner {\\n\\t\\tdisplay: block;\\n\\t\\tfont-style: italic;\\n\\t\\tfont-size: 0.8em;\\n\\t\\tcolor: #aaa;\\n\\t}\\n\\n\\t.clickable {\\n\\t\\tcursor: pointer;\\n\\t}\\n</style>\\n\\n<DataTable class=\\"transaction\\">\\n\\t<Head class=\\"teams\\">\\n\\t\\t<Row>\\n\\t\\t\\t{#each transaction.rosters as owner, ix}\\n\\t\\t\\t\\t<Cell class=\\"transactTeam\\">\\n\\t\\t\\t\\t\\t{#if transaction.previousOwners && cleanName(transaction.previousOwners[ix].name) != cleanName(currentManagers[owner].name)}\\n\\t\\t\\t\\t\\t\\t<img class=\\"avatar clickable\\" on:click={() => gotoManager(owner)} src=\\"{transaction.previousOwners[ix].avatar}\\" alt=\\"{transaction.previousOwners[ix].name} avatar\\"/>\\n\\t\\t\\t\\t\\t\\t<br /><span class=\\"clickable\\" on:click={() => gotoManager(owner)}>{transaction.previousOwners[ix].name}</span>\\n\\t\\t\\t\\t\\t\\t<span class=\\"currentOwner\\">({currentManagers[owner].name})</span>\\n\\t\\t\\t\\t\\t{:else}\\n\\t\\t\\t\\t\\t\\t<img class=\\"avatar clickable\\" on:click={() => gotoManager(owner)} src=\\"{currentManagers[owner].avatar}\\" alt=\\"{currentManagers[owner].name} avatar\\"/>\\n\\t\\t\\t\\t\\t\\t<br /><span class=\\"clickable\\" on:click={() => gotoManager(owner)}>{currentManagers[owner].name}</span>\\n\\t\\t\\t\\t\\t{/if}\\n\\t\\t\\t\\t</Cell>\\n\\t\\t\\t{/each}\\n\\t\\t</Row>\\n\\t</Head>\\n\\t<Body class=\\"moves\\">\\n\\t\\t{#each transaction.moves as move}\\n\\t\\t\\t<TransactionMove {players} {move} type={transaction.type} {masterOffset} {currentManagers} />\\n\\t\\t{/each}\\n\\t\\t<Row>\\n\\t\\t\\t<Cell class=\\"transact-date\\" colspan={transaction.rosters.length}>{transaction.date}</Cell>\\n\\t\\t</Row>\\n\\t</Body>\\n</DataTable>\\n\\n\\n\\n\\n\\n"],"names":[],"mappings":"AASS,YAAY,AAAE,CAAC,AACtB,OAAO,CAAE,KAAK,CACd,KAAK,CAAE,IAAI,CACX,MAAM,CAAE,IAAI,CAAC,IAAI,CACjB,MAAM,CAAE,GAAG,CAAC,KAAK,CAAC,IAAI,KAAK,CAAC,CAC5B,UAAU,CAAE,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI,CAAC,IAAI,cAAc,CAAC,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI,cAAc,CAAC,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI,gBAAgB,CAAC,AAC7H,CAAC,AAEO,kBAAkB,AAAE,CAAC,AAC5B,aAAa,KAAK,CAAC,UAAU,CAC7B,KAAK,CAAE,IAAI,AACZ,CAAC,AAEO,aAAa,AAAE,CAAC,AACvB,UAAU,CAAE,MAAM,CAClB,OAAO,CAAE,GAAG,CAAC,CAAC,CACd,gBAAgB,CAAE,IAAI,gBAAgB,CAAC,AACxC,CAAC,AAEO,cAAc,AAAE,CAAC,AACxB,UAAU,CAAE,MAAM,CAClB,OAAO,CAAE,GAAG,CAAC,CAAC,CACd,gBAAgB,CAAE,IAAI,gBAAgB,CAAC,CACvC,KAAK,CAAE,IAAI,CACX,UAAU,CAAE,MAAM,AACnB,CAAC,AAED,OAAO,eAAC,CAAC,AACR,cAAc,CAAE,MAAM,CACtB,aAAa,CAAE,GAAG,CAClB,MAAM,CAAE,IAAI,CACZ,KAAK,CAAE,IAAI,CACX,MAAM,CAAE,CAAC,CACT,MAAM,CAAE,MAAM,CAAC,KAAK,CAAC,IAAI,AAC1B,CAAC,AAED,aAAa,eAAC,CAAC,AACd,OAAO,CAAE,KAAK,CACd,UAAU,CAAE,MAAM,CAClB,SAAS,CAAE,KAAK,CAChB,KAAK,CAAE,IAAI,AACZ,CAAC,AAED,UAAU,eAAC,CAAC,AACX,MAAM,CAAE,OAAO,AAChB,CAAC"}`
};
var Transaction = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let { transaction, masterOffset, currentManagers, players: players2 } = $$props;
  if ($$props.transaction === void 0 && $$bindings.transaction && transaction !== void 0)
    $$bindings.transaction(transaction);
  if ($$props.masterOffset === void 0 && $$bindings.masterOffset && masterOffset !== void 0)
    $$bindings.masterOffset(masterOffset);
  if ($$props.currentManagers === void 0 && $$bindings.currentManagers && currentManagers !== void 0)
    $$bindings.currentManagers(currentManagers);
  if ($$props.players === void 0 && $$bindings.players && players2 !== void 0)
    $$bindings.players(players2);
  $$result.css.add(css$u);
  return `${validate_component(DataTable, "DataTable").$$render($$result, { class: "transaction" }, {}, {
    default: () => `${validate_component(Head, "Head").$$render($$result, { class: "teams" }, {}, {
      default: () => `${validate_component(Row, "Row").$$render($$result, {}, {}, {
        default: () => `${each(transaction.rosters, (owner, ix) => `${validate_component(Cell, "Cell").$$render($$result, { class: "transactTeam" }, {}, {
          default: () => `${transaction.previousOwners && cleanName(transaction.previousOwners[ix].name) != cleanName(currentManagers[owner].name) ? `<img class="${"avatar clickable svelte-1kfy7jk"}"${add_attribute("src", transaction.previousOwners[ix].avatar, 0)} alt="${escape(transaction.previousOwners[ix].name) + " avatar"}">
						<br><span class="${"clickable svelte-1kfy7jk"}">${escape(transaction.previousOwners[ix].name)}</span>
						<span class="${"currentOwner svelte-1kfy7jk"}">(${escape(currentManagers[owner].name)})</span>` : `<img class="${"avatar clickable svelte-1kfy7jk"}"${add_attribute("src", currentManagers[owner].avatar, 0)} alt="${escape(currentManagers[owner].name) + " avatar"}">
						<br><span class="${"clickable svelte-1kfy7jk"}">${escape(currentManagers[owner].name)}</span>`}
				`
        })}`)}`
      })}`
    })}
	${validate_component(Body2, "Body").$$render($$result, { class: "moves" }, {}, {
      default: () => `${each(transaction.moves, (move) => `${validate_component(TransactionMove, "TransactionMove").$$render($$result, {
        players: players2,
        move,
        type: transaction.type,
        masterOffset,
        currentManagers
      }, {}, {})}`)}
		${validate_component(Row, "Row").$$render($$result, {}, {}, {
        default: () => `${validate_component(Cell, "Cell").$$render($$result, {
          class: "transact-date",
          colspan: transaction.rosters.length
        }, {}, {
          default: () => `${escape(transaction.date)}`
        })}`
      })}`
    })}`
  })}`;
});
var css$t = {
  code: ".transactions.svelte-16lkrlv{position:relative;width:100%;z-index:1}p.svelte-16lkrlv{text-align:center}h5.svelte-16lkrlv{text-align:center;margin:10px auto 16px}.link.svelte-16lkrlv{cursor:pointer;color:#888;padding:10px 20px;margin-bottom:10px}.link.svelte-16lkrlv:hover{color:#00316b}.nothingYet.svelte-16lkrlv{margin:5em 0}",
  map: `{"version":3,"file":"Transactions.svelte","sources":["Transactions.svelte"],"sourcesContent":["<script>\\n\\timport { goto } from '$app/navigation';\\n\\timport { getLeagueTransactions, loadPlayers, waitForAll } from '$lib/utils/helper';\\n\\timport LinearProgress from '@smui/linear-progress';\\n\\timport { onMount } from 'svelte';\\n\\timport Transaction from './Transaction.svelte';\\n\\n\\texport let masterOffset = 0;\\n\\n\\tlet loading = true;\\n\\tlet players;\\n\\tlet transactions, currentManagers;\\n\\n\\tonMount(async () => {\\n\\t\\tconst [transactionsData, playersData] = await waitForAll(getLeagueTransactions(true),loadPlayers());\\n\\t\\tplayers = playersData.players;\\n\\t\\ttransactions = transactionsData.transactions;\\n\\t\\tcurrentManagers = transactionsData.currentManagers;\\n\\t\\tloading = false;\\n\\n\\t\\tif(transactionsData.stale) {\\n\\t\\t\\tconst newTransactions = await getLeagueTransactions(true, true);\\n\\t\\t\\ttransactions = newTransactions.transactions;\\n\\t\\t\\tcurrentManagers = newTransactions.currentManagers;\\n\\t\\t}\\n\\n\\t\\tif(playersData.stale) {\\n\\t\\t\\tconst newPlayersData = await loadPlayers(true);\\n\\t\\t\\tplayers = newPlayersData.players;\\n\\t\\t}\\n\\t})\\n<\/script>\\n\\n<style>\\n\\t.transactions {\\n\\t\\tposition: relative;\\n\\t\\twidth: 100%;\\n\\t\\tz-index: 1;\\n\\t}\\n\\n\\tp {\\n\\t\\ttext-align: center;\\n\\t}\\n\\n\\th5 {\\n\\t\\ttext-align: center;\\n\\t\\tmargin: 10px auto 16px;\\n\\t}\\n\\n\\t.link {\\n\\t\\tcursor: pointer;\\n\\t\\tcolor: #888;\\n\\t\\tpadding: 10px 20px;\\n\\t\\tmargin-bottom: 10px;\\n\\t}\\n\\n\\t.link:hover {\\n\\t\\tcolor: #00316b;\\n\\t}\\n\\n\\t.nothingYet {\\n\\t\\tmargin: 5em 0;\\n\\t}\\n</style>\\n\\n<div class=\\"transactions\\">\\n\\t{#if loading}\\n\\t\\t<p>Loading league transactions...</p>\\n\\t\\t<LinearProgress indeterminate />\\n\\t{:else}\\n\\t\\t<!-- waiver -->\\n\\t\\t{#if transactions.waivers.length}\\n\\t\\t\\t<h5>Recent Waiver Moves</h5>\\n\\t\\t\\t{#each transactions.waivers as transaction }\\n\\t\\t\\t\\t<Transaction {players} {transaction} {masterOffset} {currentManagers} />\\n\\t\\t\\t{/each}\\n\\n\\t\\t\\t<p on:click={() => goto(\\"/transactions?show=waiver&query=&page=1\\")} class=\\"link\\">( view more )</p>\\n\\t\\t{:else}\\n\\t\\t\\t<p class=\\"nothingYet\\">No waiver moves have been made yet...</p>\\n\\t\\t{/if}\\n\\n\\t\\t{#if transactions.waivers.length && transactions.trades.length}\\n\\t\\t\\t<br />\\n\\t\\t{/if}\\n\\n\\t\\t<!-- trades -->\\n\\t\\t{#if transactions.trades.length}\\n\\t\\t\\t<h5>Recent Trades</h5>\\n\\t\\t\\t{#each transactions.trades as transaction }\\n\\t\\t\\t\\t<Transaction {players} {transaction} {masterOffset} currentManagers={currentManagers} />\\n\\t\\t\\t{/each}\\n\\n\\t\\t\\t<p on:click={() => goto(\\"/transactions?show=trade&query=&page=1\\")} class=\\"link\\">( view more )</p>\\n\\t\\t{:else}\\n\\t\\t\\t<p class=\\"nothingYet\\">No trades have been made yet...</p>\\n\\t\\t{/if}\\n\\t{/if}\\n</div>"],"names":[],"mappings":"AAkCC,aAAa,eAAC,CAAC,AACd,QAAQ,CAAE,QAAQ,CAClB,KAAK,CAAE,IAAI,CACX,OAAO,CAAE,CAAC,AACX,CAAC,AAED,CAAC,eAAC,CAAC,AACF,UAAU,CAAE,MAAM,AACnB,CAAC,AAED,EAAE,eAAC,CAAC,AACH,UAAU,CAAE,MAAM,CAClB,MAAM,CAAE,IAAI,CAAC,IAAI,CAAC,IAAI,AACvB,CAAC,AAED,KAAK,eAAC,CAAC,AACN,MAAM,CAAE,OAAO,CACf,KAAK,CAAE,IAAI,CACX,OAAO,CAAE,IAAI,CAAC,IAAI,CAClB,aAAa,CAAE,IAAI,AACpB,CAAC,AAED,oBAAK,MAAM,AAAC,CAAC,AACZ,KAAK,CAAE,OAAO,AACf,CAAC,AAED,WAAW,eAAC,CAAC,AACZ,MAAM,CAAE,GAAG,CAAC,CAAC,AACd,CAAC"}`
};
var Transactions$1 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let { masterOffset = 0 } = $$props;
  if ($$props.masterOffset === void 0 && $$bindings.masterOffset && masterOffset !== void 0)
    $$bindings.masterOffset(masterOffset);
  $$result.css.add(css$t);
  return `<div class="${"transactions svelte-16lkrlv"}">${`<p class="${"svelte-16lkrlv"}">Loading league transactions...</p>
		${validate_component(LinearProgress, "LinearProgress").$$render($$result, { indeterminate: true }, {}, {})}`}</div>`;
});
var ContextFragment = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let $storeValue, $$unsubscribe_storeValue;
  let { key } = $$props;
  let { value } = $$props;
  const storeValue = writable(value);
  $$unsubscribe_storeValue = subscribe(storeValue, (value2) => $storeValue = value2);
  setContext(key, storeValue);
  onDestroy(() => {
    storeValue.set(void 0);
  });
  if ($$props.key === void 0 && $$bindings.key && key !== void 0)
    $$bindings.key(key);
  if ($$props.value === void 0 && $$bindings.value && value !== void 0)
    $$bindings.value(value);
  set_store_value(storeValue, $storeValue = value, $storeValue);
  $$unsubscribe_storeValue();
  return `${slots.default ? slots.default({}) : ``}`;
});
var FloatingLabel = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let $$restProps = compute_rest_props($$props, [
    "use",
    "class",
    "style",
    "for",
    "floatAbove",
    "required",
    "wrapped",
    "shake",
    "float",
    "setRequired",
    "getWidth",
    "getElement"
  ]);
  forwardEventsBuilder(get_current_component());
  let { use = [] } = $$props;
  let { class: className = "" } = $$props;
  let { style = "" } = $$props;
  let { for: forId = null } = $$props;
  let { floatAbove = false } = $$props;
  let { required = false } = $$props;
  let { wrapped = false } = $$props;
  let element;
  let instance;
  let internalClasses = {};
  let internalStyles = {};
  let inputProps = getContext("SMUI:generic:input:props") || {};
  let previousFloatAbove = floatAbove;
  let previousRequired = required;
  function shake(shouldShake) {
    instance.shake(shouldShake);
  }
  function float(shouldFloat) {
    floatAbove = shouldFloat;
  }
  function setRequired(isRequired) {
    required = isRequired;
  }
  function getWidth() {
    return instance.getWidth();
  }
  function getElement() {
    return element;
  }
  if ($$props.use === void 0 && $$bindings.use && use !== void 0)
    $$bindings.use(use);
  if ($$props.class === void 0 && $$bindings.class && className !== void 0)
    $$bindings.class(className);
  if ($$props.style === void 0 && $$bindings.style && style !== void 0)
    $$bindings.style(style);
  if ($$props.for === void 0 && $$bindings.for && forId !== void 0)
    $$bindings.for(forId);
  if ($$props.floatAbove === void 0 && $$bindings.floatAbove && floatAbove !== void 0)
    $$bindings.floatAbove(floatAbove);
  if ($$props.required === void 0 && $$bindings.required && required !== void 0)
    $$bindings.required(required);
  if ($$props.wrapped === void 0 && $$bindings.wrapped && wrapped !== void 0)
    $$bindings.wrapped(wrapped);
  if ($$props.shake === void 0 && $$bindings.shake && shake !== void 0)
    $$bindings.shake(shake);
  if ($$props.float === void 0 && $$bindings.float && float !== void 0)
    $$bindings.float(float);
  if ($$props.setRequired === void 0 && $$bindings.setRequired && setRequired !== void 0)
    $$bindings.setRequired(setRequired);
  if ($$props.getWidth === void 0 && $$bindings.getWidth && getWidth !== void 0)
    $$bindings.getWidth(getWidth);
  if ($$props.getElement === void 0 && $$bindings.getElement && getElement !== void 0)
    $$bindings.getElement(getElement);
  {
    if (previousFloatAbove !== floatAbove) {
      previousFloatAbove = floatAbove;
      instance.float(floatAbove);
    }
  }
  {
    if (previousRequired !== required) {
      previousRequired = required;
      instance.setRequired(required);
    }
  }
  return `${wrapped ? `<span${spread([
    {
      class: escape_attribute_value(classMap({
        [className]: true,
        "mdc-floating-label": true,
        "mdc-floating-label--float-above": floatAbove,
        "mdc-floating-label--required": required,
        ...internalClasses
      }))
    },
    {
      style: escape_attribute_value(Object.entries(internalStyles).map(([name, value]) => `${name}: ${value};`).concat([style]).join(" "))
    },
    escape_object($$restProps)
  ])}${add_attribute("this", element, 0)}>${slots.default ? slots.default({}) : ``}</span>` : `<label${spread([
    {
      class: escape_attribute_value(classMap({
        [className]: true,
        "mdc-floating-label": true,
        "mdc-floating-label--float-above": floatAbove,
        "mdc-floating-label--required": required,
        ...internalClasses
      }))
    },
    {
      style: escape_attribute_value(Object.entries(internalStyles).map(([name, value]) => `${name}: ${value};`).concat([style]).join(" "))
    },
    {
      for: escape_attribute_value(forId || (inputProps ? inputProps.id : null))
    },
    escape_object($$restProps)
  ])}${add_attribute("this", element, 0)}>${slots.default ? slots.default({}) : ``}</label>`}`;
});
var LineRipple = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let $$restProps = compute_rest_props($$props, [
    "use",
    "class",
    "style",
    "active",
    "activate",
    "deactivate",
    "setRippleCenter",
    "getElement"
  ]);
  forwardEventsBuilder(get_current_component());
  let { use = [] } = $$props;
  let { class: className = "" } = $$props;
  let { style = "" } = $$props;
  let { active = false } = $$props;
  let element;
  let instance;
  let internalClasses = {};
  let internalStyles = {};
  function activate() {
    instance.activate();
  }
  function deactivate() {
    instance.deactivate();
  }
  function setRippleCenter(xCoordinate) {
    instance.setRippleCenter(xCoordinate);
  }
  function getElement() {
    return element;
  }
  if ($$props.use === void 0 && $$bindings.use && use !== void 0)
    $$bindings.use(use);
  if ($$props.class === void 0 && $$bindings.class && className !== void 0)
    $$bindings.class(className);
  if ($$props.style === void 0 && $$bindings.style && style !== void 0)
    $$bindings.style(style);
  if ($$props.active === void 0 && $$bindings.active && active !== void 0)
    $$bindings.active(active);
  if ($$props.activate === void 0 && $$bindings.activate && activate !== void 0)
    $$bindings.activate(activate);
  if ($$props.deactivate === void 0 && $$bindings.deactivate && deactivate !== void 0)
    $$bindings.deactivate(deactivate);
  if ($$props.setRippleCenter === void 0 && $$bindings.setRippleCenter && setRippleCenter !== void 0)
    $$bindings.setRippleCenter(setRippleCenter);
  if ($$props.getElement === void 0 && $$bindings.getElement && getElement !== void 0)
    $$bindings.getElement(getElement);
  return `<div${spread([
    {
      class: escape_attribute_value(classMap({
        [className]: true,
        "mdc-line-ripple": true,
        "mdc-line-ripple--active": active,
        ...internalClasses
      }))
    },
    {
      style: escape_attribute_value(Object.entries(internalStyles).map(([name, value]) => `${name}: ${value};`).concat([style]).join(" "))
    },
    escape_object($$restProps)
  ])}${add_attribute("this", element, 0)}></div>`;
});
var NotchedOutline = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let $$restProps = compute_rest_props($$props, ["use", "class", "notched", "noLabel", "notch", "closeNotch", "getElement"]);
  forwardEventsBuilder(get_current_component());
  let { use = [] } = $$props;
  let { class: className = "" } = $$props;
  let { notched = false } = $$props;
  let { noLabel = false } = $$props;
  let element;
  let instance;
  let internalClasses = {};
  let notchStyles = {};
  function removeClass(className2) {
    if (!(className2 in internalClasses) || internalClasses[className2]) {
      internalClasses[className2] = false;
    }
  }
  function notch(notchWidth) {
    instance.notch(notchWidth);
  }
  function closeNotch() {
    instance.closeNotch();
  }
  function getElement() {
    return element;
  }
  if ($$props.use === void 0 && $$bindings.use && use !== void 0)
    $$bindings.use(use);
  if ($$props.class === void 0 && $$bindings.class && className !== void 0)
    $$bindings.class(className);
  if ($$props.notched === void 0 && $$bindings.notched && notched !== void 0)
    $$bindings.notched(notched);
  if ($$props.noLabel === void 0 && $$bindings.noLabel && noLabel !== void 0)
    $$bindings.noLabel(noLabel);
  if ($$props.notch === void 0 && $$bindings.notch && notch !== void 0)
    $$bindings.notch(notch);
  if ($$props.closeNotch === void 0 && $$bindings.closeNotch && closeNotch !== void 0)
    $$bindings.closeNotch(closeNotch);
  if ($$props.getElement === void 0 && $$bindings.getElement && getElement !== void 0)
    $$bindings.getElement(getElement);
  {
    {
      removeClass("mdc-notched-outline--upgraded");
    }
  }
  return `<div${spread([
    {
      class: escape_attribute_value(classMap({
        [className]: true,
        "mdc-notched-outline": true,
        "mdc-notched-outline--notched": notched,
        "mdc-notched-outline--no-label": noLabel,
        ...internalClasses
      }))
    },
    escape_object($$restProps)
  ])}${add_attribute("this", element, 0)}><div class="${"mdc-notched-outline__leading"}"></div>
  ${!noLabel ? `<div class="${"mdc-notched-outline__notch"}"${add_attribute("style", Object.entries(notchStyles).map(([name, value]) => `${name}: ${value};`).join(" "), 0)}>${slots.default ? slots.default({}) : ``}</div>` : ``}
  <div class="${"mdc-notched-outline__trailing"}"></div>
</div>`;
});
var HelperLine = classAdderBuilder({
  class: "mdc-text-field-helper-line",
  component: Div
});
var Prefix = classAdderBuilder({
  class: "mdc-text-field__affix mdc-text-field__affix--prefix",
  component: Span
});
var Suffix = classAdderBuilder({
  class: "mdc-text-field__affix mdc-text-field__affix--suffix",
  component: Span
});
var Input = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let $$restProps = compute_rest_props($$props, [
    "use",
    "class",
    "type",
    "placeholder",
    "value",
    "files",
    "dirty",
    "invalid",
    "updateInvalid",
    "getAttr",
    "addAttr",
    "removeAttr",
    "focus",
    "getElement"
  ]);
  forwardEventsBuilder(get_current_component());
  let { use = [] } = $$props;
  let { class: className = "" } = $$props;
  let { type = "text" } = $$props;
  let { placeholder = " " } = $$props;
  let { value = "" } = $$props;
  let { files = void 0 } = $$props;
  let { dirty = false } = $$props;
  let { invalid = false } = $$props;
  let { updateInvalid = true } = $$props;
  let element;
  let internalAttrs = {};
  let valueProp = {};
  function getAttr(name) {
    return name in internalAttrs ? internalAttrs[name] : getElement().getAttribute(name);
  }
  function addAttr(name, value2) {
    if (internalAttrs[name] !== value2) {
      internalAttrs[name] = value2;
    }
  }
  function removeAttr(name) {
    if (!(name in internalAttrs) || internalAttrs[name] != null) {
      internalAttrs[name] = void 0;
    }
  }
  function focus() {
    getElement().focus();
  }
  function getElement() {
    return element;
  }
  if ($$props.use === void 0 && $$bindings.use && use !== void 0)
    $$bindings.use(use);
  if ($$props.class === void 0 && $$bindings.class && className !== void 0)
    $$bindings.class(className);
  if ($$props.type === void 0 && $$bindings.type && type !== void 0)
    $$bindings.type(type);
  if ($$props.placeholder === void 0 && $$bindings.placeholder && placeholder !== void 0)
    $$bindings.placeholder(placeholder);
  if ($$props.value === void 0 && $$bindings.value && value !== void 0)
    $$bindings.value(value);
  if ($$props.files === void 0 && $$bindings.files && files !== void 0)
    $$bindings.files(files);
  if ($$props.dirty === void 0 && $$bindings.dirty && dirty !== void 0)
    $$bindings.dirty(dirty);
  if ($$props.invalid === void 0 && $$bindings.invalid && invalid !== void 0)
    $$bindings.invalid(invalid);
  if ($$props.updateInvalid === void 0 && $$bindings.updateInvalid && updateInvalid !== void 0)
    $$bindings.updateInvalid(updateInvalid);
  if ($$props.getAttr === void 0 && $$bindings.getAttr && getAttr !== void 0)
    $$bindings.getAttr(getAttr);
  if ($$props.addAttr === void 0 && $$bindings.addAttr && addAttr !== void 0)
    $$bindings.addAttr(addAttr);
  if ($$props.removeAttr === void 0 && $$bindings.removeAttr && removeAttr !== void 0)
    $$bindings.removeAttr(removeAttr);
  if ($$props.focus === void 0 && $$bindings.focus && focus !== void 0)
    $$bindings.focus(focus);
  if ($$props.getElement === void 0 && $$bindings.getElement && getElement !== void 0)
    $$bindings.getElement(getElement);
  {
    if (type === "file") {
      delete valueProp.value;
      valueProp = valueProp;
    } else {
      valueProp.value = value == null ? "" : value;
    }
  }
  return `<input${spread([
    {
      class: escape_attribute_value(classMap({
        [className]: true,
        "mdc-text-field__input": true
      }))
    },
    { type: escape_attribute_value(type) },
    {
      placeholder: escape_attribute_value(placeholder)
    },
    escape_object(valueProp),
    escape_object(internalAttrs),
    escape_object($$restProps)
  ])}${add_attribute("this", element, 0)}>`;
});
var Textarea = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let $$restProps = compute_rest_props($$props, [
    "use",
    "class",
    "style",
    "value",
    "dirty",
    "invalid",
    "updateInvalid",
    "resizable",
    "getAttr",
    "addAttr",
    "removeAttr",
    "focus",
    "getElement"
  ]);
  forwardEventsBuilder(get_current_component());
  let { use = [] } = $$props;
  let { class: className = "" } = $$props;
  let { style = "" } = $$props;
  let { value = "" } = $$props;
  let { dirty = false } = $$props;
  let { invalid = false } = $$props;
  let { updateInvalid = true } = $$props;
  let { resizable = true } = $$props;
  let element;
  let internalAttrs = {};
  function getAttr(name) {
    return name in internalAttrs ? internalAttrs[name] : getElement().getAttribute(name);
  }
  function addAttr(name, value2) {
    if (internalAttrs[name] !== value2) {
      internalAttrs[name] = value2;
    }
  }
  function removeAttr(name) {
    if (!(name in internalAttrs) || internalAttrs[name] != null) {
      internalAttrs[name] = void 0;
    }
  }
  function focus() {
    getElement().focus();
  }
  function getElement() {
    return element;
  }
  if ($$props.use === void 0 && $$bindings.use && use !== void 0)
    $$bindings.use(use);
  if ($$props.class === void 0 && $$bindings.class && className !== void 0)
    $$bindings.class(className);
  if ($$props.style === void 0 && $$bindings.style && style !== void 0)
    $$bindings.style(style);
  if ($$props.value === void 0 && $$bindings.value && value !== void 0)
    $$bindings.value(value);
  if ($$props.dirty === void 0 && $$bindings.dirty && dirty !== void 0)
    $$bindings.dirty(dirty);
  if ($$props.invalid === void 0 && $$bindings.invalid && invalid !== void 0)
    $$bindings.invalid(invalid);
  if ($$props.updateInvalid === void 0 && $$bindings.updateInvalid && updateInvalid !== void 0)
    $$bindings.updateInvalid(updateInvalid);
  if ($$props.resizable === void 0 && $$bindings.resizable && resizable !== void 0)
    $$bindings.resizable(resizable);
  if ($$props.getAttr === void 0 && $$bindings.getAttr && getAttr !== void 0)
    $$bindings.getAttr(getAttr);
  if ($$props.addAttr === void 0 && $$bindings.addAttr && addAttr !== void 0)
    $$bindings.addAttr(addAttr);
  if ($$props.removeAttr === void 0 && $$bindings.removeAttr && removeAttr !== void 0)
    $$bindings.removeAttr(removeAttr);
  if ($$props.focus === void 0 && $$bindings.focus && focus !== void 0)
    $$bindings.focus(focus);
  if ($$props.getElement === void 0 && $$bindings.getElement && getElement !== void 0)
    $$bindings.getElement(getElement);
  return `<textarea${spread([
    {
      class: escape_attribute_value(classMap({
        [className]: true,
        "mdc-text-field__input": true
      }))
    },
    {
      style: escape_attribute_value(`${resizable ? "" : "resize: none; "}${style}`)
    },
    escape_object(internalAttrs),
    escape_object($$restProps)
  ])}${add_attribute("this", element, 0)}>${value || ""}</textarea>`;
});
var { Object: Object_1 } = globals;
var Textfield = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let valued;
  let $$restProps = compute_rest_props($$props, [
    "use",
    "class",
    "style",
    "ripple",
    "disabled",
    "required",
    "textarea",
    "variant",
    "noLabel",
    "label",
    "type",
    "value",
    "files",
    "dirty",
    "invalid",
    "prefix",
    "suffix",
    "updateInvalid",
    "validateOnValueChange",
    "useNativeValidation",
    "withLeadingIcon",
    "withTrailingIcon",
    "input",
    "floatingLabel",
    "lineRipple",
    "notchedOutline",
    "focus",
    "layout",
    "getElement"
  ]);
  let $$slots = compute_slots(slots);
  forwardEventsBuilder(get_current_component());
  let uninitializedValue = () => {
  };
  let { use = [] } = $$props;
  let { class: className = "" } = $$props;
  let { style = "" } = $$props;
  let { ripple = true } = $$props;
  let { disabled = false } = $$props;
  let { required = false } = $$props;
  let { textarea = false } = $$props;
  let { variant = textarea ? "outlined" : "standard" } = $$props;
  let { noLabel = false } = $$props;
  let { label = null } = $$props;
  let { type = "text" } = $$props;
  let { value = uninitializedValue } = $$props;
  let { files = uninitializedValue } = $$props;
  let { dirty = false } = $$props;
  let { invalid = uninitializedValue } = $$props;
  let { prefix = null } = $$props;
  let { suffix = null } = $$props;
  let { updateInvalid = invalid === uninitializedValue } = $$props;
  let { validateOnValueChange = updateInvalid } = $$props;
  let { useNativeValidation = updateInvalid } = $$props;
  let { withLeadingIcon = uninitializedValue } = $$props;
  let { withTrailingIcon = uninitializedValue } = $$props;
  let { input = void 0 } = $$props;
  let { floatingLabel = void 0 } = $$props;
  let { lineRipple = void 0 } = $$props;
  let { notchedOutline = void 0 } = $$props;
  let element;
  let internalClasses = {};
  let internalStyles = {};
  let helperId;
  let addLayoutListener = getContext("SMUI:addLayoutListener");
  let removeLayoutListener;
  new Promise((resolve2) => resolve2);
  if (addLayoutListener) {
    removeLayoutListener = addLayoutListener(layout);
  }
  onDestroy(() => {
    if (removeLayoutListener) {
      removeLayoutListener();
    }
  });
  function focus() {
    input.focus();
  }
  function layout() {
  }
  function getElement() {
    return element;
  }
  if ($$props.use === void 0 && $$bindings.use && use !== void 0)
    $$bindings.use(use);
  if ($$props.class === void 0 && $$bindings.class && className !== void 0)
    $$bindings.class(className);
  if ($$props.style === void 0 && $$bindings.style && style !== void 0)
    $$bindings.style(style);
  if ($$props.ripple === void 0 && $$bindings.ripple && ripple !== void 0)
    $$bindings.ripple(ripple);
  if ($$props.disabled === void 0 && $$bindings.disabled && disabled !== void 0)
    $$bindings.disabled(disabled);
  if ($$props.required === void 0 && $$bindings.required && required !== void 0)
    $$bindings.required(required);
  if ($$props.textarea === void 0 && $$bindings.textarea && textarea !== void 0)
    $$bindings.textarea(textarea);
  if ($$props.variant === void 0 && $$bindings.variant && variant !== void 0)
    $$bindings.variant(variant);
  if ($$props.noLabel === void 0 && $$bindings.noLabel && noLabel !== void 0)
    $$bindings.noLabel(noLabel);
  if ($$props.label === void 0 && $$bindings.label && label !== void 0)
    $$bindings.label(label);
  if ($$props.type === void 0 && $$bindings.type && type !== void 0)
    $$bindings.type(type);
  if ($$props.value === void 0 && $$bindings.value && value !== void 0)
    $$bindings.value(value);
  if ($$props.files === void 0 && $$bindings.files && files !== void 0)
    $$bindings.files(files);
  if ($$props.dirty === void 0 && $$bindings.dirty && dirty !== void 0)
    $$bindings.dirty(dirty);
  if ($$props.invalid === void 0 && $$bindings.invalid && invalid !== void 0)
    $$bindings.invalid(invalid);
  if ($$props.prefix === void 0 && $$bindings.prefix && prefix !== void 0)
    $$bindings.prefix(prefix);
  if ($$props.suffix === void 0 && $$bindings.suffix && suffix !== void 0)
    $$bindings.suffix(suffix);
  if ($$props.updateInvalid === void 0 && $$bindings.updateInvalid && updateInvalid !== void 0)
    $$bindings.updateInvalid(updateInvalid);
  if ($$props.validateOnValueChange === void 0 && $$bindings.validateOnValueChange && validateOnValueChange !== void 0)
    $$bindings.validateOnValueChange(validateOnValueChange);
  if ($$props.useNativeValidation === void 0 && $$bindings.useNativeValidation && useNativeValidation !== void 0)
    $$bindings.useNativeValidation(useNativeValidation);
  if ($$props.withLeadingIcon === void 0 && $$bindings.withLeadingIcon && withLeadingIcon !== void 0)
    $$bindings.withLeadingIcon(withLeadingIcon);
  if ($$props.withTrailingIcon === void 0 && $$bindings.withTrailingIcon && withTrailingIcon !== void 0)
    $$bindings.withTrailingIcon(withTrailingIcon);
  if ($$props.input === void 0 && $$bindings.input && input !== void 0)
    $$bindings.input(input);
  if ($$props.floatingLabel === void 0 && $$bindings.floatingLabel && floatingLabel !== void 0)
    $$bindings.floatingLabel(floatingLabel);
  if ($$props.lineRipple === void 0 && $$bindings.lineRipple && lineRipple !== void 0)
    $$bindings.lineRipple(lineRipple);
  if ($$props.notchedOutline === void 0 && $$bindings.notchedOutline && notchedOutline !== void 0)
    $$bindings.notchedOutline(notchedOutline);
  if ($$props.focus === void 0 && $$bindings.focus && focus !== void 0)
    $$bindings.focus(focus);
  if ($$props.layout === void 0 && $$bindings.layout && layout !== void 0)
    $$bindings.layout(layout);
  if ($$props.getElement === void 0 && $$bindings.getElement && getElement !== void 0)
    $$bindings.getElement(getElement);
  let $$settled;
  let $$rendered;
  do {
    $$settled = true;
    valued = value !== uninitializedValue || files !== uninitializedValue;
    input && input.getElement();
    $$rendered = `${valued ? `<label${spread([
      {
        class: escape_attribute_value(classMap({
          [className]: true,
          "mdc-text-field": true,
          "mdc-text-field--disabled": disabled,
          "mdc-text-field--textarea": textarea,
          "mdc-text-field--filled": variant === "filled",
          "mdc-text-field--outlined": variant === "outlined",
          "smui-text-field--standard": variant === "standard" && !textarea,
          "mdc-text-field--no-label": noLabel || label == null && !$$slots.label,
          "mdc-text-field--label-floating": value != null && value !== "",
          "mdc-text-field--with-leading-icon": withLeadingIcon === uninitializedValue ? $$slots.leadingIcon : withLeadingIcon,
          "mdc-text-field--with-trailing-icon": withTrailingIcon === uninitializedValue ? $$slots.trailingIcon : withTrailingIcon,
          "mdc-text-field--with-internal-counter": textarea && $$slots.internalCounter,
          "mdc-text-field--invalid": invalid !== uninitializedValue && invalid,
          ...internalClasses
        }))
      },
      {
        style: escape_attribute_value(Object.entries(internalStyles).map(([name, value2]) => `${name}: ${value2};`).concat([style]).join(" "))
      },
      {
        for: escape_attribute_value(null)
      },
      escape_object(exclude($$restProps, ["input$", "label$", "ripple$", "outline$", "helperLine$"]))
    ])}${add_attribute("this", element, 0)}>${!textarea && variant !== "outlined" ? `${variant === "filled" ? `<span class="${"mdc-text-field__ripple"}"></span>` : ``}
      ${!noLabel && (label != null || $$slots.label) ? `${validate_component(FloatingLabel, "FloatingLabel").$$render($$result, Object_1.assign({
      floatAbove: value != null && value !== ""
    }, { required }, { wrapped: true }, prefixFilter($$restProps, "label$"), { this: floatingLabel }), {
      this: ($$value) => {
        floatingLabel = $$value;
        $$settled = false;
      }
    }, {
      default: () => `${escape(label == null ? "" : label)}${slots.label ? slots.label({}) : ``}`
    })}` : ``}` : ``}
    ${textarea || variant === "outlined" ? `${validate_component(NotchedOutline, "NotchedOutline").$$render($$result, Object_1.assign({
      noLabel: noLabel || label == null && !$$slots.label
    }, prefixFilter($$restProps, "outline$"), { this: notchedOutline }), {
      this: ($$value) => {
        notchedOutline = $$value;
        $$settled = false;
      }
    }, {
      default: () => `${!noLabel && (label != null || $$slots.label) ? `${validate_component(FloatingLabel, "FloatingLabel").$$render($$result, Object_1.assign({
        floatAbove: value != null && value !== ""
      }, { required }, { wrapped: true }, prefixFilter($$restProps, "label$"), { this: floatingLabel }), {
        this: ($$value) => {
          floatingLabel = $$value;
          $$settled = false;
        }
      }, {
        default: () => `${escape(label == null ? "" : label)}${slots.label ? slots.label({}) : ``}`
      })}` : ``}`
    })}` : ``}
    ${validate_component(ContextFragment, "ContextFragment").$$render($$result, {
      key: "SMUI:textfield:icon:leading",
      value: true
    }, {}, {
      default: () => `${slots.leadingIcon ? slots.leadingIcon({}) : ``}`
    })}
    ${slots.default ? slots.default({}) : ``}
    ${textarea ? `<span${add_attribute("class", classMap({
      "mdc-text-field__resizer": !("input$resizable" in $$restProps) || $$restProps.input$resizable
    }), 0)}>${validate_component(Textarea, "Textarea").$$render($$result, Object_1.assign({ disabled }, { required }, { updateInvalid }, { "aria-controls": helperId }, { "aria-describedby": helperId }, prefixFilter($$restProps, "input$"), { this: input }, { value }, { dirty }, { invalid }), {
      this: ($$value) => {
        input = $$value;
        $$settled = false;
      },
      value: ($$value) => {
        value = $$value;
        $$settled = false;
      },
      dirty: ($$value) => {
        dirty = $$value;
        $$settled = false;
      },
      invalid: ($$value) => {
        invalid = $$value;
        $$settled = false;
      }
    }, {})}
        ${slots.internalCounter ? slots.internalCounter({}) : ``}</span>` : `${slots.prefix ? slots.prefix({}) : ``}
      ${prefix != null ? `${validate_component(Prefix, "Prefix").$$render($$result, {}, {}, { default: () => `${escape(prefix)}` })}` : ``}
      ${validate_component(Input, "Input").$$render($$result, Object_1.assign({ type }, { disabled }, { required }, { updateInvalid }, { "aria-controls": helperId }, { "aria-describedby": helperId }, noLabel && label != null ? { placeholder: label } : {}, prefixFilter($$restProps, "input$"), { this: input }, { value }, { files }, { dirty }, { invalid }), {
      this: ($$value) => {
        input = $$value;
        $$settled = false;
      },
      value: ($$value) => {
        value = $$value;
        $$settled = false;
      },
      files: ($$value) => {
        files = $$value;
        $$settled = false;
      },
      dirty: ($$value) => {
        dirty = $$value;
        $$settled = false;
      },
      invalid: ($$value) => {
        invalid = $$value;
        $$settled = false;
      }
    }, {})}
      ${suffix != null ? `${validate_component(Suffix, "Suffix").$$render($$result, {}, {}, { default: () => `${escape(suffix)}` })}` : ``}
      ${slots.suffix ? slots.suffix({}) : ``}`}
    ${validate_component(ContextFragment, "ContextFragment").$$render($$result, {
      key: "SMUI:textfield:icon:leading",
      value: false
    }, {}, {
      default: () => `${slots.trailingIcon ? slots.trailingIcon({}) : ``}`
    })}
    ${!textarea && variant !== "outlined" && ripple ? `${validate_component(LineRipple, "LineRipple").$$render($$result, Object_1.assign(prefixFilter($$restProps, "ripple$"), { this: lineRipple }), {
      this: ($$value) => {
        lineRipple = $$value;
        $$settled = false;
      }
    }, {})}` : ``}</label>` : `<div${spread([
      {
        class: escape_attribute_value(classMap({
          [className]: true,
          "mdc-text-field": true,
          "mdc-text-field--disabled": disabled,
          "mdc-text-field--textarea": textarea,
          "mdc-text-field--filled": variant === "filled",
          "mdc-text-field--outlined": variant === "outlined",
          "smui-text-field--standard": variant === "standard" && !textarea,
          "mdc-text-field--no-label": noLabel || !$$slots.label,
          "mdc-text-field--with-leading-icon": $$slots.leadingIcon,
          "mdc-text-field--with-trailing-icon": $$slots.trailingIcon,
          "mdc-text-field--invalid": invalid !== uninitializedValue && invalid,
          ...internalClasses
        }))
      },
      {
        style: escape_attribute_value(Object.entries(internalStyles).map(([name, value2]) => `${name}: ${value2};`).concat([style]).join(" "))
      },
      escape_object(exclude($$restProps, ["input$", "label$", "ripple$", "outline$", "helperLine$"]))
    ])}${add_attribute("this", element, 0)}>${slots.label ? slots.label({}) : ``}
    ${validate_component(ContextFragment, "ContextFragment").$$render($$result, {
      key: "SMUI:textfield:icon:leading",
      value: true
    }, {}, {
      default: () => `${slots.leadingIcon ? slots.leadingIcon({}) : ``}`
    })}
    ${slots.default ? slots.default({}) : ``}
    ${validate_component(ContextFragment, "ContextFragment").$$render($$result, {
      key: "SMUI:textfield:icon:leading",
      value: false
    }, {}, {
      default: () => `${slots.trailingIcon ? slots.trailingIcon({}) : ``}`
    })}
    ${slots.ripple ? slots.ripple({}) : ``}</div>`}
${$$slots.helper ? `${validate_component(HelperLine, "HelperLine").$$render($$result, Object_1.assign(prefixFilter($$restProps, "helperLine$")), {}, {
      default: () => `${slots.helper ? slots.helper({}) : ``}`
    })}` : ``}`;
  } while (!$$settled);
  return $$rendered;
});
var Icon = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let $$restProps = compute_rest_props($$props, ["use", "class", "role", "tabindex", "disabled", "getElement"]);
  let $leadingStore, $$unsubscribe_leadingStore;
  forwardEventsBuilder(get_current_component());
  let { use = [] } = $$props;
  let { class: className = "" } = $$props;
  let { role = null } = $$props;
  let { tabindex = role === "button" ? "0" : "-1" } = $$props;
  let { disabled = false } = $$props;
  let element;
  let internalAttrs = {};
  const leadingStore = getContext("SMUI:textfield:icon:leading");
  $$unsubscribe_leadingStore = subscribe(leadingStore, (value) => $leadingStore = value);
  const leading = $leadingStore;
  function getElement() {
    return element;
  }
  if ($$props.use === void 0 && $$bindings.use && use !== void 0)
    $$bindings.use(use);
  if ($$props.class === void 0 && $$bindings.class && className !== void 0)
    $$bindings.class(className);
  if ($$props.role === void 0 && $$bindings.role && role !== void 0)
    $$bindings.role(role);
  if ($$props.tabindex === void 0 && $$bindings.tabindex && tabindex !== void 0)
    $$bindings.tabindex(tabindex);
  if ($$props.disabled === void 0 && $$bindings.disabled && disabled !== void 0)
    $$bindings.disabled(disabled);
  if ($$props.getElement === void 0 && $$bindings.getElement && getElement !== void 0)
    $$bindings.getElement(getElement);
  $$unsubscribe_leadingStore();
  return `<i${spread([
    {
      class: escape_attribute_value(classMap({
        [className]: true,
        "mdc-text-field__icon": true,
        "mdc-text-field__icon--leading": leading,
        "mdc-text-field__icon--trailing": !leading
      }))
    },
    {
      tabindex: escape_attribute_value(tabindex)
    },
    {
      "aria-hidden": escape_attribute_value(tabindex === "-1" ? "true" : "false")
    },
    {
      "aria-disabled": escape_attribute_value(role === "button" ? disabled ? "true" : "false" : null)
    },
    { role: escape_attribute_value(role) },
    escape_object(internalAttrs),
    escape_object($$restProps)
  ])}${add_attribute("this", element, 0)}>${slots.default ? slots.default({}) : ``}</i>`;
});
var css$s = {
  code: ".transactionsParent.svelte-1vi4974{display:flex;flex-wrap:wrap;position:relative;width:100%;z-index:1;overflow-y:hidden}@media(max-width: 1000px){}.transactions.svelte-1vi4974{flex-grow:1;padding:0 15px}p.svelte-1vi4974{text-align:center}h5.svelte-1vi4974{text-align:center;margin:30px auto 16px}.buttons.svelte-1vi4974{margin:40px auto 0}.disabled{pointer-events:none}.invis-buttons.svelte-1vi4974{display:none !important}.searchContainer.svelte-1vi4974{width:100%;text-align:center;margin:2em 0 .5em}.clearPlaceholder.svelte-1vi4974{width:48px;display:inline-block}.empty.svelte-1vi4974{width:100%;font-style:italic;text-align:center;color:#999}",
  map: `{"version":3,"file":"TransactionsPage.svelte","sources":["TransactionsPage.svelte"],"sourcesContent":["<script>\\n\\timport Textfield from '@smui/textfield';\\n  \\timport Icon from '@smui/textfield/icon';\\n\\timport Transaction from './Transaction.svelte';\\n\\timport Button, { Label } from '@smui/button';\\n\\timport IconButton from '@smui/icon-button';\\n\\timport Pagination from '../Pagination.svelte';\\n\\timport { match } from 'fuzzyjs';\\n\\timport { goto } from '$app/navigation';\\n\\timport { getLeagueTransactions, loadPlayers } from '$lib/utils/helper';\\n\\n\\texport let masterOffset = 0, show, playersInfo, query, queryPage, transactions, currentManagers, stale, perPage, postUpdate=false;\\n\\tconst oldQuery = query;\\n\\tlet page = queryPage || 0;\\n\\n\\tconst refreshTransactions = async () => {\\n\\t\\tconst newTransactions = await getLeagueTransactions(false, true);\\n\\t\\ttransactions = newTransactions.transactions;\\n\\t\\tcurrentManagers = newTransactions.currentManagers;\\n\\t}\\n\\n\\tif(stale) {\\n\\t\\trefreshTransactions();\\n\\t}\\n\\n\\tlet players = playersInfo.players;\\n\\n\\tconst refreshPlayers = async () => {\\n\\t\\tconst newPlayersInfo = await loadPlayers(true);\\n\\t\\tplayers = newPlayersInfo.players;\\n\\t}\\n\\n\\tif(playersInfo.stale) {\\n\\t\\trefreshPlayers();\\n\\t}\\n\\n\\t// filtered subset based on search\\n\\tlet subsetTransactions = [];\\n\\n\\tlet totalTransactions = 0;\\n\\n\\tconst setFilter = (filterBy, transactions) => {\\n\\t\\tif(filterBy == \\"both\\") {\\n\\t\\t\\treturn transactions;\\n\\t\\t} else {\\n\\t\\t\\treturn transactions.filter( transaction => transaction.type == filterBy);\\n\\t\\t}\\n\\t}\\n\\n\\t// filtered subset based on filter\\n\\t$: filteredTransactions = setFilter(show, transactions);\\n\\n\\tconst setQuery = (query, filteredTransactions) => {\\n\\t\\tif(!filteredTransactions) {\\n\\t\\t\\treturn [];\\n\\t\\t}\\n\\t\\tif(query && query.trim() != \\"\\") {\\n\\t\\t\\tsubsetTransactions = filteredTransactions.filter( transaction => checkForQuery(transaction));\\n\\t\\t\\ttotalTransactions = subsetTransactions.length;\\n\\t\\t} else {\\n\\t\\t\\tsubsetTransactions = filteredTransactions;\\n\\t\\t\\ttotalTransactions = subsetTransactions.length;\\n\\t\\t}\\n\\n\\t\\tconst start = page * perPage;\\n\\t\\tconst end = (page + 1) * perPage;\\n\\t\\treturn subsetTransactions.slice(start, end);\\n\\t}\\n\\t$: displayTransactions = setQuery(query, filteredTransactions);\\n\\n\\tconst changePage = (dest, pageChange = false) => {\\n\\t\\tif(queryPage == dest && pageChange) return;\\n\\t\\tpage = dest;\\n\\t\\tif(dest > (filteredTransactions.length / perPage) || dest < 0) {\\n\\t\\t\\tpage = 0;\\n\\t\\t}\\n\\t\\tdisplayTransactions = setQuery(query, filteredTransactions);\\n\\t\\tif(postUpdate) {\\n\\t\\t\\tsetTimeout(() => {goto(\`/transactions?show=\${show}&query=\${query}&page=\${page+1}\`, {noscroll: true,  keepfocus: true})}, 800);\\n\\t\\t}\\n\\t}\\n\\n\\tlet lastUpdate = new Date;\\n\\n\\tconst search = () => {\\n\\t\\tlastUpdate = new Date;\\n\\t\\tquery = query.trimLeft();\\n\\t\\tif(query.trim() == oldQuery) return;\\n\\t\\tpage = 0;\\n\\t\\tif(postUpdate) {\\n\\t\\t\\tupdateQueryParam(false);\\n\\t\\t}\\n\\t}\\n\\n\\tlet called = false;\\n\\n\\tconst updateQueryParam = (stack = true) => {\\n\\t\\tif(called && !stack) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tcalled = true;\\n\\t\\tconst FIVE_SECONDS = 5 * 1000; /* five seconds */\\n\\t\\tif(((new Date) - lastUpdate) > FIVE_SECONDS) {\\n\\t\\t\\tcalled = false;\\n\\t\\t\\tgoto(\`/transactions?show=\${show}&query=\${query.trim()}&page=\${page+1}\`, {noscroll: true,  keepfocus: true});\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\treturn setTimeout(updateQueryParam, 2000); // check every 2 seconds\\n\\t}\\n\\n\\tconst clearSearch = () => {\\n\\t\\tquery = \\"\\";\\n\\t\\tif(postUpdate) {\\n\\t\\t\\tgoto(\`/transactions?show=\${show}&query=&page=\${page+1}\`, {noscroll: true,  keepfocus: true});\\n\\t\\t}\\n\\t}\\n\\t\\n\\tconst checkMatch = (query, name) => {\\n\\t\\tconst nameMatch = match(query, name)\\n\\t\\tif(nameMatch.match && nameMatch.score > 0) {\\n\\t\\t\\t(nameMatch.score);\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t}\\n\\n\\tconst checkForQuery = (transaction) => {\\n\\t\\tconst moves = transaction.moves;\\n\\t\\tfor(const move of moves) {\\n\\t\\t\\tfor(const col of move) {\\n\\t\\t\\t\\tif(!col?.player) continue;\\n\\t\\t\\t\\treturn checkMatch(query, \`\${players[col.player].fn} \${players[col.player].ln}\`);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn false;\\n\\t}\\n\\n\\t$: changePage(page, true);\\n\\n\\t$: setQuery(query);\\n\\n    let el;\\n\\n    $: top = el?.getBoundingClientRect() ? el?.getBoundingClientRect().top  : 0;\\n\\n\\tconst setShow = (val) => {\\n\\t\\tshow = val;\\n\\t\\tpage = 0;\\n\\t\\tchangePage(0);\\n\\t}\\n<\/script>\\n\\n<style>\\n\\t.transactionsParent {\\n\\t\\tdisplay: flex;\\n\\t\\tflex-wrap: wrap;\\n\\t\\tposition: relative;\\n\\t\\twidth: 100%;\\n\\t\\tz-index: 1;\\n\\t\\toverflow-y: hidden;\\n\\t}\\n\\n    @media (max-width: 1000px) {\\n    }\\n\\n\\t.transactions {\\n\\t\\tflex-grow: 1;\\n\\t\\tpadding: 0 15px;\\n\\t}\\n\\n\\tp {\\n\\t\\ttext-align: center;\\n\\t}\\n\\n\\th5 {\\n\\t\\ttext-align: center;\\n\\t\\tmargin: 30px auto 16px;\\n\\t}\\n\\n\\t.buttons {\\n\\t\\tmargin: 40px auto 0;\\n\\t}\\n\\n\\t:global(.disabled) {\\n\\t\\tpointer-events: none;\\n\\t}\\n\\n\\t.invis-buttons {\\n\\t\\tdisplay: none !important;\\n\\t}\\n\\n\\t.searchContainer {\\n\\t\\twidth: 100%;\\n\\t\\ttext-align: center;\\n\\t\\tmargin: 2em 0 .5em;\\n\\t}\\n\\n\\t.clearPlaceholder {\\n\\t\\twidth: 48px;\\n\\t\\tdisplay: inline-block;\\n\\t}\\n\\t\\n\\t.empty {\\n\\t\\twidth: 100%;\\n\\t\\tfont-style: italic;\\n\\t\\ttext-align: center;\\n\\t\\tcolor: #999;\\n\\t}\\n</style>\\n\\n<div class=\\"transactionsParent\\">\\n\\t<div class=\\"buttons {show == \\"trade\\" ? \\"\\" : \\"invis-buttons\\"}\\">\\n\\t\\t<Button class=\\"{show == \\"trade\\" ? \\"disabled\\" : \\"\\"}\\" color=\\"primary\\" on:click={() => setShow(\\"trade\\")} variant=\\"{show == \\"trade\\" ? \\"raised\\" : \\"outlined\\"}\\" touch>\\n\\t\\t\\t<Label>Trades</Label>\\n\\t\\t</Button>\\n\\t\\t<Button class=\\"{show == \\"waiver\\" ? \\"disabled\\" : \\"\\"}\\" color=\\"primary\\" on:click={() => setShow(\\"waiver\\")} variant=\\"{show == \\"waiver\\" ? \\"raised\\" : \\"outlined\\"}\\" touch>\\n\\t\\t\\t<Label>Waivers</Label>\\n\\t\\t</Button>\\n\\t\\t<Button class=\\"{show == \\"both\\" ? \\"disabled\\" : \\"\\"}\\" color=\\"primary\\" on:click={() => setShow(\\"both\\")} variant=\\"{show == \\"both\\" ? \\"raised\\" : \\"outlined\\"}\\" touch>\\n\\t\\t\\t<Label>Both</Label>\\n\\t\\t</Button>\\n\\t</div>\\n\\t<div class=\\"buttons {show == \\"waiver\\" ? \\"\\" : \\"invis-buttons\\"}\\">\\n\\t\\t<Button class=\\"{show == \\"trade\\" ? \\"disabled\\" : \\"\\"}\\" color=\\"primary\\" on:click={() => setShow(\\"trade\\")} variant=\\"{show == \\"trade\\" ? \\"raised\\" : \\"outlined\\"}\\" touch>\\n\\t\\t\\t<Label>Trades</Label>\\n\\t\\t</Button>\\n\\t\\t<Button class=\\"{show == \\"waiver\\" ? \\"disabled\\" : \\"\\"}\\" color=\\"primary\\" on:click={() => setShow(\\"waiver\\")} variant=\\"{show == \\"waiver\\" ? \\"raised\\" : \\"outlined\\"}\\" touch>\\n\\t\\t\\t<Label>Waivers</Label>\\n\\t\\t</Button>\\n\\t\\t<Button class=\\"{show == \\"both\\" ? \\"disabled\\" : \\"\\"}\\" color=\\"primary\\" on:click={() => setShow(\\"both\\")} variant=\\"{show == \\"both\\" ? \\"raised\\" : \\"outlined\\"}\\" touch>\\n\\t\\t\\t<Label>Both</Label>\\n\\t\\t</Button>\\n\\t</div>\\n\\t<div class=\\"buttons {show == \\"both\\" ? \\"\\" : \\"invis-buttons\\"}\\">\\n\\t\\t<Button class=\\"{show == \\"trade\\" ? \\"disabled\\" : \\"\\"}\\" color=\\"primary\\" on:click={() => setShow(\\"trade\\")} variant=\\"{show == \\"trade\\" ? \\"raised\\" : \\"outlined\\"}\\" touch>\\n\\t\\t\\t<Label>Trades</Label>\\n\\t\\t</Button>\\n\\t\\t<Button class=\\"{show == \\"waiver\\" ? \\"disabled\\" : \\"\\"}\\" color=\\"primary\\" on:click={() => setShow(\\"waiver\\")} variant=\\"{show == \\"waiver\\" ? \\"raised\\" : \\"outlined\\"}\\" touch>\\n\\t\\t\\t<Label>Waivers</Label>\\n\\t\\t</Button>\\n\\t\\t<Button class=\\"{show == \\"both\\" ? \\"disabled\\" : \\"\\"}\\" color=\\"primary\\" on:click={() => setShow(\\"both\\")} variant=\\"{show == \\"both\\" ? \\"raised\\" : \\"outlined\\"}\\" touch>\\n\\t\\t\\t<Label>Both</Label>\\n\\t\\t</Button>\\n\\t</div>\\n\\t<div class=\\"searchContainer\\">\\n\\t\\t<span class=\\"clearPlaceholder\\" />\\n\\t\\t<Textfield\\n\\t\\t\\tclass=\\"shaped-outlined\\"\\n\\t\\t\\tvariant=\\"outlined\\"\\n\\t\\t\\tbind:value={query}\\n\\t\\t\\tlabel=\\"Search for a player...\\"\\n\\t\\t\\ton:input={() => search()}\\n\\t\\t>\\n\\t\\t\\t<Icon class=\\"material-icons\\" slot=\\"leadingIcon\\">search</Icon>\\n\\t\\t</Textfield>\\n\\t\\t{#if query.length > 0}\\n\\t\\t\\t  <IconButton class=\\"material-icons\\" on:click={() => clearSearch()}>clear</IconButton>\\n\\t\\t{:else}\\n\\t\\t\\t<span class=\\"clearPlaceholder\\" />\\n\\t\\t{/if}\\n\\t</div>\\n\\n\\t<div class=\\"transactions\\" bind:this={el}>\\n\\t\\t{#if show == \\"both\\"}\\n\\t\\t\\t<!-- trades -->\\n\\t\\t\\t<h5>Recent Transactions</h5>\\n\\t\\t{:else if show == \\"trade\\"}\\n\\t\\t\\t<!-- trades -->\\n\\t\\t\\t<h5>Recent Trades</h5>\\n\\t\\t{:else}\\n\\t\\t\\t<!-- waiver -->\\n\\t\\t\\t<h5>Recent Waivers</h5>\\n\\t\\t{/if}\\n\\n\\t\\t<Pagination {perPage} total={totalTransactions} bind:page={page} target={top} scroll={false} />\\n\\t\\t<div class=\\"transactions-child\\">\\n\\t\\t\\t{#each displayTransactions as transaction (transaction.id)}\\n\\t\\t\\t\\t<Transaction {players} {transaction} masterOffset={masterOffset + 15} {currentManagers} />\\n\\t\\t\\t{/each}\\n\\t\\t</div>\\n\\t\\t<Pagination {perPage} total={totalTransactions} bind:page={page} target={top} scroll={true} />\\n\\n\\t</div>\\n\\n\\t{#if totalTransactions == 0}\\n\\t\\t{#if show == \\"trade\\"}\\n\\t\\t\\t<p class=\\"empty\\">{query.trim() != \\"\\" ? \\"No trades match your search\\" : \\"Nobody has made any trades yet... that's just sad\\" }</p>\\n\\t\\t{:else if show == \\"waiver\\"}\\n\\t\\t\\t<p class=\\"empty\\">{query.trim() != \\"\\" ? \\"No waivers match your search\\" : \\"Nobody has made any waiver wire moves yet... that's just sad\\" }</p>\\n\\t\\t{:else}\\n\\t\\t\\t<p class=\\"empty\\">{query.trim() != \\"\\" ? \\"No transactions match your search\\" : \\"Nobody has made any moves yet... that's just sad\\" }</p>\\n\\t\\t{/if}\\n\\t{/if}\\n</div>"],"names":[],"mappings":"AAwJC,mBAAmB,eAAC,CAAC,AACpB,OAAO,CAAE,IAAI,CACb,SAAS,CAAE,IAAI,CACf,QAAQ,CAAE,QAAQ,CAClB,KAAK,CAAE,IAAI,CACX,OAAO,CAAE,CAAC,CACV,UAAU,CAAE,MAAM,AACnB,CAAC,AAEE,MAAM,AAAC,YAAY,MAAM,CAAC,AAAC,CAAC,AAC5B,CAAC,AAEJ,aAAa,eAAC,CAAC,AACd,SAAS,CAAE,CAAC,CACZ,OAAO,CAAE,CAAC,CAAC,IAAI,AAChB,CAAC,AAED,CAAC,eAAC,CAAC,AACF,UAAU,CAAE,MAAM,AACnB,CAAC,AAED,EAAE,eAAC,CAAC,AACH,UAAU,CAAE,MAAM,CAClB,MAAM,CAAE,IAAI,CAAC,IAAI,CAAC,IAAI,AACvB,CAAC,AAED,QAAQ,eAAC,CAAC,AACT,MAAM,CAAE,IAAI,CAAC,IAAI,CAAC,CAAC,AACpB,CAAC,AAEO,SAAS,AAAE,CAAC,AACnB,cAAc,CAAE,IAAI,AACrB,CAAC,AAED,cAAc,eAAC,CAAC,AACf,OAAO,CAAE,IAAI,CAAC,UAAU,AACzB,CAAC,AAED,gBAAgB,eAAC,CAAC,AACjB,KAAK,CAAE,IAAI,CACX,UAAU,CAAE,MAAM,CAClB,MAAM,CAAE,GAAG,CAAC,CAAC,CAAC,IAAI,AACnB,CAAC,AAED,iBAAiB,eAAC,CAAC,AAClB,KAAK,CAAE,IAAI,CACX,OAAO,CAAE,YAAY,AACtB,CAAC,AAED,MAAM,eAAC,CAAC,AACP,KAAK,CAAE,IAAI,CACX,UAAU,CAAE,MAAM,CAClB,UAAU,CAAE,MAAM,CAClB,KAAK,CAAE,IAAI,AACZ,CAAC"}`
};
var TransactionsPage = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let filteredTransactions;
  let displayTransactions;
  let top;
  let { masterOffset = 0, show, playersInfo, query, queryPage, transactions, currentManagers, stale, perPage: perPage2, postUpdate = false } = $$props;
  let page = queryPage || 0;
  const refreshTransactions = async () => {
    const newTransactions = await getLeagueTransactions(false, true);
    transactions = newTransactions.transactions;
    currentManagers = newTransactions.currentManagers;
  };
  if (stale) {
    refreshTransactions();
  }
  let players2 = playersInfo.players;
  const refreshPlayers = async () => {
    const newPlayersInfo = await loadPlayers(true);
    players2 = newPlayersInfo.players;
  };
  if (playersInfo.stale) {
    refreshPlayers();
  }
  let subsetTransactions = [];
  let totalTransactions = 0;
  const setFilter = (filterBy, transactions2) => {
    if (filterBy == "both") {
      return transactions2;
    } else {
      return transactions2.filter((transaction) => transaction.type == filterBy);
    }
  };
  const setQuery = (query2, filteredTransactions2) => {
    if (!filteredTransactions2) {
      return [];
    }
    if (query2 && query2.trim() != "") {
      subsetTransactions = filteredTransactions2.filter((transaction) => checkForQuery(transaction));
      totalTransactions = subsetTransactions.length;
    } else {
      subsetTransactions = filteredTransactions2;
      totalTransactions = subsetTransactions.length;
    }
    const start = page * perPage2;
    const end = (page + 1) * perPage2;
    return subsetTransactions.slice(start, end);
  };
  const changePage = (dest, pageChange = false) => {
    if (queryPage == dest && pageChange)
      return;
    page = dest;
    if (dest > filteredTransactions.length / perPage2 || dest < 0) {
      page = 0;
    }
    displayTransactions = setQuery(query, filteredTransactions);
    if (postUpdate) {
      setTimeout(() => {
        goto(`/transactions?show=${show}&query=${query}&page=${page + 1}`, { noscroll: true, keepfocus: true });
      }, 800);
    }
  };
  const checkMatch = (query2, name) => {
    const nameMatch = (0, import_fuzzyjs.match)(query2, name);
    if (nameMatch.match && nameMatch.score > 0) {
      nameMatch.score;
      return true;
    }
  };
  const checkForQuery = (transaction) => {
    const moves = transaction.moves;
    for (const move of moves) {
      for (const col of move) {
        if (!(col == null ? void 0 : col.player))
          continue;
        return checkMatch(query, `${players2[col.player].fn} ${players2[col.player].ln}`);
      }
    }
    return false;
  };
  let el;
  if ($$props.masterOffset === void 0 && $$bindings.masterOffset && masterOffset !== void 0)
    $$bindings.masterOffset(masterOffset);
  if ($$props.show === void 0 && $$bindings.show && show !== void 0)
    $$bindings.show(show);
  if ($$props.playersInfo === void 0 && $$bindings.playersInfo && playersInfo !== void 0)
    $$bindings.playersInfo(playersInfo);
  if ($$props.query === void 0 && $$bindings.query && query !== void 0)
    $$bindings.query(query);
  if ($$props.queryPage === void 0 && $$bindings.queryPage && queryPage !== void 0)
    $$bindings.queryPage(queryPage);
  if ($$props.transactions === void 0 && $$bindings.transactions && transactions !== void 0)
    $$bindings.transactions(transactions);
  if ($$props.currentManagers === void 0 && $$bindings.currentManagers && currentManagers !== void 0)
    $$bindings.currentManagers(currentManagers);
  if ($$props.stale === void 0 && $$bindings.stale && stale !== void 0)
    $$bindings.stale(stale);
  if ($$props.perPage === void 0 && $$bindings.perPage && perPage2 !== void 0)
    $$bindings.perPage(perPage2);
  if ($$props.postUpdate === void 0 && $$bindings.postUpdate && postUpdate !== void 0)
    $$bindings.postUpdate(postUpdate);
  $$result.css.add(css$s);
  let $$settled;
  let $$rendered;
  do {
    $$settled = true;
    filteredTransactions = setFilter(show, transactions);
    displayTransactions = setQuery(query, filteredTransactions);
    {
      changePage(page, true);
    }
    {
      setQuery(query);
    }
    top = (el == null ? void 0 : el.getBoundingClientRect()) ? el == null ? void 0 : el.getBoundingClientRect().top : 0;
    $$rendered = `<div class="${"transactionsParent svelte-1vi4974"}"><div class="${"buttons " + escape(show == "trade" ? "" : "invis-buttons") + " svelte-1vi4974"}">${validate_component(Button_1, "Button").$$render($$result, {
      class: show == "trade" ? "disabled" : "",
      color: "primary",
      variant: show == "trade" ? "raised" : "outlined",
      touch: true
    }, {}, {
      default: () => `${validate_component(CommonLabel, "Label").$$render($$result, {}, {}, { default: () => `Trades` })}`
    })}
		${validate_component(Button_1, "Button").$$render($$result, {
      class: show == "waiver" ? "disabled" : "",
      color: "primary",
      variant: show == "waiver" ? "raised" : "outlined",
      touch: true
    }, {}, {
      default: () => `${validate_component(CommonLabel, "Label").$$render($$result, {}, {}, { default: () => `Waivers` })}`
    })}
		${validate_component(Button_1, "Button").$$render($$result, {
      class: show == "both" ? "disabled" : "",
      color: "primary",
      variant: show == "both" ? "raised" : "outlined",
      touch: true
    }, {}, {
      default: () => `${validate_component(CommonLabel, "Label").$$render($$result, {}, {}, { default: () => `Both` })}`
    })}</div>
	<div class="${"buttons " + escape(show == "waiver" ? "" : "invis-buttons") + " svelte-1vi4974"}">${validate_component(Button_1, "Button").$$render($$result, {
      class: show == "trade" ? "disabled" : "",
      color: "primary",
      variant: show == "trade" ? "raised" : "outlined",
      touch: true
    }, {}, {
      default: () => `${validate_component(CommonLabel, "Label").$$render($$result, {}, {}, { default: () => `Trades` })}`
    })}
		${validate_component(Button_1, "Button").$$render($$result, {
      class: show == "waiver" ? "disabled" : "",
      color: "primary",
      variant: show == "waiver" ? "raised" : "outlined",
      touch: true
    }, {}, {
      default: () => `${validate_component(CommonLabel, "Label").$$render($$result, {}, {}, { default: () => `Waivers` })}`
    })}
		${validate_component(Button_1, "Button").$$render($$result, {
      class: show == "both" ? "disabled" : "",
      color: "primary",
      variant: show == "both" ? "raised" : "outlined",
      touch: true
    }, {}, {
      default: () => `${validate_component(CommonLabel, "Label").$$render($$result, {}, {}, { default: () => `Both` })}`
    })}</div>
	<div class="${"buttons " + escape(show == "both" ? "" : "invis-buttons") + " svelte-1vi4974"}">${validate_component(Button_1, "Button").$$render($$result, {
      class: show == "trade" ? "disabled" : "",
      color: "primary",
      variant: show == "trade" ? "raised" : "outlined",
      touch: true
    }, {}, {
      default: () => `${validate_component(CommonLabel, "Label").$$render($$result, {}, {}, { default: () => `Trades` })}`
    })}
		${validate_component(Button_1, "Button").$$render($$result, {
      class: show == "waiver" ? "disabled" : "",
      color: "primary",
      variant: show == "waiver" ? "raised" : "outlined",
      touch: true
    }, {}, {
      default: () => `${validate_component(CommonLabel, "Label").$$render($$result, {}, {}, { default: () => `Waivers` })}`
    })}
		${validate_component(Button_1, "Button").$$render($$result, {
      class: show == "both" ? "disabled" : "",
      color: "primary",
      variant: show == "both" ? "raised" : "outlined",
      touch: true
    }, {}, {
      default: () => `${validate_component(CommonLabel, "Label").$$render($$result, {}, {}, { default: () => `Both` })}`
    })}</div>
	<div class="${"searchContainer svelte-1vi4974"}"><span class="${"clearPlaceholder svelte-1vi4974"}"></span>
		${validate_component(Textfield, "Textfield").$$render($$result, {
      class: "shaped-outlined",
      variant: "outlined",
      label: "Search for a player...",
      value: query
    }, {
      value: ($$value) => {
        query = $$value;
        $$settled = false;
      }
    }, {
      leadingIcon: () => `${validate_component(Icon, "Icon").$$render($$result, {
        class: "material-icons",
        slot: "leadingIcon"
      }, {}, { default: () => `search` })}`
    })}
		${query.length > 0 ? `${validate_component(IconButton, "IconButton").$$render($$result, { class: "material-icons" }, {}, { default: () => `clear` })}` : `<span class="${"clearPlaceholder svelte-1vi4974"}"></span>`}</div>

	<div class="${"transactions svelte-1vi4974"}"${add_attribute("this", el, 0)}>${show == "both" ? `
			<h5 class="${"svelte-1vi4974"}">Recent Transactions</h5>` : `${show == "trade" ? `
			<h5 class="${"svelte-1vi4974"}">Recent Trades</h5>` : `
			<h5 class="${"svelte-1vi4974"}">Recent Waivers</h5>`}`}

		${validate_component(Pagination, "Pagination").$$render($$result, {
      perPage: perPage2,
      total: totalTransactions,
      target: top,
      scroll: false,
      page
    }, {
      page: ($$value) => {
        page = $$value;
        $$settled = false;
      }
    }, {})}
		<div class="${"transactions-child"}">${each(displayTransactions, (transaction) => `${validate_component(Transaction, "Transaction").$$render($$result, {
      players: players2,
      transaction,
      masterOffset: masterOffset + 15,
      currentManagers
    }, {}, {})}`)}</div>
		${validate_component(Pagination, "Pagination").$$render($$result, {
      perPage: perPage2,
      total: totalTransactions,
      target: top,
      scroll: true,
      page
    }, {
      page: ($$value) => {
        page = $$value;
        $$settled = false;
      }
    }, {})}</div>

	${totalTransactions == 0 ? `${show == "trade" ? `<p class="${"empty svelte-1vi4974"}">${escape(query.trim() != "" ? "No trades match your search" : "Nobody has made any trades yet... that's just sad")}</p>` : `${show == "waiver" ? `<p class="${"empty svelte-1vi4974"}">${escape(query.trim() != "" ? "No waivers match your search" : "Nobody has made any waiver wire moves yet... that's just sad")}</p>` : `<p class="${"empty svelte-1vi4974"}">${escape(query.trim() != "" ? "No transactions match your search" : "Nobody has made any moves yet... that's just sad")}</p>`}`}` : ``}</div>`;
  } while (!$$settled);
  return $$rendered;
});
var css$r = {
  code: ".message.svelte-kb9n9i{display:block;width:85%;max-width:500px;margin:80px auto}.buttonHolder.svelte-kb9n9i{display:flex;flex-direction:column;align-items:center;margin:3em 0}",
  map: `{"version":3,"file":"MatchupsAndBrackets.svelte","sources":["MatchupsAndBrackets.svelte"],"sourcesContent":["\\n<script>\\n\\timport LinearProgress from '@smui/linear-progress';\\n\\timport MatchupWeeks from './MatchupWeeks.svelte';\\n\\timport Brackets from './Brackets.svelte';\\n    import Button, { Group, Label } from '@smui/button';\\n    import { goto } from '$app/navigation';\\n    import { onMount } from 'svelte';\\n    import { loadPlayers } from '$lib/utils/helper';\\n\\n\\texport let queryWeek, matchupsData, bracketsData, playersData;\\n\\n    let players, matchupWeeks, year, week, regularSeasonLength, brackets;\\n\\n    let loading = true;\\n\\n    onMount(async () => {\\n        brackets = await bracketsData;\\n        const matchupsInfo = await matchupsData;\\n        matchupWeeks = matchupsInfo.matchupWeeks;\\n        year = matchupsInfo.year;\\n        week = matchupsInfo.week;\\n        regularSeasonLength = matchupsInfo.regularSeasonLength;\\n        const playersInfo = await playersData;\\n        players = playersInfo.players;\\n        loading = false;\\n\\n        if(playersInfo.stale) {\\n            const newPlayersInfo = await loadPlayers(true);\\n            players = newPlayersInfo.players;\\n        }\\n    });\\n\\n    const changeSelection = (s) => {\\n        if(s == 'regular') {\\n            queryWeek = 1;\\n            goto(\`/matchups?week=1\`, {noscroll: true});\\n        } else if(selection == 'regular') {\\n            queryWeek = 99;\\n            goto(\`/matchups?week=99\`, {noscroll: true});\\n        }\\n        selection = s;\\n    }\\n\\n    let selection = 'regular';\\n    let playoffWeek\\n<\/script>\\n\\n<style>\\n    .message {\\n        display: block;\\n        width: 85%;\\n        max-width: 500px;\\n        margin: 80px auto;\\n    }\\n\\n    .buttonHolder {\\n        display: flex;\\n        flex-direction: column;\\n        align-items: center;\\n        margin: 3em 0;\\n    }\\n</style>\\n\\n\\n\\n{#if loading}\\n    <!-- promise is pending -->\\n    <div class=\\"message\\">\\n        <p>Loading league matchups...</p>\\n        <LinearProgress indeterminate />\\n    </div>\\n{:else}\\n    {#if matchupWeeks.length}\\n        <div class=\\"buttonHolder\\">\\n            <Group variant=\\"outlined\\">\\n                <!-- Regular Season -->\\n                <Button class=\\"selectionButtons\\" on:click={() => changeSelection('regular')} variant=\\"{selection == 'regular' ? \\"raised\\" : \\"outlined\\"}\\">\\n                    <Label>Regular Season</Label>\\n                </Button>\\n                <!-- Championship Bracket -->\\n                <Button class=\\"selectionButtons\\" on:click={() => changeSelection('champions')} variant=\\"{selection == 'champions' || selection == 'losers' ? \\"raised\\" : \\"outlined\\"}\\">\\n                    <Label>Playoffs</Label>\\n                </Button>\\n            </Group>\\n            {#if selection == 'champions' || selection == 'losers'}\\n                <Group variant=\\"outlined\\">\\n                    <!-- Championship Bracket -->\\n                    <Button class=\\"selectionButtons\\" on:click={() => changeSelection('champions')} variant=\\"{selection == 'champions' ? \\"raised\\" : \\"outlined\\"}\\">\\n                        <Label>Champions' Bracket</Label>\\n                    </Button>\\n                    <!-- Losers Bracket -->\\n                    <Button class=\\"selectionButtons\\" on:click={() => changeSelection('losers')} variant=\\"{selection == 'losers' ? \\"raised\\" : \\"outlined\\"}\\">\\n                        <Label>Losers' Bracket</Label>\\n                    </Button>\\n                </Group>\\n            {/if}\\n        </div>\\n        {#if selection == 'regular'}\\n            <MatchupWeeks {players} {queryWeek} {matchupWeeks} {regularSeasonLength} {year} {week} bind:selection={selection} />\\n        {/if}\\n    {:else}\\n        <div class=\\"message\\">\\n            <p>No upcoming matchups...</p>\\n        </div>\\n    {/if}\\n    <!-- {promise has processed -->\\n    {#if brackets.champs.bracket[0][0][0].points && (selection == 'champions' || selection == 'losers')}\\n        <Brackets {queryWeek} {players} {brackets} bind:selection={selection}/>\\n    {/if}\\n{/if}"],"names":[],"mappings":"AAiDI,QAAQ,cAAC,CAAC,AACN,OAAO,CAAE,KAAK,CACd,KAAK,CAAE,GAAG,CACV,SAAS,CAAE,KAAK,CAChB,MAAM,CAAE,IAAI,CAAC,IAAI,AACrB,CAAC,AAED,aAAa,cAAC,CAAC,AACX,OAAO,CAAE,IAAI,CACb,cAAc,CAAE,MAAM,CACtB,WAAW,CAAE,MAAM,CACnB,MAAM,CAAE,GAAG,CAAC,CAAC,AACjB,CAAC"}`
};
var MatchupsAndBrackets = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let { queryWeek, matchupsData, bracketsData, playersData } = $$props;
  if ($$props.queryWeek === void 0 && $$bindings.queryWeek && queryWeek !== void 0)
    $$bindings.queryWeek(queryWeek);
  if ($$props.matchupsData === void 0 && $$bindings.matchupsData && matchupsData !== void 0)
    $$bindings.matchupsData(matchupsData);
  if ($$props.bracketsData === void 0 && $$bindings.bracketsData && bracketsData !== void 0)
    $$bindings.bracketsData(bracketsData);
  if ($$props.playersData === void 0 && $$bindings.playersData && playersData !== void 0)
    $$bindings.playersData(playersData);
  $$result.css.add(css$r);
  let $$settled;
  let $$rendered;
  do {
    $$settled = true;
    $$rendered = `${`
    <div class="${"message svelte-kb9n9i"}"><p>Loading league matchups...</p>
        ${validate_component(LinearProgress, "LinearProgress").$$render($$result, { indeterminate: true }, {}, {})}</div>`}`;
  } while (!$$settled);
  return $$rendered;
});
var css$q = {
  code: ".draftCell{position:relative}.changedHands{background-color:var(--draftSwapped)}.draftPos.svelte-1a7exod{position:absolute;top:0.3em;left:0.3em;font-style:italic;color:#aaa}.draftPosPrev.svelte-1a7exod{position:absolute;top:0.1em;left:0.1em;font-style:italic;color:#444}.newOwner.svelte-1a7exod{font-style:italic;color:#444;text-align:center;white-space:break-spaces;line-height:1.2em}.prevQB{background-color:var(--QBfade)}.prevWR{background-color:var(--WRfade)}.prevRB{background-color:var(--RBfade)}.prevTE{background-color:var(--TEfade)}.prevK{background-color:var(--Kfade)}.prevDEF{background-color:var(--DEfadeFfade)}.prevCB{background-color:var(--CBfade)}.prevSS{background-color:var(--SSfade)}.prevFS{background-color:var(--FSfade)}.prevDE{background-color:var(--DEfade)}.prevDL{background-color:var(--DLfade)}.prevLB{background-color:var(--LBfade)}.playerAvatar.svelte-1a7exod{display:inline-block;position:absolute;transform:translate(-50%, -50%);left:50%;top:45%;height:25px;width:25px;background-position:center;border-radius:100%;background-repeat:no-repeat;background-size:auto 25px}.name.svelte-1a7exod{display:block;width:100%;text-align:center;position:absolute;left:0;white-space:break-spaces;line-height:1em;bottom:0.5em;color:rgba(0, 0, 0, 0.87)}",
  map: '{"version":3,"file":"DraftRow.svelte","sources":["DraftRow.svelte"],"sourcesContent":["<script>\\n  \\timport {Row, Cell } from \'@smui/data-table\';\\n    export let draftRow, draftType, row, reversalRound, previous=false;\\n<\/script>\\n\\n<style>\\n    :global(.draftCell) {\\n        position: relative;\\n    }\\n\\n    :global(.changedHands) {\\n        background-color: var(--draftSwapped);\\n    }\\n\\n    .draftPos {\\n        position: absolute;\\n        top: 0.3em;\\n        left: 0.3em;\\n        font-style: italic;\\n        color: #aaa;\\n    }\\n\\n    .draftPosPrev {\\n        position: absolute;\\n        top: 0.1em;\\n        left: 0.1em;\\n        font-style: italic;\\n        color: #444;\\n    }\\n\\n    .newOwner {\\n        font-style: italic;\\n        color: #444;\\n        text-align: center;\\n        white-space: break-spaces;\\n        line-height: 1.2em;\\n    }\\n\\n\\t:global(.prevQB) {\\n\\t\\tbackground-color: var(--QBfade);\\n\\t}\\n\\n\\t:global(.prevWR) {\\n\\t\\tbackground-color: var(--WRfade);\\n\\t}\\n\\n\\t:global(.prevRB) {\\n\\t\\tbackground-color: var(--RBfade);\\n\\t}\\n\\n\\t:global(.prevTE) {\\n\\t\\tbackground-color: var(--TEfade);\\n\\t}\\n\\n\\t:global(.prevK) {\\n\\t\\tbackground-color: var(--Kfade);\\n\\t}\\n\\n\\t:global(.prevDEF) {\\n\\t\\tbackground-color: var(--DEfadeFfade);\\n\\t}\\n\\n    :global(.prevCB) {\\n        background-color: var(--CBfade);\\n    }\\n\\n    :global(.prevSS) {\\n        background-color: var(--SSfade);\\n    }\\n\\n    :global(.prevFS) {\\n        background-color: var(--FSfade);\\n    }\\n\\n    :global(.prevDE) {\\n        background-color: var(--DEfade);\\n    }\\n\\n    :global(.prevDL) {\\n        background-color: var(--DLfade);\\n    }\\n\\n    :global(.prevLB) {\\n        background-color: var(--LBfade);\\n    }\\n\\n\\t.playerAvatar {\\n\\t\\tdisplay: inline-block;\\n        position: absolute;\\n        transform: translate(-50%, -50%);\\n        left: 50%;\\n        top: 45%;\\n\\t\\theight: 25px;\\n\\t\\twidth: 25px;\\n\\t\\tbackground-position: center;\\n\\t\\tborder-radius: 100%;\\n\\t\\tbackground-repeat: no-repeat;\\n\\t\\tbackground-size: auto 25px;\\n\\t}\\n\\n    .name {\\n        display: block;\\n        width: 100%;\\n        text-align: center;\\n        position: absolute;\\n        left: 0;\\n        white-space: break-spaces;\\n        line-height: 1em;\\n        bottom: 0.5em;\\n        color: rgba(0, 0, 0, 0.87);\\n    }\\n</style>\\n\\n<Row>\\n    {#each draftRow as draftCol, col}\\n        {#if !previous || draftCol}\\n            <Cell class=\\"draftCell{draftCol ? \' changedHands\' : \'\'}{previous ? ` prev${draftCol.player.position}` : \'\'}\\">\\n                <span class=\\"draftPos{previous ? \\"Prev\\" : \\"\\"}\\">\\n                    {#if draftType == \\"auction\\" && previous}\\n                        ${draftCol.player?.amount}\\n                    {:else if draftType == \\"snake\\" && !reversalRound}\\n                        {row}.{row % 2 == 0 ? draftRow.length - col : col + 1}{draftCol?.newOwner ? ` ${draftCol.newOwner}` : \'\'}\\n                    {:else if draftType == \\"snake\\" && reversalRound}\\n                        {#if (row < reversalRound && row % 2 == 0) || (row >= reversalRound && row % 2 == 1)}\\n                            {row}.{draftRow.length - col}\\n                        {:else}\\n                            {row}.{col + 1}\\n                        {/if}\\n                        {draftCol?.newOwner ? ` ${draftCol.newOwner}` : \'\'}\\n                    {:else}\\n                        {#if !reversalRound || row < reversalRound}\\n                            {row}.{col+1}{draftCol?.newOwner ? ` ${draftCol.newOwner}` : \'\'}\\n                        {:else}\\n                            {row}.{draftRow.length - col}{draftCol?.newOwner ? ` ${draftCol.newOwner}` : \'\'}\\n                        {/if}\\n                    {/if}\\n                </span>\\n                {#if draftCol && !previous}\\n                    <div class=\\"newOwner\\">{draftCol}</div>\\n                {/if}\\n                {#if previous}\\n                    <div class=\\"playerAvatar\\" style=\\"{draftCol.player.avatar}\\" />\\n                    <br />\\n                    <div class=\\"name\\">{draftCol.player.name}{draftCol.player.position == \\"DEF\\" ? \\"\\" : ` (${draftCol.player.team})`}</div>\\n                {/if}\\n            </Cell>\\n        {/if}\\n    {/each}\\n</Row>"],"names":[],"mappings":"AAMY,UAAU,AAAE,CAAC,AACjB,QAAQ,CAAE,QAAQ,AACtB,CAAC,AAEO,aAAa,AAAE,CAAC,AACpB,gBAAgB,CAAE,IAAI,cAAc,CAAC,AACzC,CAAC,AAED,SAAS,eAAC,CAAC,AACP,QAAQ,CAAE,QAAQ,CAClB,GAAG,CAAE,KAAK,CACV,IAAI,CAAE,KAAK,CACX,UAAU,CAAE,MAAM,CAClB,KAAK,CAAE,IAAI,AACf,CAAC,AAED,aAAa,eAAC,CAAC,AACX,QAAQ,CAAE,QAAQ,CAClB,GAAG,CAAE,KAAK,CACV,IAAI,CAAE,KAAK,CACX,UAAU,CAAE,MAAM,CAClB,KAAK,CAAE,IAAI,AACf,CAAC,AAED,SAAS,eAAC,CAAC,AACP,UAAU,CAAE,MAAM,CAClB,KAAK,CAAE,IAAI,CACX,UAAU,CAAE,MAAM,CAClB,WAAW,CAAE,YAAY,CACzB,WAAW,CAAE,KAAK,AACtB,CAAC,AAEI,OAAO,AAAE,CAAC,AACjB,gBAAgB,CAAE,IAAI,QAAQ,CAAC,AAChC,CAAC,AAEO,OAAO,AAAE,CAAC,AACjB,gBAAgB,CAAE,IAAI,QAAQ,CAAC,AAChC,CAAC,AAEO,OAAO,AAAE,CAAC,AACjB,gBAAgB,CAAE,IAAI,QAAQ,CAAC,AAChC,CAAC,AAEO,OAAO,AAAE,CAAC,AACjB,gBAAgB,CAAE,IAAI,QAAQ,CAAC,AAChC,CAAC,AAEO,MAAM,AAAE,CAAC,AAChB,gBAAgB,CAAE,IAAI,OAAO,CAAC,AAC/B,CAAC,AAEO,QAAQ,AAAE,CAAC,AAClB,gBAAgB,CAAE,IAAI,aAAa,CAAC,AACrC,CAAC,AAEU,OAAO,AAAE,CAAC,AACd,gBAAgB,CAAE,IAAI,QAAQ,CAAC,AACnC,CAAC,AAEO,OAAO,AAAE,CAAC,AACd,gBAAgB,CAAE,IAAI,QAAQ,CAAC,AACnC,CAAC,AAEO,OAAO,AAAE,CAAC,AACd,gBAAgB,CAAE,IAAI,QAAQ,CAAC,AACnC,CAAC,AAEO,OAAO,AAAE,CAAC,AACd,gBAAgB,CAAE,IAAI,QAAQ,CAAC,AACnC,CAAC,AAEO,OAAO,AAAE,CAAC,AACd,gBAAgB,CAAE,IAAI,QAAQ,CAAC,AACnC,CAAC,AAEO,OAAO,AAAE,CAAC,AACd,gBAAgB,CAAE,IAAI,QAAQ,CAAC,AACnC,CAAC,AAEJ,aAAa,eAAC,CAAC,AACd,OAAO,CAAE,YAAY,CACf,QAAQ,CAAE,QAAQ,CAClB,SAAS,CAAE,UAAU,IAAI,CAAC,CAAC,IAAI,CAAC,CAChC,IAAI,CAAE,GAAG,CACT,GAAG,CAAE,GAAG,CACd,MAAM,CAAE,IAAI,CACZ,KAAK,CAAE,IAAI,CACX,mBAAmB,CAAE,MAAM,CAC3B,aAAa,CAAE,IAAI,CACnB,iBAAiB,CAAE,SAAS,CAC5B,eAAe,CAAE,IAAI,CAAC,IAAI,AAC3B,CAAC,AAEE,KAAK,eAAC,CAAC,AACH,OAAO,CAAE,KAAK,CACd,KAAK,CAAE,IAAI,CACX,UAAU,CAAE,MAAM,CAClB,QAAQ,CAAE,QAAQ,CAClB,IAAI,CAAE,CAAC,CACP,WAAW,CAAE,YAAY,CACzB,WAAW,CAAE,GAAG,CAChB,MAAM,CAAE,KAAK,CACb,KAAK,CAAE,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,AAC9B,CAAC"}'
};
var DraftRow = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let { draftRow, draftType, row, reversalRound, previous = false } = $$props;
  if ($$props.draftRow === void 0 && $$bindings.draftRow && draftRow !== void 0)
    $$bindings.draftRow(draftRow);
  if ($$props.draftType === void 0 && $$bindings.draftType && draftType !== void 0)
    $$bindings.draftType(draftType);
  if ($$props.row === void 0 && $$bindings.row && row !== void 0)
    $$bindings.row(row);
  if ($$props.reversalRound === void 0 && $$bindings.reversalRound && reversalRound !== void 0)
    $$bindings.reversalRound(reversalRound);
  if ($$props.previous === void 0 && $$bindings.previous && previous !== void 0)
    $$bindings.previous(previous);
  $$result.css.add(css$q);
  return `${validate_component(Row, "Row").$$render($$result, {}, {}, {
    default: () => `${each(draftRow, (draftCol, col) => `${!previous || draftCol ? `${validate_component(Cell, "Cell").$$render($$result, {
      class: "draftCell" + (draftCol ? " changedHands" : "") + (previous ? ` prev${draftCol.player.position}` : "")
    }, {}, {
      default: () => {
        var _a;
        return `<span class="${"draftPos" + escape(previous ? "Prev" : "") + " svelte-1a7exod"}">${draftType == "auction" && previous ? `$${escape((_a = draftCol.player) == null ? void 0 : _a.amount)}` : `${draftType == "snake" && !reversalRound ? `${escape(row)}.${escape(row % 2 == 0 ? draftRow.length - col : col + 1)}${escape((draftCol == null ? void 0 : draftCol.newOwner) ? ` ${draftCol.newOwner}` : "")}` : `${draftType == "snake" && reversalRound ? `${row < reversalRound && row % 2 == 0 || row >= reversalRound && row % 2 == 1 ? `${escape(row)}.${escape(draftRow.length - col)}` : `${escape(row)}.${escape(col + 1)}`}
                        ${escape((draftCol == null ? void 0 : draftCol.newOwner) ? ` ${draftCol.newOwner}` : "")}` : `${!reversalRound || row < reversalRound ? `${escape(row)}.${escape(col + 1)}${escape((draftCol == null ? void 0 : draftCol.newOwner) ? ` ${draftCol.newOwner}` : "")}` : `${escape(row)}.${escape(draftRow.length - col)}${escape((draftCol == null ? void 0 : draftCol.newOwner) ? ` ${draftCol.newOwner}` : "")}`}`}`}`}</span>
                ${draftCol && !previous ? `<div class="${"newOwner svelte-1a7exod"}">${escape(draftCol)}</div>` : ``}
                ${previous ? `<div class="${"playerAvatar svelte-1a7exod"}"${add_attribute("style", draftCol.player.avatar, 0)}></div>
                    <br>
                    <div class="${"name svelte-1a7exod"}">${escape(draftCol.player.name)}${escape(draftCol.player.position == "DEF" ? "" : ` (${draftCol.player.team})`)}</div>` : ``}
            `;
      }
    })}` : ``}`)}`
  })}`;
});
var css$p = {
  code: ".accuracy.svelte-uyxuaj{display:block;width:80%;max-width:800px;margin:2em auto 3em}.accuracyText.svelte-uyxuaj{font-size:0.7em;color:#666}.disclaimer.svelte-uyxuaj{font-style:italic;color:#888}.draftBoard{display:block;width:95%;margin:2em auto 3em;overflow-x:auto}.draftTeam{font-size:0.8em;text-align:center;padding:5px 0;background-color:var(--transactHeader);white-space:break-spaces;line-height:1em;height:5em;vertical-align:initial}.draftBoard table{border-collapse:collapse;table-layout:fixed;width:100%;min-width:1200px}.draftBoard td{border-right:1px solid #ddd;height:7em;font-size:0.7em}.draftBoard td:last-of-type{border-right:none}.avatar.svelte-uyxuaj{border-radius:50%;height:30px;width:30px;margin:0.4em 0;border:0.25px solid #777}.clickable.svelte-uyxuaj{cursor:pointer}.curDraftName{color:#888;font-size:0.7em;font-style:italic}",
  map: `{"version":3,"file":"Draft.svelte","sources":["Draft.svelte"],"sourcesContent":["<script>\\n  \\timport DataTable, { Head, Body, Row, Cell } from '@smui/data-table';\\n\\timport LinearProgress from '@smui/linear-progress';\\n    import { onMount } from 'svelte';\\n    import DraftRow from './DraftRow.svelte';\\n    import { cleanName, gotoManager } from '$lib/utils/helper'\\n    \\n    export let draftData, previous = false;\\n\\n    const {draftOrder, draft, currentManagers, originalManagers, accuracy, reversalRound, draftType} = draftData;\\n\\n    let progress = 0;\\n    let closed = false;\\n\\n    onMount(loadAccuracy);\\n\\n    function loadAccuracy() {\\n        if(!accuracy) return;\\n        let timer;\\n        progress = 0;\\n        closed = false;\\n        clearInterval(timer);\\n        timer = setInterval(() => {\\n            progress += 0.01;\\n            if (progress >= accuracy) {\\n                clearInterval(timer);\\n                if (progress >= 1) {\\n                    progress = 1;\\n                    closed = true;\\n                }\\n            }\\n\\n        }, 100);\\n    }\\n<\/script>\\n\\n<style>\\n    .accuracy {\\n        display: block;\\n        width: 80%;\\n        max-width: 800px;\\n        margin: 2em auto 3em;\\n    }\\n\\n    .accuracyText {\\n        font-size: 0.7em;\\n        color: #666;\\n    }\\n\\n    .disclaimer {\\n        font-style: italic;\\n        color: #888;\\n    }\\n\\n    :global(.draftBoard) {\\n        display: block;\\n        width: 95%;\\n        margin: 2em auto 3em;\\n        overflow-x: auto;\\n    }\\n\\n\\t:global(.draftTeam) {\\n        font-size: 0.8em;\\n\\t\\ttext-align: center;\\n\\t\\tpadding: 5px 0;\\n\\t\\tbackground-color: var(--transactHeader);\\n        white-space: break-spaces;\\n        line-height: 1em;\\n        height: 5em;\\n        vertical-align: initial;\\n\\t}\\n\\n\\t:global(.draftBoard table) {\\n        border-collapse: collapse;\\n        table-layout: fixed;\\n        width: 100%;\\n        min-width: 1200px;\\n\\t}\\n\\n    :global(.draftBoard td) {\\n        border-right: 1px solid #ddd;\\n        height: 7em;\\n        font-size: 0.7em;\\n    }\\n\\n    :global(.draftBoard td:last-of-type) {\\n        border-right: none;\\n    }\\n\\n\\t.avatar {\\n\\t\\tborder-radius: 50%;\\n        height: 30px;\\n        width: 30px;\\n        margin: 0.4em 0;\\n\\t\\tborder: 0.25px solid #777;\\n\\t}\\n\\n    .clickable {\\n        cursor: pointer;\\n    }\\n\\t\\n\\t:global(.curDraftName) {\\n        color: #888;\\n        font-size: 0.7em;\\n        font-style: italic;\\n    }\\n</style>\\n\\n{#if accuracy  && !closed}\\n    <div class=\\"accuracy\\">\\n        <div class=\\"accuracyText\\">\\n            Upcomig draft order accuracy: {parseInt(progress*100)}%\\n            <span class=\\"disclaimer\\">(accuracy will improve as the regular season progresses)</span>\\n        </div>\\n        <LinearProgress {progress} {closed} />\\n    </div>\\n{/if}\\n\\n<DataTable class=\\"draftBoard\\">\\n    <Head>\\n        <Row>\\n            {#each draftOrder as draftPosition}\\n                {#if draftPosition}\\n                    <Cell class=\\"draftTeam\\">\\n                        <img class=\\"avatar clickable\\" on:click={() => gotoManager(draftPosition)} src=\\"{originalManagers[draftPosition].avatar}\\" alt=\\"{originalManagers[draftPosition].name} avatar\\"/>\\n                        <br />\\n                        <span class=\\"clickable\\" on:click={() => gotoManager(draftPosition)}>{originalManagers[draftPosition].name}{@html currentManagers && cleanName(currentManagers[draftPosition].name) != cleanName(originalManagers[draftPosition].name) ? \`<br /><span class=\\"curDraftName\\">(\${currentManagers[draftPosition].name})</span>\` : ''}</span>\\n                    </Cell>\\n                {/if}\\n            {/each}\\n        </Row>\\n    </Head>\\n    <Body>\\n        {#each draft as draftRow, row}\\n            <DraftRow {draftRow} row={row + 1} {previous} {reversalRound} {draftType} />\\n        {/each}\\n    </Body>\\n</DataTable>\\n\\n"],"names":[],"mappings":"AAqCI,SAAS,cAAC,CAAC,AACP,OAAO,CAAE,KAAK,CACd,KAAK,CAAE,GAAG,CACV,SAAS,CAAE,KAAK,CAChB,MAAM,CAAE,GAAG,CAAC,IAAI,CAAC,GAAG,AACxB,CAAC,AAED,aAAa,cAAC,CAAC,AACX,SAAS,CAAE,KAAK,CAChB,KAAK,CAAE,IAAI,AACf,CAAC,AAED,WAAW,cAAC,CAAC,AACT,UAAU,CAAE,MAAM,CAClB,KAAK,CAAE,IAAI,AACf,CAAC,AAEO,WAAW,AAAE,CAAC,AAClB,OAAO,CAAE,KAAK,CACd,KAAK,CAAE,GAAG,CACV,MAAM,CAAE,GAAG,CAAC,IAAI,CAAC,GAAG,CACpB,UAAU,CAAE,IAAI,AACpB,CAAC,AAEI,UAAU,AAAE,CAAC,AACd,SAAS,CAAE,KAAK,CACtB,UAAU,CAAE,MAAM,CAClB,OAAO,CAAE,GAAG,CAAC,CAAC,CACd,gBAAgB,CAAE,IAAI,gBAAgB,CAAC,CACjC,WAAW,CAAE,YAAY,CACzB,WAAW,CAAE,GAAG,CAChB,MAAM,CAAE,GAAG,CACX,cAAc,CAAE,OAAO,AAC9B,CAAC,AAEO,iBAAiB,AAAE,CAAC,AACrB,eAAe,CAAE,QAAQ,CACzB,YAAY,CAAE,KAAK,CACnB,KAAK,CAAE,IAAI,CACX,SAAS,CAAE,MAAM,AACxB,CAAC,AAEU,cAAc,AAAE,CAAC,AACrB,YAAY,CAAE,GAAG,CAAC,KAAK,CAAC,IAAI,CAC5B,MAAM,CAAE,GAAG,CACX,SAAS,CAAE,KAAK,AACpB,CAAC,AAEO,2BAA2B,AAAE,CAAC,AAClC,YAAY,CAAE,IAAI,AACtB,CAAC,AAEJ,OAAO,cAAC,CAAC,AACR,aAAa,CAAE,GAAG,CACZ,MAAM,CAAE,IAAI,CACZ,KAAK,CAAE,IAAI,CACX,MAAM,CAAE,KAAK,CAAC,CAAC,CACrB,MAAM,CAAE,MAAM,CAAC,KAAK,CAAC,IAAI,AAC1B,CAAC,AAEE,UAAU,cAAC,CAAC,AACR,MAAM,CAAE,OAAO,AACnB,CAAC,AAEI,aAAa,AAAE,CAAC,AACjB,KAAK,CAAE,IAAI,CACX,SAAS,CAAE,KAAK,CAChB,UAAU,CAAE,MAAM,AACtB,CAAC"}`
};
var Draft = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let { draftData, previous = false } = $$props;
  const { draftOrder, draft, currentManagers, originalManagers, accuracy, reversalRound, draftType } = draftData;
  let progress = 0;
  let closed = false;
  if ($$props.draftData === void 0 && $$bindings.draftData && draftData !== void 0)
    $$bindings.draftData(draftData);
  if ($$props.previous === void 0 && $$bindings.previous && previous !== void 0)
    $$bindings.previous(previous);
  $$result.css.add(css$p);
  return `${accuracy && !closed ? `<div class="${"accuracy svelte-uyxuaj"}"><div class="${"accuracyText svelte-uyxuaj"}">Upcomig draft order accuracy: ${escape(parseInt(progress * 100))}%
            <span class="${"disclaimer svelte-uyxuaj"}">(accuracy will improve as the regular season progresses)</span></div>
        ${validate_component(LinearProgress, "LinearProgress").$$render($$result, { progress, closed }, {}, {})}</div>` : ``}

${validate_component(DataTable, "DataTable").$$render($$result, { class: "draftBoard" }, {}, {
    default: () => `${validate_component(Head, "Head").$$render($$result, {}, {}, {
      default: () => `${validate_component(Row, "Row").$$render($$result, {}, {}, {
        default: () => `${each(draftOrder, (draftPosition) => `${draftPosition ? `${validate_component(Cell, "Cell").$$render($$result, { class: "draftTeam" }, {}, {
          default: () => `<img class="${"avatar clickable svelte-uyxuaj"}"${add_attribute("src", originalManagers[draftPosition].avatar, 0)} alt="${escape(originalManagers[draftPosition].name) + " avatar"}">
                        <br>
                        <span class="${"clickable svelte-uyxuaj"}">${escape(originalManagers[draftPosition].name)}<!-- HTML_TAG_START -->${currentManagers && cleanName(currentManagers[draftPosition].name) != cleanName(originalManagers[draftPosition].name) ? `<br /><span class="curDraftName">(${currentManagers[draftPosition].name})</span>` : ""}<!-- HTML_TAG_END --></span>
                    `
        })}` : ``}`)}`
      })}`
    })}
    ${validate_component(Body2, "Body").$$render($$result, {}, {}, {
      default: () => `${each(draft, (draftRow, row) => `${validate_component(DraftRow, "DraftRow").$$render($$result, {
        draftRow,
        row: row + 1,
        previous,
        reversalRound,
        draftType
      }, {}, {})}`)}`
    })}`
  })}`;
});
var css$o = {
  code: ".loading.svelte-88vdj{display:block;width:85%;max-width:500px;margin:80px auto}h4.svelte-88vdj{text-align:center}h6.svelte-88vdj{text-align:center}",
  map: `{"version":3,"file":"index.svelte","sources":["index.svelte"],"sourcesContent":["<script>\\n\\timport LinearProgress from '@smui/linear-progress';\\n    import Draft from './Draft.svelte'; \\n\\n    export let upcomingDraftData, previousDraftsData;\\n<\/script>\\n\\n<style>\\n\\t.loading {\\n\\t\\tdisplay: block;\\n\\t\\twidth: 85%;\\n\\t\\tmax-width: 500px;\\n\\t\\tmargin: 80px auto;\\n\\t}\\n\\n    h4 {\\n        text-align: center;\\n    }\\n\\n    h6 {\\n        text-align: center;\\n    }\\n</style>\\n\\n\\n{#await upcomingDraftData }\\n\\t<div class=\\"loading\\">\\n\\t\\t<p>Retrieving upcoming draft...</p>\\n\\t\\t<br />\\n\\t\\t<LinearProgress indeterminate />\\n\\t</div>\\n{:then upcomingDraft }\\n    <h4>Upcoming {upcomingDraft.year} Draft</h4>\\n    <Draft draftData={upcomingDraft} />\\n{:catch error}\\n\\t<!-- promise was rejected -->\\n\\t<p>Something went wrong: {error.message}</p>\\n{/await}\\n\\n\\n{#await previousDraftsData }\\n\\t<hr />\\n\\t<h4>Previous Drafts</h4>\\n\\t<div class=\\"loading\\">\\n\\t\\t<p>Retrieving previous drafts...</p>\\n\\t\\t<br />\\n\\t\\t<LinearProgress indeterminate />\\n\\t</div>\\n{:then previousDrafts }\\n\\t<!-- Don't display anything unless there are previous drafts -->\\n\\t{#if previousDrafts.length}\\n\\t\\t<hr />\\n\\t\\t<h4>Previous Drafts</h4>\\n\\t\\t{#each previousDrafts as previousDraft}\\n\\t\\t\\t<h6>{previousDraft.year} Draft</h6>\\n\\t\\t\\t<Draft draftData={previousDraft} previous={true} />\\n\\t\\t{/each}\\n\\t{/if}\\n{:catch error}\\n\\t<!-- promise was rejected -->\\n\\t<p>Something went wrong: {error.message}</p>\\n{/await}"],"names":[],"mappings":"AAQC,QAAQ,aAAC,CAAC,AACT,OAAO,CAAE,KAAK,CACd,KAAK,CAAE,GAAG,CACV,SAAS,CAAE,KAAK,CAChB,MAAM,CAAE,IAAI,CAAC,IAAI,AAClB,CAAC,AAEE,EAAE,aAAC,CAAC,AACA,UAAU,CAAE,MAAM,AACtB,CAAC,AAED,EAAE,aAAC,CAAC,AACA,UAAU,CAAE,MAAM,AACtB,CAAC"}`
};
var Drafts = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let { upcomingDraftData, previousDraftsData } = $$props;
  if ($$props.upcomingDraftData === void 0 && $$bindings.upcomingDraftData && upcomingDraftData !== void 0)
    $$bindings.upcomingDraftData(upcomingDraftData);
  if ($$props.previousDraftsData === void 0 && $$bindings.previousDraftsData && previousDraftsData !== void 0)
    $$bindings.previousDraftsData(previousDraftsData);
  $$result.css.add(css$o);
  return `${function(__value) {
    if (is_promise(__value)) {
      __value.then(null, noop);
      return `
	<div class="${"loading svelte-88vdj"}"><p>Retrieving upcoming draft...</p>
		<br>
		${validate_component(LinearProgress, "LinearProgress").$$render($$result, { indeterminate: true }, {}, {})}</div>
`;
    }
    return function(upcomingDraft2) {
      return `
    <h4 class="${"svelte-88vdj"}">Upcoming ${escape(upcomingDraft2.year)} Draft</h4>
    ${validate_component(Draft, "Draft").$$render($$result, { draftData: upcomingDraft2 }, {}, {})}
`;
    }(__value);
  }(upcomingDraftData)}


${function(__value) {
    if (is_promise(__value)) {
      __value.then(null, noop);
      return `
	<hr>
	<h4 class="${"svelte-88vdj"}">Previous Drafts</h4>
	<div class="${"loading svelte-88vdj"}"><p>Retrieving previous drafts...</p>
		<br>
		${validate_component(LinearProgress, "LinearProgress").$$render($$result, { indeterminate: true }, {}, {})}</div>
`;
    }
    return function(previousDrafts2) {
      return `
	
	${previousDrafts2.length ? `<hr>
		<h4 class="${"svelte-88vdj"}">Previous Drafts</h4>
		${each(previousDrafts2, (previousDraft) => `<h6 class="${"svelte-88vdj"}">${escape(previousDraft.year)} Draft</h6>
			${validate_component(Draft, "Draft").$$render($$result, { draftData: previousDraft, previous: true }, {}, {})}`)}` : ``}
`;
    }(__value);
  }(previousDraftsData)}`;
});
var xIntervalFont = (width) => {
  if (width > 780) {
    return 1;
  }
  if (width > 650) {
    return 0.9;
  }
  if (width > 570) {
    return 0.7;
  }
  if (width > 460) {
    return 0.6;
  }
  if (width > 420) {
    return 0.5;
  }
  return 0.4;
};
var xIntervalHeight = (width) => {
  if (width > 900) {
    return 160;
  }
  if (width > 780) {
    return 140;
  }
  if (width > 650) {
    return 120;
  }
  if (width > 570) {
    return 100;
  }
  if (width > 460) {
    return 80;
  }
  if (width > 420) {
    return 70;
  }
  if (width > 350) {
    return 60;
  }
  return 56;
};
var barLabelFont = (width) => {
  if (width > 650) {
    return 0.7;
  }
  if (width > 570) {
    return 0.5;
  }
  if (width > 460) {
    return 0.4;
  }
  return 0.3;
};
var labelFont = (width) => {
  if (width > 460) {
    return 1;
  }
  return 0.7;
};
var css$n = {
  code: ".opacity{opacity:0.3}.chartWrapper.svelte-1h9hzg2{background-color:var(--fff);padding:1em 0 0.5em;margin:0 auto;box-shadow:0px 3px 3px -2px var(--boxShadowOne), 0px 3px 4px 0px var(--boxShadowTwo), 0px 1px 8px 0px var(--boxShadowThree)}.barChart.svelte-1h9hzg2{display:block;position:relative;width:100%;height:100%}.barChartInner.svelte-1h9hzg2{display:block;position:absolute;top:0.1em;right:0;border-bottom:1px solid #ccc;border-left:1px solid #ccc}.barLabel.svelte-1h9hzg2{position:absolute;transform:translate(-50%, 0);line-height:1.1em;left:50%;color:#666;bottom:101%;text-align:center}.yLabel.svelte-1h9hzg2{writing-mode:tb-rl;transform:rotate(-180deg);text-align:center}.yIntervals.svelte-1h9hzg2{position:absolute;display:inline-block;top:1em}.yInterval.svelte-1h9hzg2{display:inline-block;position:absolute;width:62px;text-align:right}.xLabel.svelte-1h9hzg2{display:inline-block;right:0;position:absolute;text-align:center;bottom:1%}.xIntervals.svelte-1h9hzg2{position:absolute;display:inline-block;right:0}.xInterval.svelte-1h9hzg2{display:flex;justify-content:flex-end;align-items:center;position:absolute;writing-mode:tb-rl;transform:translate(-50%, 0) rotate(-160deg);word-break:break-word;text-align:right;line-height:1em}.bar.svelte-1h9hzg2{position:absolute;bottom:0;transition:height 0.6s}h6.svelte-1h9hzg2{font-weight:400;width:100%;text-align:center;margin:0 0 1em}.buttonHolderG.svelte-1h9hzg2{text-align:center;margin:1em 0 2em}@media(max-width: 525px){.buttonHolderG .selectionButtons{font-size:0.6em}}@media(max-width: 405px){.buttonHolderG .selectionButtons{font-size:0.5em;padding:0 6px}}",
  map: `{"version":3,"file":"BarChart.svelte","sources":["BarChart.svelte"],"sourcesContent":["<script>\\n    import Button, { Group, Label } from '@smui/button';\\n    import {xIntervalFont, xIntervalHeight, barLabelFont, labelFont} from './barChartResize'\\n\\n    export let graphs, curGraph = 0, maxWidth = 1000;\\n\\n    const colors = [\\n        \\"#52DEE5\\",\\n        \\"#B4436C\\",\\n        \\"#4D9078\\",\\n        \\"#1789FC\\",\\n        \\"#0E273C\\",\\n        \\"#F78154\\",\\n        \\"#3777FF\\",\\n        \\"#4A306D\\",\\n        \\"#5FAD56\\",\\n        \\"#A33B20\\",\\n        \\"#F2C14E\\",\\n        \\"#393D3F\\",\\n    ];\\n\\n    $: yMin = graphs[curGraph].secondStats.length > 0 ? graphs[curGraph].yMin/2 : graphs[curGraph].yMin;\\n    $: yMax = graphs[curGraph].yMax;\\n    $: stats = graphs[curGraph].stats;\\n    $: secondStats = graphs[curGraph].secondStats;\\n    $: managers = graphs[curGraph].managers;\\n    $: rosterIDs = graphs[curGraph].rosterIDs;\\n    $: labels = graphs[curGraph].labels;\\n    $: header = graphs[curGraph].header;\\n\\n    $: interval = (yMax - yMin) / 4;\\n\\n    $: yScales = [\\n        yMin,\\n        yMin + interval,\\n        yMin + interval * 2,\\n        yMin + interval * 3,\\n        yMin + interval * 4,\\n    ];\\n\\n\\tlet el;\\n\\n    let top = 0;\\n    let bottom = 0;\\n    let left = 0;\\n    let right = 0;\\n\\n    let chartHeight = 0;\\n    let chartHeightInterval = 0;\\n    let chartWidth = 0;\\n    let chartWidthInterval = 0;\\n\\n    let width = 0;\\n\\n    // screen resize dimensions\\n    let xIFont = 1;\\n    let xIHeight = 160;\\n    let barLFont = 0.7;\\n    let lFont = 1;\\n\\n    const resize = (w) => {\\n        width = maxWidth > 1000 ? 1000 : maxWidth;\\n        resizeInner();\\n        xIFont = xIntervalFont(maxWidth);\\n        xIHeight = xIntervalHeight(maxWidth);\\n        barLFont = barLabelFont(maxWidth);\\n        lFont = labelFont(maxWidth);\\n    }\\n\\n    const resizeInner = () => {\\n        top = el?.getBoundingClientRect() ? el?.getBoundingClientRect().top  : 0;\\n        right = el?.getBoundingClientRect() ? el?.getBoundingClientRect().right  : 0;\\n        bottom = top + (width * 0.7 * 0.66);\\n        left = right - (width * 0.85);\\n\\n        chartHeight = bottom - top;\\n        chartHeightInterval = chartHeight / 4;\\n        chartWidth = right - left;\\n        chartWidthInterval = chartWidth / (stats.length + 1);\\n    }\\n\\n    $: resize(maxWidth);\\n    $: resize(innerWidth);\\n    \\n    let innerWidth;\\n\\n<\/script>\\n\\n<svelte:window bind:innerWidth={innerWidth} />\\n\\n<style>\\n    :global(.opacity) {\\n        opacity: 0.3;\\n    }\\n\\n    .chartWrapper {\\n\\t\\tbackground-color: var(--fff);\\n        padding: 1em 0 0.5em;\\n        margin: 0 auto;\\n        box-shadow: 0px 3px 3px -2px var(--boxShadowOne), 0px 3px 4px 0px var(--boxShadowTwo), 0px 1px 8px 0px var(--boxShadowThree);\\n    }\\n    .barChart {\\n        display: block;\\n        position: relative;\\n        width: 100%;\\n        height: 100%;\\n    }\\n\\n    .barChartInner {\\n        display: block;\\n        position: absolute;\\n        top: 0.1em;\\n        right: 0;\\n        border-bottom: 1px solid #ccc;\\n        border-left: 1px solid #ccc;\\n    }\\n\\n    .barLabel {\\n        position: absolute;\\n        transform: translate(-50%, 0);\\n        line-height: 1.1em;\\n        left: 50%;\\n        color: #666;\\n        bottom: 101%;\\n        text-align: center;\\n    }\\n\\n    .yLabel {\\n        writing-mode: tb-rl;\\n        transform: rotate(-180deg);\\n        text-align: center;\\n    }\\n\\n    .yIntervals {\\n        position: absolute;\\n        display: inline-block;\\n        top: 1em;\\n    }\\n\\n    .yInterval {\\n        display: inline-block;\\n        position: absolute;\\n        width: 62px;\\n        text-align: right;\\n    }\\n\\n    .xLabel {\\n        display: inline-block;\\n        right: 0;\\n        position: absolute;\\n        text-align: center;\\n        bottom: 1%;\\n    }\\n\\n    .xIntervals {\\n        position: absolute;\\n        display: inline-block;\\n        right: 0;\\n    }\\n\\n    .xInterval {\\n        display: flex;\\n        justify-content: flex-end;\\n        align-items: center;\\n        position: absolute;\\n        writing-mode: tb-rl;\\n        transform: translate(-50%, 0) rotate(-160deg);\\n        word-break: break-word;\\n        text-align: right;\\n        line-height: 1em;\\n    }\\n\\n    .bar {\\n        position: absolute;\\n        bottom: 0;\\n\\t\\ttransition: height 0.6s;\\n    }\\n\\n    h6 {\\n        font-weight: 400;\\n        width: 100%;\\n        text-align: center;\\n        margin: 0 0 1em;\\n    }\\n\\n    .buttonHolderG {\\n        text-align: center;\\n        margin: 1em 0 2em;\\n    }\\n\\n    /* Start button resizing */\\n\\n    @media (max-width: 525px) {\\n        :global(.buttonHolderG .selectionButtons) {\\n            font-size: 0.6em;\\n        }\\n    }\\n\\n    @media (max-width: 405px) {\\n        :global(.buttonHolderG .selectionButtons) {\\n            font-size: 0.5em;\\n            padding: 0 6px;\\n        }\\n    }\\n\\n    /* End button resizing */\\n</style>\\n\\n<h6>{header}</h6>\\n<div class=\\"chartWrapper\\" style=\\"width: {width}px; height: {width * .7}px\\">\\n    <div class=\\"barChart\\" >\\n        <div class=\\"barChartInner\\" style=\\"width: {width * .85}px; height: {width * .7 * .66}px\\" bind:this={el}>\\n            <!-- x Axis label and intervals -->\\n            {#each stats as stat, ix}\\n                <div class=\\"bar{secondStats.length == 0  ? '' : ' opacity'}\\" style=\\"background-color: {colors[(rosterIDs[ix]-1) % 12]}; width: {chartWidthInterval * 0.8}px; left: {chartWidthInterval * ix + (chartWidthInterval / 2)}px; height: {(stat - yMin) / (yMax - yMin == 0 ? 1 : (yMax - yMin)) * 100}%;\\">\\n                    <span class=\\"barLabel\\" style=\\"font-size: {barLFont}em;\\">{stat}{labels.stat}</span>\\n                </div>\\n            {/each}\\n            {#each secondStats as stat, ix}\\n                <div class=\\"bar\\" style=\\"background-color: {colors[(rosterIDs[ix]-1) % 12]}; width: {chartWidthInterval * 0.8}px; left: {chartWidthInterval * ix + (chartWidthInterval / 2)}px; height: {(stat - yMin) / (yMax - yMin == 0 ? 1 : (yMax - yMin)) * 100}%;\\" />\\n            {/each}\\n        </div>\\n\\n        <!-- y Axis label and intervals -->\\n        <div class=\\"yAxis\\">\\n            <div class=\\"label yLabel\\" style=\\"height: {chartHeight}px; font-size: {lFont}em;\\">{labels.y}</div>\\n            <div class=\\"yIntervals\\" style=\\"right: {chartWidth + 65}px; height: {chartHeight}px;\\">\\n                {#each yScales as yScale, ix}\\n                    <div class=\\"label yInterval\\" style=\\"bottom: {chartHeightInterval * ix}px; font-size: {lFont}em;\\">{yScale}</div>\\n                {/each}\\n            </div>\\n        </div>\\n\\n        <!-- x Axis label and intervals -->\\n        <div class=\\"xAxis\\">\\n            <div class=\\"label xLabel\\" style=\\"width: {chartWidth}px; font-size: {lFont}em;\\">{labels.x}</div>\\n            <div class=\\"xIntervals\\" style=\\"width: {chartWidth}px; top: {chartHeight + 6}px;\\">\\n                {#each managers as manager, ix}\\n                    <div class=\\"xInterval\\" style=\\"left: {chartWidthInterval * (ix + 0.5)}px; font-size: {xIFont}em; height: {xIHeight}px;\\">{manager.name}</div>\\n                {/each}\\n            </div>\\n        </div>\\n    </div>\\n</div>\\n\\n{#if graphs.length > 1}\\n    <div class=\\"buttonHolderG\\">\\n        <Group variant=\\"outlined\\">\\n            {#each graphs as graph, ix}\\n                {#if ix < 4}\\n                    <Button class=\\"selectionButtons\\" on:click={() => curGraph = ix} variant=\\"{curGraph == ix ? \\"raised\\" : \\"outlined\\"}\\">\\n                        <Label>{graph.short}</Label>\\n                    </Button>\\n                {/if}\\n            {/each}\\n        </Group>\\n        <br />\\n        <Group variant=\\"outlined\\">\\n            {#each graphs as graph, ix}\\n                {#if ix > 3}\\n                    <Button class=\\"selectionButtons\\" on:click={() => curGraph = ix} variant=\\"{curGraph == ix ? \\"raised\\" : \\"outlined\\"}\\">\\n                        <Label>{graph.short}</Label>\\n                    </Button>\\n                {/if}\\n            {/each}\\n        </Group>\\n    </div>\\n{/if}"],"names":[],"mappings":"AA2FY,QAAQ,AAAE,CAAC,AACf,OAAO,CAAE,GAAG,AAChB,CAAC,AAED,aAAa,eAAC,CAAC,AACjB,gBAAgB,CAAE,IAAI,KAAK,CAAC,CACtB,OAAO,CAAE,GAAG,CAAC,CAAC,CAAC,KAAK,CACpB,MAAM,CAAE,CAAC,CAAC,IAAI,CACd,UAAU,CAAE,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI,CAAC,IAAI,cAAc,CAAC,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI,cAAc,CAAC,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI,gBAAgB,CAAC,AAChI,CAAC,AACD,SAAS,eAAC,CAAC,AACP,OAAO,CAAE,KAAK,CACd,QAAQ,CAAE,QAAQ,CAClB,KAAK,CAAE,IAAI,CACX,MAAM,CAAE,IAAI,AAChB,CAAC,AAED,cAAc,eAAC,CAAC,AACZ,OAAO,CAAE,KAAK,CACd,QAAQ,CAAE,QAAQ,CAClB,GAAG,CAAE,KAAK,CACV,KAAK,CAAE,CAAC,CACR,aAAa,CAAE,GAAG,CAAC,KAAK,CAAC,IAAI,CAC7B,WAAW,CAAE,GAAG,CAAC,KAAK,CAAC,IAAI,AAC/B,CAAC,AAED,SAAS,eAAC,CAAC,AACP,QAAQ,CAAE,QAAQ,CAClB,SAAS,CAAE,UAAU,IAAI,CAAC,CAAC,CAAC,CAAC,CAC7B,WAAW,CAAE,KAAK,CAClB,IAAI,CAAE,GAAG,CACT,KAAK,CAAE,IAAI,CACX,MAAM,CAAE,IAAI,CACZ,UAAU,CAAE,MAAM,AACtB,CAAC,AAED,OAAO,eAAC,CAAC,AACL,YAAY,CAAE,KAAK,CACnB,SAAS,CAAE,OAAO,OAAO,CAAC,CAC1B,UAAU,CAAE,MAAM,AACtB,CAAC,AAED,WAAW,eAAC,CAAC,AACT,QAAQ,CAAE,QAAQ,CAClB,OAAO,CAAE,YAAY,CACrB,GAAG,CAAE,GAAG,AACZ,CAAC,AAED,UAAU,eAAC,CAAC,AACR,OAAO,CAAE,YAAY,CACrB,QAAQ,CAAE,QAAQ,CAClB,KAAK,CAAE,IAAI,CACX,UAAU,CAAE,KAAK,AACrB,CAAC,AAED,OAAO,eAAC,CAAC,AACL,OAAO,CAAE,YAAY,CACrB,KAAK,CAAE,CAAC,CACR,QAAQ,CAAE,QAAQ,CAClB,UAAU,CAAE,MAAM,CAClB,MAAM,CAAE,EAAE,AACd,CAAC,AAED,WAAW,eAAC,CAAC,AACT,QAAQ,CAAE,QAAQ,CAClB,OAAO,CAAE,YAAY,CACrB,KAAK,CAAE,CAAC,AACZ,CAAC,AAED,UAAU,eAAC,CAAC,AACR,OAAO,CAAE,IAAI,CACb,eAAe,CAAE,QAAQ,CACzB,WAAW,CAAE,MAAM,CACnB,QAAQ,CAAE,QAAQ,CAClB,YAAY,CAAE,KAAK,CACnB,SAAS,CAAE,UAAU,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,OAAO,OAAO,CAAC,CAC7C,UAAU,CAAE,UAAU,CACtB,UAAU,CAAE,KAAK,CACjB,WAAW,CAAE,GAAG,AACpB,CAAC,AAED,IAAI,eAAC,CAAC,AACF,QAAQ,CAAE,QAAQ,CAClB,MAAM,CAAE,CAAC,CACf,UAAU,CAAE,MAAM,CAAC,IAAI,AACrB,CAAC,AAED,EAAE,eAAC,CAAC,AACA,WAAW,CAAE,GAAG,CAChB,KAAK,CAAE,IAAI,CACX,UAAU,CAAE,MAAM,CAClB,MAAM,CAAE,CAAC,CAAC,CAAC,CAAC,GAAG,AACnB,CAAC,AAED,cAAc,eAAC,CAAC,AACZ,UAAU,CAAE,MAAM,CAClB,MAAM,CAAE,GAAG,CAAC,CAAC,CAAC,GAAG,AACrB,CAAC,AAID,MAAM,AAAC,YAAY,KAAK,CAAC,AAAC,CAAC,AACf,gCAAgC,AAAE,CAAC,AACvC,SAAS,CAAE,KAAK,AACpB,CAAC,AACL,CAAC,AAED,MAAM,AAAC,YAAY,KAAK,CAAC,AAAC,CAAC,AACf,gCAAgC,AAAE,CAAC,AACvC,SAAS,CAAE,KAAK,CAChB,OAAO,CAAE,CAAC,CAAC,GAAG,AAClB,CAAC,AACL,CAAC"}`
};
var BarChart = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let yMin;
  let yMax;
  let stats;
  let secondStats;
  let managers2;
  let rosterIDs;
  let labels;
  let header;
  let interval;
  let yScales;
  let { graphs, curGraph = 0, maxWidth = 1e3 } = $$props;
  const colors = [
    "#52DEE5",
    "#B4436C",
    "#4D9078",
    "#1789FC",
    "#0E273C",
    "#F78154",
    "#3777FF",
    "#4A306D",
    "#5FAD56",
    "#A33B20",
    "#F2C14E",
    "#393D3F"
  ];
  let el;
  let top = 0;
  let bottom = 0;
  let left = 0;
  let right = 0;
  let chartHeight = 0;
  let chartHeightInterval = 0;
  let chartWidth = 0;
  let chartWidthInterval = 0;
  let width = 0;
  let xIFont = 1;
  let xIHeight = 160;
  let barLFont = 0.7;
  let lFont = 1;
  const resize = (w) => {
    width = maxWidth > 1e3 ? 1e3 : maxWidth;
    resizeInner();
    xIFont = xIntervalFont(maxWidth);
    xIHeight = xIntervalHeight(maxWidth);
    barLFont = barLabelFont(maxWidth);
    lFont = labelFont(maxWidth);
  };
  const resizeInner = () => {
    top = (el == null ? void 0 : el.getBoundingClientRect()) ? el == null ? void 0 : el.getBoundingClientRect().top : 0;
    right = (el == null ? void 0 : el.getBoundingClientRect()) ? el == null ? void 0 : el.getBoundingClientRect().right : 0;
    bottom = top + width * 0.7 * 0.66;
    left = right - width * 0.85;
    chartHeight = bottom - top;
    chartHeightInterval = chartHeight / 4;
    chartWidth = right - left;
    chartWidthInterval = chartWidth / (stats.length + 1);
  };
  if ($$props.graphs === void 0 && $$bindings.graphs && graphs !== void 0)
    $$bindings.graphs(graphs);
  if ($$props.curGraph === void 0 && $$bindings.curGraph && curGraph !== void 0)
    $$bindings.curGraph(curGraph);
  if ($$props.maxWidth === void 0 && $$bindings.maxWidth && maxWidth !== void 0)
    $$bindings.maxWidth(maxWidth);
  $$result.css.add(css$n);
  yMin = graphs[curGraph].secondStats.length > 0 ? graphs[curGraph].yMin / 2 : graphs[curGraph].yMin;
  yMax = graphs[curGraph].yMax;
  stats = graphs[curGraph].stats;
  secondStats = graphs[curGraph].secondStats;
  managers2 = graphs[curGraph].managers;
  rosterIDs = graphs[curGraph].rosterIDs;
  labels = graphs[curGraph].labels;
  header = graphs[curGraph].header;
  interval = (yMax - yMin) / 4;
  yScales = [
    yMin,
    yMin + interval,
    yMin + interval * 2,
    yMin + interval * 3,
    yMin + interval * 4
  ];
  {
    resize();
  }
  {
    resize();
  }
  return `



<h6 class="${"svelte-1h9hzg2"}">${escape(header)}</h6>
<div class="${"chartWrapper svelte-1h9hzg2"}" style="${"width: " + escape(width) + "px; height: " + escape(width * 0.7) + "px"}"><div class="${"barChart svelte-1h9hzg2"}"><div class="${"barChartInner svelte-1h9hzg2"}" style="${"width: " + escape(width * 0.85) + "px; height: " + escape(width * 0.7 * 0.66) + "px"}"${add_attribute("this", el, 0)}>
            ${each(stats, (stat, ix) => `<div class="${"bar" + escape(secondStats.length == 0 ? "" : " opacity") + " svelte-1h9hzg2"}" style="${"background-color: " + escape(colors[(rosterIDs[ix] - 1) % 12]) + "; width: " + escape(chartWidthInterval * 0.8) + "px; left: " + escape(chartWidthInterval * ix + chartWidthInterval / 2) + "px; height: " + escape((stat - yMin) / (yMax - yMin == 0 ? 1 : yMax - yMin) * 100) + "%;"}"><span class="${"barLabel svelte-1h9hzg2"}" style="${"font-size: " + escape(barLFont) + "em;"}">${escape(stat)}${escape(labels.stat)}</span>
                </div>`)}
            ${each(secondStats, (stat, ix) => `<div class="${"bar svelte-1h9hzg2"}" style="${"background-color: " + escape(colors[(rosterIDs[ix] - 1) % 12]) + "; width: " + escape(chartWidthInterval * 0.8) + "px; left: " + escape(chartWidthInterval * ix + chartWidthInterval / 2) + "px; height: " + escape((stat - yMin) / (yMax - yMin == 0 ? 1 : yMax - yMin) * 100) + "%;"}"></div>`)}</div>

        
        <div class="${"yAxis"}"><div class="${"label yLabel svelte-1h9hzg2"}" style="${"height: " + escape(chartHeight) + "px; font-size: " + escape(lFont) + "em;"}">${escape(labels.y)}</div>
            <div class="${"yIntervals svelte-1h9hzg2"}" style="${"right: " + escape(chartWidth + 65) + "px; height: " + escape(chartHeight) + "px;"}">${each(yScales, (yScale, ix) => `<div class="${"label yInterval svelte-1h9hzg2"}" style="${"bottom: " + escape(chartHeightInterval * ix) + "px; font-size: " + escape(lFont) + "em;"}">${escape(yScale)}</div>`)}</div></div>

        
        <div class="${"xAxis"}"><div class="${"label xLabel svelte-1h9hzg2"}" style="${"width: " + escape(chartWidth) + "px; font-size: " + escape(lFont) + "em;"}">${escape(labels.x)}</div>
            <div class="${"xIntervals svelte-1h9hzg2"}" style="${"width: " + escape(chartWidth) + "px; top: " + escape(chartHeight + 6) + "px;"}">${each(managers2, (manager, ix) => `<div class="${"xInterval svelte-1h9hzg2"}" style="${"left: " + escape(chartWidthInterval * (ix + 0.5)) + "px; font-size: " + escape(xIFont) + "em; height: " + escape(xIHeight) + "px;"}">${escape(manager.name)}</div>`)}</div></div></div></div>

${graphs.length > 1 ? `<div class="${"buttonHolderG svelte-1h9hzg2"}">${validate_component(Group, "Group").$$render($$result, { variant: "outlined" }, {}, {
    default: () => `${each(graphs, (graph, ix) => `${ix < 4 ? `${validate_component(Button_1, "Button").$$render($$result, {
      class: "selectionButtons",
      variant: curGraph == ix ? "raised" : "outlined"
    }, {}, {
      default: () => `${validate_component(CommonLabel, "Label").$$render($$result, {}, {}, { default: () => `${escape(graph.short)}` })}
                    `
    })}` : ``}`)}`
  })}
        <br>
        ${validate_component(Group, "Group").$$render($$result, { variant: "outlined" }, {}, {
    default: () => `${each(graphs, (graph, ix) => `${ix > 3 ? `${validate_component(Button_1, "Button").$$render($$result, {
      class: "selectionButtons",
      variant: curGraph == ix ? "raised" : "outlined"
    }, {}, {
      default: () => `${validate_component(CommonLabel, "Label").$$render($$result, {}, {}, { default: () => `${escape(graph.short)}` })}
                    `
    })}` : ``}`)}`
  })}</div>` : ``}`;
});
var css$m = {
  code: ".header{text-align:center}.recordTable{box-shadow:0px 3px 3px -2px var(--boxShadowOne), 0px 3px 4px 0px var(--boxShadowTwo), 0px 1px 8px 0px var(--boxShadowThree);margin:2em}.rankingTable{display:table;box-shadow:0px 3px 3px -2px var(--boxShadowOne), 0px 3px 4px 0px var(--boxShadowTwo), 0px 1px 8px 0px var(--boxShadowThree);margin:2em auto 0.5em}.fullFlex.svelte-g4jcp2{display:flex;flex-wrap:wrap;justify-content:space-around;margin:3em auto 5em}.rankingHolder.svelte-g4jcp2{display:block;width:100%;overflow-x:hidden}.subTitle.svelte-g4jcp2{font-style:italic;font-size:0.7em;color:#888;line-height:1.2em}h4.svelte-g4jcp2{text-align:center;margin:2em 0 1em}.curRecordManager.svelte-g4jcp2{font-style:italic;color:#999;font-size:0.8em;line-height:1.1em}.rankingTableWrapper.svelte-g4jcp2{width:25%}.rankingInner.svelte-g4jcp2{position:relative;display:flex;flex-wrap:nowrap;width:400%;transition:margin-left 0.8s}.buttonHolder.svelte-g4jcp2{text-align:center;margin:2em 0 4em}.cellName{cursor:pointer;line-height:1.2em}.differentialName{padding:0.7em 0}.center.svelte-g4jcp2{text-align:center}@media(max-width: 540px){.buttonHolder .selectionButtons{font-size:0.6em}}@media(max-width: 415px){.buttonHolder .selectionButtons{font-size:0.5em;padding:0 6px}}@media(max-width: 315px){.buttonHolder .selectionButtons{font-size:0.45em;padding:0 3px}}@media(max-width: 510px){.recordTable th{font-size:0.8em;padding:1px 12px}.recordTable td{font-size:0.8em;padding:1px 12px}}@media(max-width: 435px){.rank{padding:1px 0 1px 5px !important}.rank{padding:1px 0 1px 5px !important}}@media(max-width: 420px){.recordTable th{font-size:0.6em;padding:1px 12px}.recordTable td{font-size:0.6em;padding:1px 12px}}@media(max-width: 330px){.recordTable th{font-size:0.5em;padding:1px 8px}.recordTable td{font-size:0.5em;padding:1px 8px}}@media(max-width: 570px){.rankingTable th{font-size:0.8em;max-width:110px;white-space:break-spaces;padding:1px 12px}.rankingTable td{font-size:0.8em;max-width:110px;white-space:break-spaces;padding:1px 12px}}@media(max-width: 410px){.rankingTable th{font-size:0.6em;max-width:90px;white-space:break-spaces;padding:1px 12px}.rankingTable td{font-size:0.6em;max-width:90px;white-space:break-spaces;padding:1px 12px}}@media(max-width: 340px){.rankingTable th{font-size:0.55em;max-width:80px;white-space:break-spaces;padding:1px 6px}.rankingTable td{font-size:0.55em;max-width:80px;white-space:break-spaces;padding:1px 6px}}",
  map: `{"version":3,"file":"RecordsAndRankings.svelte","sources":["RecordsAndRankings.svelte"],"sourcesContent":["<script>\\n    import Button, { Group, Label } from '@smui/button';\\n    import BarChart from '../BarChart.svelte'\\n    import { cleanName, generateGraph, gotoManager, round } from '$lib/utils/helper';\\n\\n  \\timport DataTable, { Head, Body, Row, Cell } from '@smui/data-table';\\n\\n    export let tradesData, waiversData, weekRecords, seasonLongRecords, showTies, winPercentages, fptsHistories, lineupIQs, prefix, blowouts, closestMatchups, currentManagers, allTime=false, last=false;\\n\\n    const lineupIQGraph = {\\n        stats: lineupIQs,\\n        x: \\"Manager\\",\\n        y: \\"Lineup IQ\\",\\n        stat: \\"%\\",\\n        header: \\"Manager Lineup IQ\\",\\n        field: \\"iq\\",\\n        short: \\"Lineup IQ\\"\\n    }\\n\\n    const potentialPointsGraph = {\\n        stats: lineupIQs,\\n        x: \\"Manager\\",\\n        y: \\"Points\\",\\n        stat: \\"\\",\\n        header: \\"Potential Points vs Points\\",\\n        field: \\"potentialPoints\\",\\n        secondField: \\"fpts\\",\\n        short: \\"Potential Points\\"\\n    }\\n\\n    const winsGraph = {\\n        stats: winPercentages,\\n        x: \\"Manager\\",\\n        y: \\"Wins\\",\\n        stat: \\"\\",\\n        header: \\"Team Wins\\",\\n        field: \\"wins\\",\\n        short: \\"Wins\\"\\n    }\\n\\n    const winPercentagesGraph = {\\n        stats: winPercentages,\\n        x: \\"Manager\\",\\n        y: \\"Win Percentage\\",\\n        stat: \\"%\\",\\n        header: \\"Team Win Percentages\\",\\n        field: \\"percentage\\",\\n        short: \\"Win Percentage\\"\\n    }\\n\\n    const fptsHistoriesGraph = {\\n        stats: fptsHistories,\\n        x: \\"Manager\\",\\n        y: \\"Fantasy Points\\",\\n        stat: \\"\\",\\n        header: \\"Team Fantasy Points\\",\\n        field: \\"fptsFor\\",\\n        short: \\"Fantasy Points\\"\\n    }\\n\\n    for(let i = 1; i <= waiversData.length; i++) {\\n        if(!tradesData.find(t => t.rosterID == i)) {\\n            tradesData.push({\\n                rosterID: i,\\n                manager: currentManagers[i],\\n                trades: 0,\\n            })\\n        }\\n    }\\n\\n    const tradesGraph = {\\n        stats: tradesData,\\n        x: \\"Manager\\",\\n        y: \\"# of trades\\",\\n        stat: \\"\\",\\n        header: \\"Trades Managers Have Made\\",\\n        field: \\"trades\\",\\n        short: \\"Trades\\"\\n    }\\n\\n    const waiversGraph = {\\n        stats: waiversData,\\n        x: \\"Manager\\",\\n        y: \\"# of Waiver Moves\\",\\n        stat: \\"\\",\\n        header: \\"Waivers Managers Have Made\\",\\n        field: \\"waivers\\",\\n        short: \\"Waivers\\"\\n    }\\n    \\n    const graphs = [];\\n\\n    if(lineupIQs[0]?.potentialPoints) {\\n        graphs.push(generateGraph(lineupIQGraph));\\n    }\\n    graphs.push(generateGraph(winsGraph, 5));\\n    graphs.push(generateGraph(winPercentagesGraph));\\n    graphs.push(generateGraph(fptsHistoriesGraph));\\n    if(lineupIQs[0]?.potentialPoints) {\\n        graphs.push(generateGraph(potentialPointsGraph, 10, 0));\\n    }\\n    graphs.push(generateGraph(tradesGraph));\\n    graphs.push(generateGraph(waiversGraph));\\n\\n    const transactions = [];\\n\\n    for(let i = 1; i <= waiversData.length; i++) {\\n        const waiver = waiversData.find(w => w.rosterID == i);\\n        const trades = tradesData.find(t => t.rosterID == i)?.trades || 0;\\n        const waivers = waiver?.waivers || 0;\\n        const manager = waiver.manager;\\n        transactions.push({\\n            rosterID: i,\\n            manager,\\n            trades,\\n            waivers,\\n        })\\n    }\\n\\n    let curTable = 0;\\n    let curGraph = 0;\\n\\n    let iqOffset = 0;\\n    const tables = [\\n        \\"Win Percentages\\",\\n        \\"Points\\",\\n        \\"Transactions\\",\\n    ]\\n    if(!lineupIQs[0]?.potentialPoints) {\\n        iqOffset = 1;\\n    } else {\\n        tables.unshift('Lineup IQs');\\n    }\\n    const changeTable = (newGraph) => {\\n        switch (newGraph) {\\n            case 0 - iqOffset:\\n            case (4 + (99 * iqOffset)):\\n                curTable = 0;\\n                break;\\n            case 1 - iqOffset:\\n            case 2 - iqOffset:\\n                curTable = 1 - iqOffset;\\n                break;\\n            case 3 - iqOffset:\\n                curTable = 2 - iqOffset;\\n                break;\\n            case 5 - (2 * iqOffset):\\n            case 6 - (2 * iqOffset):\\n                curTable = 3 - iqOffset;\\n                break;\\n            default:\\n                curTable = 0;\\n                break;\\n        }\\n    }\\n\\n    const changeGraph = (newTable) => {\\n        switch (newTable) {\\n            case 0 - iqOffset:\\n                if(curGraph == 0 || curGraph == 4) {\\n                    break;\\n                }\\n                curGraph = 0;\\n                break;\\n            case 1 - iqOffset:\\n                if(curGraph == 1 - iqOffset || curGraph == 2 - iqOffset) {\\n                    break;\\n                }\\n                curGraph = 1 - iqOffset;\\n                break;\\n            case 2 - iqOffset:\\n                curGraph = 3 - iqOffset;\\n                break;\\n            case 3 - iqOffset:\\n                if(curGraph == 5 - (2 * iqOffset) || curGraph == 6 - (2 * iqOffset)) {\\n                    break;\\n                }\\n                curGraph = 5 - (2 * iqOffset);\\n                break;\\n            default:\\n                curGraph = 0;\\n                break;\\n        }\\n    }\\n\\n    $: changeTable(curGraph);\\n    $: changeGraph(curTable);\\n    \\n    let innerWidth;\\n\\n<\/script>\\n\\n<svelte:window bind:innerWidth={innerWidth} />\\n\\n<style>\\n    :global(.header) {\\n        text-align: center;\\n    }\\n\\n    :global(.recordTable) {\\n        box-shadow: 0px 3px 3px -2px var(--boxShadowOne), 0px 3px 4px 0px var(--boxShadowTwo), 0px 1px 8px 0px var(--boxShadowThree);\\n        margin: 2em;\\n    }\\n\\n    :global(.rankingTable) {\\n        display: table;\\n        box-shadow: 0px 3px 3px -2px var(--boxShadowOne), 0px 3px 4px 0px var(--boxShadowTwo), 0px 1px 8px 0px var(--boxShadowThree);\\n        margin: 2em auto 0.5em;\\n    }\\n\\n    .fullFlex {\\n        display: flex;\\n        flex-wrap: wrap;\\n        justify-content: space-around;\\n        margin: 3em auto 5em;\\n    }\\n\\n    .rankingHolder {\\n        display: block;\\n        width: 100%;\\n        overflow-x: hidden;\\n    }\\n\\n    .subTitle {\\n        font-style: italic;\\n        font-size: 0.7em;\\n        color: #888;\\n        line-height: 1.2em;\\n    }\\n\\n    h5 {\\n        text-align: center;\\n        margin: 2em 0 1em;\\n    }\\n\\n    h4 {\\n        text-align: center;\\n        margin: 2em 0 1em;\\n    }\\n\\n    .curRecordManager {\\n        font-style: italic;\\n        color: #999;\\n        font-size: 0.8em;\\n        line-height: 1.1em;\\n    }\\n\\n    .rankingTableWrapper {\\n        width: 25%;\\n    }\\n\\n    .rankingInner {\\n        position: relative;\\n        display: flex;\\n        flex-wrap: nowrap;\\n        width: 400%;\\n\\t\\ttransition: margin-left 0.8s;\\n    }\\n\\n    .buttonHolder {\\n        text-align: center;\\n        margin: 2em 0 4em;\\n    }\\n\\n    :global(.cellName) {\\n        cursor: pointer;\\n        line-height: 1.2em;\\n    }\\n\\n    :global(.differentialName) {\\n        padding: 0.7em 0;\\n    }\\n\\n    .center {\\n        text-align: center;\\n    }\\n\\n    /* Start button resizing */\\n\\n    @media (max-width: 540px) {\\n        :global(.buttonHolder .selectionButtons) {\\n            font-size: 0.6em;\\n        }\\n    }\\n\\n    @media (max-width: 415px) {\\n        :global(.buttonHolder .selectionButtons) {\\n            font-size: 0.5em;\\n            padding: 0 6px;\\n        }\\n    }\\n\\n    @media (max-width: 315px) {\\n        :global(.buttonHolder .selectionButtons) {\\n            font-size: 0.45em;\\n            padding: 0 3px;\\n        }\\n    }\\n\\n    /* End button resizing */\\n\\n    /* Start record table resizing */\\n\\n    @media (max-width: 510px) {\\n        :global(.recordTable th) {\\n            font-size: 0.8em;\\n            padding: 1px 12px;\\n        }\\n        :global(.recordTable td) {\\n            font-size: 0.8em;\\n            padding: 1px 12px;\\n        }\\n    }\\n\\n    @media (max-width: 435px) {\\n        :global(.rank) {\\n            padding: 1px 0 1px 5px !important;\\n        }\\n        :global(.rank) {\\n            padding: 1px 0 1px 5px !important;\\n        }\\n    }\\n\\n    @media (max-width: 420px) {\\n        :global(.recordTable th) {\\n            font-size: 0.6em;\\n            padding: 1px 12px;\\n        }\\n        :global(.recordTable td) {\\n            font-size: 0.6em;\\n            padding: 1px 12px;\\n        }\\n    }\\n\\n    @media (max-width: 330px) {\\n        :global(.recordTable th) {\\n            font-size: 0.5em;\\n            padding: 1px 8px;\\n        }\\n        :global(.recordTable td) {\\n            font-size: 0.5em;\\n            padding: 1px 8px;\\n        }\\n    }\\n\\n    /* END record table resizing */\\n\\n    /* Start ranking table resizing */\\n\\n    @media (max-width: 570px) {\\n        :global(.rankingTable th) {\\n            font-size: 0.8em;\\n            max-width: 110px;\\n            white-space: break-spaces;\\n            padding: 1px 12px;\\n        }\\n        :global(.rankingTable td) {\\n            font-size: 0.8em;\\n            max-width: 110px;\\n            white-space: break-spaces;\\n            padding: 1px 12px;\\n        }\\n    }\\n\\n    @media (max-width: 410px) {\\n        :global(.rankingTable th) {\\n            font-size: 0.6em;\\n            max-width: 90px;\\n            white-space: break-spaces;\\n            padding: 1px 12px;\\n        }\\n        :global(.rankingTable td) {\\n            font-size: 0.6em;\\n            max-width: 90px;\\n            white-space: break-spaces;\\n            padding: 1px 12px;\\n        }\\n    }\\n\\n    @media (max-width: 340px) {\\n        :global(.rankingTable th) {\\n            font-size: 0.55em;\\n            max-width: 80px;\\n            white-space: break-spaces;\\n            padding: 1px 6px;\\n        }\\n        :global(.rankingTable td) {\\n            font-size: 0.55em;\\n            max-width: 80px;\\n            white-space: break-spaces;\\n            padding: 1px 6px;\\n        }\\n    }\\n\\n    /* END ranking table resizing */\\n</style>\\n\\n<h4>{prefix} Records</h4>\\n\\n<div class=\\"fullFlex\\">\\n    {#if weekRecords && weekRecords.length}\\n        <DataTable class=\\"recordTable\\">\\n            <Head>\\n                <Row>\\n                    <Cell class=\\"header\\" colspan=4>{prefix} Single Week Scoring Records</Cell>\\n                </Row>\\n                <Row>\\n                    <Cell class=\\"header rank\\"></Cell>\\n                    <Cell class=\\"header\\">Manager</Cell>\\n                    <Cell class=\\"header\\">Week</Cell>\\n                    <Cell class=\\"header\\">Total Points</Cell>\\n                </Row>\\n            </Head>\\n            <Body>\\n                {#each weekRecords as leagueWeekRecord, ix}\\n                    <Row>\\n                        <Cell class=\\"rank\\">{ix + 1}</Cell>\\n                        <Cell class=\\"cellName\\" on:click={() => gotoManager(leagueWeekRecord.rosterID)}>\\n                            {leagueWeekRecord.manager.name}\\n                            {#if !allTime  && cleanName(leagueWeekRecord.manager.name) != cleanName(currentManagers[leagueWeekRecord.rosterID].name)}\\n                                <div class=\\"curRecordManager\\">({currentManagers[leagueWeekRecord.rosterID].name})</div>\\n                            {/if}\\n                        </Cell>\\n                        <Cell>{allTime ? leagueWeekRecord.year + \\" \\" : \\"\\" }Week {leagueWeekRecord.week}</Cell>\\n                        <Cell>{round(leagueWeekRecord.fpts)}</Cell>\\n                    </Row>\\n                {/each}\\n            </Body>\\n        </DataTable>\\n    {/if}\\n\\n    <DataTable class=\\"recordTable\\">\\n        <Head>\\n            <Row>\\n                <Cell class=\\"header\\" colspan=4>{prefix} Season-long Scoring Records</Cell>\\n            </Row>\\n            <Row>\\n                <Cell class=\\"header rank\\"></Cell>\\n                <Cell class=\\"header\\">Manager</Cell>\\n                {#if allTime}\\n                    <Cell class=\\"header\\">Year</Cell>\\n                {/if}\\n                <Cell class=\\"header\\">Total Points</Cell>\\n            </Row>\\n        </Head>\\n        <Body>\\n            {#each seasonLongRecords as mostSeasonLongPoint, ix}\\n                <Row>\\n                    <Cell class=\\"rank\\">{ix + 1}</Cell>\\n                    <Cell class=\\"cellName\\" on:click={() => gotoManager(mostSeasonLongPoint.rosterID)}>\\n                        {mostSeasonLongPoint.manager.name}\\n                        {#if !allTime  && cleanName(mostSeasonLongPoint.manager.name) != cleanName(currentManagers[mostSeasonLongPoint.rosterID].name)}\\n                            <div class=\\"curRecordManager\\">({currentManagers[mostSeasonLongPoint.rosterID].name})</div>\\n                        {/if}\\n                    </Cell>\\n                    {#if allTime}\\n                        <Cell>{mostSeasonLongPoint.year}</Cell>\\n                    {/if}\\n                    <Cell>{mostSeasonLongPoint.fpts}</Cell>\\n                </Row>\\n            {/each}\\n        </Body>\\n    </DataTable>\\n\\n    {#if blowouts && blowouts.length}\\n        <DataTable class=\\"recordTable\\">\\n            <Head>\\n                <Row>\\n                    <Cell class=\\"header\\" colspan=4>{prefix} Largest Blowouts</Cell>\\n                </Row>\\n                <Row>\\n                    <Cell class=\\"header rank\\"></Cell>\\n                    <Cell class=\\"header\\">Matchup</Cell>\\n                    <Cell class=\\"header\\">Week</Cell>\\n                    <Cell class=\\"header\\">Differential</Cell>\\n                </Row>\\n            </Head>\\n            <Body>\\n                {#each blowouts as blowout, ix}\\n                    <Row>\\n                        <Cell class=\\"rank\\">{ix + 1}</Cell>\\n                        <Cell class=\\"cellName center differentialName\\">\\n                            <div class=\\"center\\" on:click={() => gotoManager(blowout.home.rosterID)}>\\n                                {blowout.home.manager.name} ({round(blowout.home.fpts)})\\n                                {#if !allTime  && cleanName(blowout.home.manager.name) != cleanName(currentManagers[blowout.home.rosterID].name)}\\n                                    <div class=\\"curRecordManager\\">({currentManagers[blowout.home.rosterID].name})</div>\\n                                {/if}\\n                            </div>\\n                            vs\\n                            <div class=\\"center\\" on:click={() => gotoManager(blowout.away.rosterID)}>\\n                                {blowout.away.manager.name} ({round(blowout.away.fpts)})\\n                                {#if !allTime  && cleanName(blowout.away.manager.name) != cleanName(currentManagers[blowout.away.rosterID].name)}\\n                                    <div class=\\"curRecordManager\\">({currentManagers[blowout.away.rosterID].name})</div>\\n                                {/if}\\n                            </div>\\n                        </Cell>\\n                        <Cell>{allTime ? blowout.year + \\" \\" : \\"\\" }Week {blowout.week}</Cell>\\n                        <Cell>{round(blowout.differential)}</Cell>\\n                    </Row>\\n                {/each}\\n            </Body>\\n        </DataTable>\\n    {/if}\\n\\n    {#if closestMatchups && closestMatchups.length}\\n        <DataTable class=\\"recordTable\\">\\n            <Head>\\n                <Row>\\n                    <Cell class=\\"header\\" colspan=4>{prefix} Narrowest Wins</Cell>\\n                </Row>\\n                <Row>\\n                    <Cell class=\\"header rank\\"></Cell>\\n                    <Cell class=\\"header\\">Matchup</Cell>\\n                    <Cell class=\\"header\\">Week</Cell>\\n                    <Cell class=\\"header\\">Differential</Cell>\\n                </Row>\\n            </Head>\\n            <Body>\\n                {#each closestMatchups as closestMatchup, ix}\\n                    <Row>\\n                        <Cell class=\\"rank\\">{ix + 1}</Cell>\\n                        <Cell class=\\"cellName center differentialName\\">\\n                            <div class=\\"center\\" on:click={() => gotoManager(closestMatchup.home.rosterID)}>\\n                                {closestMatchup.home.manager.name} ({round(closestMatchup.home.fpts)})\\n                                {#if !allTime  && cleanName(closestMatchup.home.manager.name) != cleanName(currentManagers[closestMatchup.home.rosterID].name)}\\n                                    <div class=\\"curRecordManager\\">({currentManagers[closestMatchup.home.rosterID].name})</div>\\n                                {/if}\\n                            </div>\\n                            vs\\n                            <div class=\\"center\\" on:click={() => gotoManager(closestMatchup.away.rosterID)}>\\n                                {closestMatchup.away.manager.name} ({round(closestMatchup.away.fpts)})\\n                                {#if !allTime  && cleanName(closestMatchup.away.manager.name) != cleanName(currentManagers[closestMatchup.away.rosterID].name)}\\n                                    <div class=\\"curRecordManager\\">({currentManagers[closestMatchup.away.rosterID].name})</div>\\n                                {/if}\\n                            </div>\\n                        </Cell>\\n                        <Cell>{allTime ? closestMatchup.year + \\" \\" : \\"\\" }Week {closestMatchup.week}</Cell>\\n                        <Cell>{round(closestMatchup.differential)}</Cell>\\n                    </Row>\\n                {/each}\\n            </Body>\\n        </DataTable>\\n    {/if}\\n</div>\\n\\n<h4>{prefix} Rankings</h4>\\n\\n<BarChart maxWidth={innerWidth} {graphs} bind:curGraph={curGraph} />\\n\\n<div class=\\"rankingHolder\\">\\n    <div class=\\"rankingInner\\" style=\\"margin-left: -{100 * curTable}%;\\">\\n        {#if lineupIQs[0]?.potentialPoints}\\n            <div class=\\"rankingTableWrapper\\">\\n                <DataTable class=\\"rankingTable\\">\\n                    <Head>\\n                        <Row>\\n                            <Cell class=\\"header\\" colspan=5>\\n                                {prefix} Lineup IQ Rankings\\n                                <div class=\\"subTitle\\">\\n                                    The percentage of potential points each manager has captured\\n                                </div>\\n                            </Cell>\\n                        </Row>\\n                        <Row>\\n                            <Cell class=\\"header\\"></Cell>\\n                            <Cell class=\\"header\\">Manager</Cell>\\n                            <Cell class=\\"header\\">Lineup IQ</Cell>\\n                            <Cell class=\\"header\\">Points</Cell>\\n                            <Cell class=\\"header\\">Potential Points</Cell>\\n                        </Row>\\n                    </Head>\\n                    <Body>\\n                        {#each lineupIQs as lineupIQ, ix}\\n                            <Row>\\n                                <Cell>{ix + 1}</Cell>\\n                                <Cell class=\\"cellName\\" on:click={() => gotoManager(lineupIQ.rosterID)}>\\n                                    {lineupIQ.manager.name}\\n                                    {#if !allTime  && cleanName(lineupIQ.manager.name) != cleanName(currentManagers[lineupIQ.rosterID].name)}\\n                                        <div class=\\"curRecordManager\\">({currentManagers[lineupIQ.rosterID].name})</div>\\n                                    {/if}\\n                                </Cell>\\n                                <Cell>{lineupIQ.iq}%</Cell>\\n                                <Cell>{lineupIQ.fpts}</Cell>\\n                                <Cell>{lineupIQ.potentialPoints}</Cell>\\n                            </Row>\\n                        {/each}\\n                    </Body>\\n                </DataTable>\\n            </div>\\n        {/if}\\n\\n        <div class=\\"rankingTableWrapper\\">\\n            <DataTable class=\\"rankingTable\\">\\n                <Head>\\n                    <Row>\\n                        <Cell class=\\"header\\" colspan=6>{prefix} Win Percentages Rankings</Cell>\\n                    </Row>\\n                    <Row>\\n                        <Cell class=\\"header\\"></Cell>\\n                        <Cell class=\\"header\\">Manager</Cell>\\n                        <Cell class=\\"header\\">Win %</Cell>\\n                        <Cell class=\\"header\\">Wins</Cell>\\n                        {#if showTies}\\n                            <Cell class=\\"header\\">Ties</Cell>\\n                        {/if}\\n                        <Cell class=\\"header\\">Losses</Cell>\\n                    </Row>\\n                </Head>\\n                <Body>\\n                    {#each winPercentages as winPercentage, ix}\\n                        <Row>\\n                            <Cell>{ix + 1}</Cell>\\n                            <Cell class=\\"cellName\\" on:click={() => gotoManager(winPercentage.rosterID)}>\\n                                {winPercentage.manager.name}\\n                                {#if !allTime  && cleanName(winPercentage.manager.name) != cleanName(currentManagers[winPercentage.rosterID].name)}\\n                                    <div class=\\"curRecordManager\\">({currentManagers[winPercentage.rosterID].name})</div>\\n                                {/if}\\n                            </Cell>\\n                            <Cell>{winPercentage.percentage}%</Cell>\\n                            <Cell>{winPercentage.wins}</Cell>\\n                            {#if showTies}\\n                                <Cell>{winPercentage.ties}</Cell>\\n                            {/if}\\n                            <Cell>{winPercentage.losses}</Cell>\\n                        </Row>\\n                    {/each}\\n                </Body>\\n            </DataTable>\\n        </div>\\n\\n        <div class=\\"rankingTableWrapper\\">\\n            <DataTable class=\\"rankingTable\\">\\n                <Head>\\n                    <Row>\\n                        <Cell class=\\"header\\" colspan=4>\\n                            {prefix} Fantasy Points Rankings\\n                        </Cell>\\n                    </Row>\\n                    <Row>\\n                        <Cell class=\\"header\\"></Cell>\\n                        <Cell class=\\"header\\">Manager</Cell>\\n                        <Cell class=\\"header\\">Points For</Cell>\\n                        <Cell class=\\"header\\">Points Against</Cell>\\n                    </Row>\\n                </Head>\\n                <Body>\\n                    {#each fptsHistories as fptsHistory, ix}\\n                        <Row>\\n                            <Cell>{ix + 1}</Cell>\\n                            <Cell class=\\"cellName\\" on:click={() => gotoManager(fptsHistory.rosterID)}>\\n                                {fptsHistory.manager.name}\\n                                {#if !allTime  && cleanName(fptsHistory.manager.name) != cleanName(currentManagers[fptsHistory.rosterID].name)}\\n                                    <div class=\\"curRecordManager\\">({currentManagers[fptsHistory.rosterID].name})</div>\\n                                {/if}\\n                            </Cell>\\n                            <Cell>{fptsHistory.fptsFor}</Cell>\\n                            <Cell>{fptsHistory.fptsAgainst}</Cell>\\n                        </Row>\\n                    {/each}\\n                </Body>\\n            </DataTable>\\n        </div>\\n\\n        <div class=\\"rankingTableWrapper\\">\\n            <DataTable class=\\"rankingTable\\">\\n                <Head>\\n                    <Row>\\n                        <Cell class=\\"header\\" colspan=4>\\n                            {prefix} Transaction Totals\\n                        </Cell>\\n                    </Row>\\n                    <Row>\\n                        <Cell class=\\"header\\"></Cell>\\n                        <Cell class=\\"header\\">Manager</Cell>\\n                        <Cell class=\\"header\\">Trades</Cell>\\n                        <Cell class=\\"header\\">Waivers</Cell>\\n                    </Row>\\n                </Head>\\n                <Body>\\n                    {#each transactions as transaction, ix}\\n                        <Row>\\n                            <Cell>{ix + 1}</Cell>\\n                            <Cell class=\\"cellName\\" on:click={() => gotoManager(transaction.rosterID)}>\\n                                {transaction.manager.name}\\n                                {#if !allTime  && cleanName(transaction.manager.name) != cleanName(currentManagers[transaction.rosterID].name)}\\n                                    <div class=\\"curRecordManager\\">({currentManagers[transaction.rosterID].name})</div>\\n                                {/if}\\n                            </Cell>\\n                            <Cell>{transaction.trades}</Cell>\\n                            <Cell>{transaction.waivers}</Cell>\\n                        </Row>\\n                    {/each}\\n                </Body>\\n            </DataTable>\\n        </div>\\n\\n    </div>\\n</div>\\n\\n<div class=\\"buttonHolder\\">\\n    <Group variant=\\"outlined\\">\\n        {#each tables as table, ix}\\n            <Button class=\\"selectionButtons\\" on:click={() => curTable = ix} variant=\\"{curTable == ix ? \\"raised\\" : \\"outlined\\"}\\">\\n                <Label>{table}</Label>\\n            </Button>\\n        {/each}\\n    </Group>\\n</div>\\n\\n{#if !last}\\n    <hr />\\n{/if}"],"names":[],"mappings":"AAmMY,OAAO,AAAE,CAAC,AACd,UAAU,CAAE,MAAM,AACtB,CAAC,AAEO,YAAY,AAAE,CAAC,AACnB,UAAU,CAAE,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI,CAAC,IAAI,cAAc,CAAC,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI,cAAc,CAAC,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI,gBAAgB,CAAC,CAC5H,MAAM,CAAE,GAAG,AACf,CAAC,AAEO,aAAa,AAAE,CAAC,AACpB,OAAO,CAAE,KAAK,CACd,UAAU,CAAE,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI,CAAC,IAAI,cAAc,CAAC,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI,cAAc,CAAC,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI,gBAAgB,CAAC,CAC5H,MAAM,CAAE,GAAG,CAAC,IAAI,CAAC,KAAK,AAC1B,CAAC,AAED,SAAS,cAAC,CAAC,AACP,OAAO,CAAE,IAAI,CACb,SAAS,CAAE,IAAI,CACf,eAAe,CAAE,YAAY,CAC7B,MAAM,CAAE,GAAG,CAAC,IAAI,CAAC,GAAG,AACxB,CAAC,AAED,cAAc,cAAC,CAAC,AACZ,OAAO,CAAE,KAAK,CACd,KAAK,CAAE,IAAI,CACX,UAAU,CAAE,MAAM,AACtB,CAAC,AAED,SAAS,cAAC,CAAC,AACP,UAAU,CAAE,MAAM,CAClB,SAAS,CAAE,KAAK,CAChB,KAAK,CAAE,IAAI,CACX,WAAW,CAAE,KAAK,AACtB,CAAC,AAOD,EAAE,cAAC,CAAC,AACA,UAAU,CAAE,MAAM,CAClB,MAAM,CAAE,GAAG,CAAC,CAAC,CAAC,GAAG,AACrB,CAAC,AAED,iBAAiB,cAAC,CAAC,AACf,UAAU,CAAE,MAAM,CAClB,KAAK,CAAE,IAAI,CACX,SAAS,CAAE,KAAK,CAChB,WAAW,CAAE,KAAK,AACtB,CAAC,AAED,oBAAoB,cAAC,CAAC,AAClB,KAAK,CAAE,GAAG,AACd,CAAC,AAED,aAAa,cAAC,CAAC,AACX,QAAQ,CAAE,QAAQ,CAClB,OAAO,CAAE,IAAI,CACb,SAAS,CAAE,MAAM,CACjB,KAAK,CAAE,IAAI,CACjB,UAAU,CAAE,WAAW,CAAC,IAAI,AAC1B,CAAC,AAED,aAAa,cAAC,CAAC,AACX,UAAU,CAAE,MAAM,CAClB,MAAM,CAAE,GAAG,CAAC,CAAC,CAAC,GAAG,AACrB,CAAC,AAEO,SAAS,AAAE,CAAC,AAChB,MAAM,CAAE,OAAO,CACf,WAAW,CAAE,KAAK,AACtB,CAAC,AAEO,iBAAiB,AAAE,CAAC,AACxB,OAAO,CAAE,KAAK,CAAC,CAAC,AACpB,CAAC,AAED,OAAO,cAAC,CAAC,AACL,UAAU,CAAE,MAAM,AACtB,CAAC,AAID,MAAM,AAAC,YAAY,KAAK,CAAC,AAAC,CAAC,AACf,+BAA+B,AAAE,CAAC,AACtC,SAAS,CAAE,KAAK,AACpB,CAAC,AACL,CAAC,AAED,MAAM,AAAC,YAAY,KAAK,CAAC,AAAC,CAAC,AACf,+BAA+B,AAAE,CAAC,AACtC,SAAS,CAAE,KAAK,CAChB,OAAO,CAAE,CAAC,CAAC,GAAG,AAClB,CAAC,AACL,CAAC,AAED,MAAM,AAAC,YAAY,KAAK,CAAC,AAAC,CAAC,AACf,+BAA+B,AAAE,CAAC,AACtC,SAAS,CAAE,MAAM,CACjB,OAAO,CAAE,CAAC,CAAC,GAAG,AAClB,CAAC,AACL,CAAC,AAMD,MAAM,AAAC,YAAY,KAAK,CAAC,AAAC,CAAC,AACf,eAAe,AAAE,CAAC,AACtB,SAAS,CAAE,KAAK,CAChB,OAAO,CAAE,GAAG,CAAC,IAAI,AACrB,CAAC,AACO,eAAe,AAAE,CAAC,AACtB,SAAS,CAAE,KAAK,CAChB,OAAO,CAAE,GAAG,CAAC,IAAI,AACrB,CAAC,AACL,CAAC,AAED,MAAM,AAAC,YAAY,KAAK,CAAC,AAAC,CAAC,AACf,KAAK,AAAE,CAAC,AACZ,OAAO,CAAE,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,UAAU,AACrC,CAAC,AACO,KAAK,AAAE,CAAC,AACZ,OAAO,CAAE,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,UAAU,AACrC,CAAC,AACL,CAAC,AAED,MAAM,AAAC,YAAY,KAAK,CAAC,AAAC,CAAC,AACf,eAAe,AAAE,CAAC,AACtB,SAAS,CAAE,KAAK,CAChB,OAAO,CAAE,GAAG,CAAC,IAAI,AACrB,CAAC,AACO,eAAe,AAAE,CAAC,AACtB,SAAS,CAAE,KAAK,CAChB,OAAO,CAAE,GAAG,CAAC,IAAI,AACrB,CAAC,AACL,CAAC,AAED,MAAM,AAAC,YAAY,KAAK,CAAC,AAAC,CAAC,AACf,eAAe,AAAE,CAAC,AACtB,SAAS,CAAE,KAAK,CAChB,OAAO,CAAE,GAAG,CAAC,GAAG,AACpB,CAAC,AACO,eAAe,AAAE,CAAC,AACtB,SAAS,CAAE,KAAK,CAChB,OAAO,CAAE,GAAG,CAAC,GAAG,AACpB,CAAC,AACL,CAAC,AAMD,MAAM,AAAC,YAAY,KAAK,CAAC,AAAC,CAAC,AACf,gBAAgB,AAAE,CAAC,AACvB,SAAS,CAAE,KAAK,CAChB,SAAS,CAAE,KAAK,CAChB,WAAW,CAAE,YAAY,CACzB,OAAO,CAAE,GAAG,CAAC,IAAI,AACrB,CAAC,AACO,gBAAgB,AAAE,CAAC,AACvB,SAAS,CAAE,KAAK,CAChB,SAAS,CAAE,KAAK,CAChB,WAAW,CAAE,YAAY,CACzB,OAAO,CAAE,GAAG,CAAC,IAAI,AACrB,CAAC,AACL,CAAC,AAED,MAAM,AAAC,YAAY,KAAK,CAAC,AAAC,CAAC,AACf,gBAAgB,AAAE,CAAC,AACvB,SAAS,CAAE,KAAK,CAChB,SAAS,CAAE,IAAI,CACf,WAAW,CAAE,YAAY,CACzB,OAAO,CAAE,GAAG,CAAC,IAAI,AACrB,CAAC,AACO,gBAAgB,AAAE,CAAC,AACvB,SAAS,CAAE,KAAK,CAChB,SAAS,CAAE,IAAI,CACf,WAAW,CAAE,YAAY,CACzB,OAAO,CAAE,GAAG,CAAC,IAAI,AACrB,CAAC,AACL,CAAC,AAED,MAAM,AAAC,YAAY,KAAK,CAAC,AAAC,CAAC,AACf,gBAAgB,AAAE,CAAC,AACvB,SAAS,CAAE,MAAM,CACjB,SAAS,CAAE,IAAI,CACf,WAAW,CAAE,YAAY,CACzB,OAAO,CAAE,GAAG,CAAC,GAAG,AACpB,CAAC,AACO,gBAAgB,AAAE,CAAC,AACvB,SAAS,CAAE,MAAM,CACjB,SAAS,CAAE,IAAI,CACf,WAAW,CAAE,YAAY,CACzB,OAAO,CAAE,GAAG,CAAC,GAAG,AACpB,CAAC,AACL,CAAC"}`
};
var RecordsAndRankings = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  var _a, _b, _c, _d, _e;
  let { tradesData, waiversData, weekRecords, seasonLongRecords, showTies, winPercentages, fptsHistories, lineupIQs, prefix, blowouts, closestMatchups, currentManagers, allTime = false, last = false } = $$props;
  const lineupIQGraph = {
    stats: lineupIQs,
    x: "Manager",
    y: "Lineup IQ",
    stat: "%",
    header: "Manager Lineup IQ",
    field: "iq",
    short: "Lineup IQ"
  };
  const potentialPointsGraph = {
    stats: lineupIQs,
    x: "Manager",
    y: "Points",
    stat: "",
    header: "Potential Points vs Points",
    field: "potentialPoints",
    secondField: "fpts",
    short: "Potential Points"
  };
  const winsGraph = {
    stats: winPercentages,
    x: "Manager",
    y: "Wins",
    stat: "",
    header: "Team Wins",
    field: "wins",
    short: "Wins"
  };
  const winPercentagesGraph = {
    stats: winPercentages,
    x: "Manager",
    y: "Win Percentage",
    stat: "%",
    header: "Team Win Percentages",
    field: "percentage",
    short: "Win Percentage"
  };
  const fptsHistoriesGraph = {
    stats: fptsHistories,
    x: "Manager",
    y: "Fantasy Points",
    stat: "",
    header: "Team Fantasy Points",
    field: "fptsFor",
    short: "Fantasy Points"
  };
  for (let i = 1; i <= waiversData.length; i++) {
    if (!tradesData.find((t) => t.rosterID == i)) {
      tradesData.push({
        rosterID: i,
        manager: currentManagers[i],
        trades: 0
      });
    }
  }
  const tradesGraph = {
    stats: tradesData,
    x: "Manager",
    y: "# of trades",
    stat: "",
    header: "Trades Managers Have Made",
    field: "trades",
    short: "Trades"
  };
  const waiversGraph = {
    stats: waiversData,
    x: "Manager",
    y: "# of Waiver Moves",
    stat: "",
    header: "Waivers Managers Have Made",
    field: "waivers",
    short: "Waivers"
  };
  const graphs = [];
  if ((_a = lineupIQs[0]) == null ? void 0 : _a.potentialPoints) {
    graphs.push(generateGraph(lineupIQGraph));
  }
  graphs.push(generateGraph(winsGraph, 5));
  graphs.push(generateGraph(winPercentagesGraph));
  graphs.push(generateGraph(fptsHistoriesGraph));
  if ((_b = lineupIQs[0]) == null ? void 0 : _b.potentialPoints) {
    graphs.push(generateGraph(potentialPointsGraph, 10, 0));
  }
  graphs.push(generateGraph(tradesGraph));
  graphs.push(generateGraph(waiversGraph));
  const transactions = [];
  for (let i = 1; i <= waiversData.length; i++) {
    const waiver = waiversData.find((w) => w.rosterID == i);
    const trades = ((_c = tradesData.find((t) => t.rosterID == i)) == null ? void 0 : _c.trades) || 0;
    const waivers = (waiver == null ? void 0 : waiver.waivers) || 0;
    const manager = waiver.manager;
    transactions.push({ rosterID: i, manager, trades, waivers });
  }
  let curTable = 0;
  let curGraph = 0;
  let iqOffset = 0;
  const tables = ["Win Percentages", "Points", "Transactions"];
  if (!((_d = lineupIQs[0]) == null ? void 0 : _d.potentialPoints)) {
    iqOffset = 1;
  } else {
    tables.unshift("Lineup IQs");
  }
  const changeTable = (newGraph) => {
    switch (newGraph) {
      case 0 - iqOffset:
      case 4 + 99 * iqOffset:
        curTable = 0;
        break;
      case 1 - iqOffset:
      case 2 - iqOffset:
        curTable = 1 - iqOffset;
        break;
      case 3 - iqOffset:
        curTable = 2 - iqOffset;
        break;
      case 5 - 2 * iqOffset:
      case 6 - 2 * iqOffset:
        curTable = 3 - iqOffset;
        break;
      default:
        curTable = 0;
        break;
    }
  };
  const changeGraph = (newTable) => {
    switch (newTable) {
      case 0 - iqOffset:
        if (curGraph == 0 || curGraph == 4) {
          break;
        }
        curGraph = 0;
        break;
      case 1 - iqOffset:
        if (curGraph == 1 - iqOffset || curGraph == 2 - iqOffset) {
          break;
        }
        curGraph = 1 - iqOffset;
        break;
      case 2 - iqOffset:
        curGraph = 3 - iqOffset;
        break;
      case 3 - iqOffset:
        if (curGraph == 5 - 2 * iqOffset || curGraph == 6 - 2 * iqOffset) {
          break;
        }
        curGraph = 5 - 2 * iqOffset;
        break;
      default:
        curGraph = 0;
        break;
    }
  };
  let innerWidth;
  if ($$props.tradesData === void 0 && $$bindings.tradesData && tradesData !== void 0)
    $$bindings.tradesData(tradesData);
  if ($$props.waiversData === void 0 && $$bindings.waiversData && waiversData !== void 0)
    $$bindings.waiversData(waiversData);
  if ($$props.weekRecords === void 0 && $$bindings.weekRecords && weekRecords !== void 0)
    $$bindings.weekRecords(weekRecords);
  if ($$props.seasonLongRecords === void 0 && $$bindings.seasonLongRecords && seasonLongRecords !== void 0)
    $$bindings.seasonLongRecords(seasonLongRecords);
  if ($$props.showTies === void 0 && $$bindings.showTies && showTies !== void 0)
    $$bindings.showTies(showTies);
  if ($$props.winPercentages === void 0 && $$bindings.winPercentages && winPercentages !== void 0)
    $$bindings.winPercentages(winPercentages);
  if ($$props.fptsHistories === void 0 && $$bindings.fptsHistories && fptsHistories !== void 0)
    $$bindings.fptsHistories(fptsHistories);
  if ($$props.lineupIQs === void 0 && $$bindings.lineupIQs && lineupIQs !== void 0)
    $$bindings.lineupIQs(lineupIQs);
  if ($$props.prefix === void 0 && $$bindings.prefix && prefix !== void 0)
    $$bindings.prefix(prefix);
  if ($$props.blowouts === void 0 && $$bindings.blowouts && blowouts !== void 0)
    $$bindings.blowouts(blowouts);
  if ($$props.closestMatchups === void 0 && $$bindings.closestMatchups && closestMatchups !== void 0)
    $$bindings.closestMatchups(closestMatchups);
  if ($$props.currentManagers === void 0 && $$bindings.currentManagers && currentManagers !== void 0)
    $$bindings.currentManagers(currentManagers);
  if ($$props.allTime === void 0 && $$bindings.allTime && allTime !== void 0)
    $$bindings.allTime(allTime);
  if ($$props.last === void 0 && $$bindings.last && last !== void 0)
    $$bindings.last(last);
  $$result.css.add(css$m);
  let $$settled;
  let $$rendered;
  do {
    $$settled = true;
    {
      changeTable(curGraph);
    }
    {
      changeGraph(curTable);
    }
    $$rendered = `



<h4 class="${"svelte-g4jcp2"}">${escape(prefix)} Records</h4>

<div class="${"fullFlex svelte-g4jcp2"}">${weekRecords && weekRecords.length ? `${validate_component(DataTable, "DataTable").$$render($$result, { class: "recordTable" }, {}, {
      default: () => `${validate_component(Head, "Head").$$render($$result, {}, {}, {
        default: () => `${validate_component(Row, "Row").$$render($$result, {}, {}, {
          default: () => `${validate_component(Cell, "Cell").$$render($$result, { class: "header", colspan: "4" }, {}, {
            default: () => `${escape(prefix)} Single Week Scoring Records`
          })}`
        })}
                ${validate_component(Row, "Row").$$render($$result, {}, {}, {
          default: () => `${validate_component(Cell, "Cell").$$render($$result, { class: "header rank" }, {}, {})}
                    ${validate_component(Cell, "Cell").$$render($$result, { class: "header" }, {}, { default: () => `Manager` })}
                    ${validate_component(Cell, "Cell").$$render($$result, { class: "header" }, {}, { default: () => `Week` })}
                    ${validate_component(Cell, "Cell").$$render($$result, { class: "header" }, {}, { default: () => `Total Points` })}`
        })}`
      })}
            ${validate_component(Body2, "Body").$$render($$result, {}, {}, {
        default: () => `${each(weekRecords, (leagueWeekRecord, ix) => `${validate_component(Row, "Row").$$render($$result, {}, {}, {
          default: () => `${validate_component(Cell, "Cell").$$render($$result, { class: "rank" }, {}, { default: () => `${escape(ix + 1)}` })}
                        ${validate_component(Cell, "Cell").$$render($$result, { class: "cellName" }, {}, {
            default: () => `${escape(leagueWeekRecord.manager.name)}
                            ${!allTime && cleanName(leagueWeekRecord.manager.name) != cleanName(currentManagers[leagueWeekRecord.rosterID].name) ? `<div class="${"curRecordManager svelte-g4jcp2"}">(${escape(currentManagers[leagueWeekRecord.rosterID].name)})</div>` : ``}
                        `
          })}
                        ${validate_component(Cell, "Cell").$$render($$result, {}, {}, {
            default: () => `${escape(allTime ? leagueWeekRecord.year + " " : "")}Week ${escape(leagueWeekRecord.week)}`
          })}
                        ${validate_component(Cell, "Cell").$$render($$result, {}, {}, {
            default: () => `${escape(round(leagueWeekRecord.fpts))}`
          })}
                    `
        })}`)}`
      })}`
    })}` : ``}

    ${validate_component(DataTable, "DataTable").$$render($$result, { class: "recordTable" }, {}, {
      default: () => `${validate_component(Head, "Head").$$render($$result, {}, {}, {
        default: () => `${validate_component(Row, "Row").$$render($$result, {}, {}, {
          default: () => `${validate_component(Cell, "Cell").$$render($$result, { class: "header", colspan: "4" }, {}, {
            default: () => `${escape(prefix)} Season-long Scoring Records`
          })}`
        })}
            ${validate_component(Row, "Row").$$render($$result, {}, {}, {
          default: () => `${validate_component(Cell, "Cell").$$render($$result, { class: "header rank" }, {}, {})}
                ${validate_component(Cell, "Cell").$$render($$result, { class: "header" }, {}, { default: () => `Manager` })}
                ${allTime ? `${validate_component(Cell, "Cell").$$render($$result, { class: "header" }, {}, { default: () => `Year` })}` : ``}
                ${validate_component(Cell, "Cell").$$render($$result, { class: "header" }, {}, { default: () => `Total Points` })}`
        })}`
      })}
        ${validate_component(Body2, "Body").$$render($$result, {}, {}, {
        default: () => `${each(seasonLongRecords, (mostSeasonLongPoint, ix) => `${validate_component(Row, "Row").$$render($$result, {}, {}, {
          default: () => `${validate_component(Cell, "Cell").$$render($$result, { class: "rank" }, {}, { default: () => `${escape(ix + 1)}` })}
                    ${validate_component(Cell, "Cell").$$render($$result, { class: "cellName" }, {}, {
            default: () => `${escape(mostSeasonLongPoint.manager.name)}
                        ${!allTime && cleanName(mostSeasonLongPoint.manager.name) != cleanName(currentManagers[mostSeasonLongPoint.rosterID].name) ? `<div class="${"curRecordManager svelte-g4jcp2"}">(${escape(currentManagers[mostSeasonLongPoint.rosterID].name)})</div>` : ``}
                    `
          })}
                    ${allTime ? `${validate_component(Cell, "Cell").$$render($$result, {}, {}, {
            default: () => `${escape(mostSeasonLongPoint.year)}`
          })}` : ``}
                    ${validate_component(Cell, "Cell").$$render($$result, {}, {}, {
            default: () => `${escape(mostSeasonLongPoint.fpts)}`
          })}
                `
        })}`)}`
      })}`
    })}

    ${blowouts && blowouts.length ? `${validate_component(DataTable, "DataTable").$$render($$result, { class: "recordTable" }, {}, {
      default: () => `${validate_component(Head, "Head").$$render($$result, {}, {}, {
        default: () => `${validate_component(Row, "Row").$$render($$result, {}, {}, {
          default: () => `${validate_component(Cell, "Cell").$$render($$result, { class: "header", colspan: "4" }, {}, {
            default: () => `${escape(prefix)} Largest Blowouts`
          })}`
        })}
                ${validate_component(Row, "Row").$$render($$result, {}, {}, {
          default: () => `${validate_component(Cell, "Cell").$$render($$result, { class: "header rank" }, {}, {})}
                    ${validate_component(Cell, "Cell").$$render($$result, { class: "header" }, {}, { default: () => `Matchup` })}
                    ${validate_component(Cell, "Cell").$$render($$result, { class: "header" }, {}, { default: () => `Week` })}
                    ${validate_component(Cell, "Cell").$$render($$result, { class: "header" }, {}, { default: () => `Differential` })}`
        })}`
      })}
            ${validate_component(Body2, "Body").$$render($$result, {}, {}, {
        default: () => `${each(blowouts, (blowout, ix) => `${validate_component(Row, "Row").$$render($$result, {}, {}, {
          default: () => `${validate_component(Cell, "Cell").$$render($$result, { class: "rank" }, {}, { default: () => `${escape(ix + 1)}` })}
                        ${validate_component(Cell, "Cell").$$render($$result, {
            class: "cellName center differentialName"
          }, {}, {
            default: () => `<div class="${"center svelte-g4jcp2"}">${escape(blowout.home.manager.name)} (${escape(round(blowout.home.fpts))})
                                ${!allTime && cleanName(blowout.home.manager.name) != cleanName(currentManagers[blowout.home.rosterID].name) ? `<div class="${"curRecordManager svelte-g4jcp2"}">(${escape(currentManagers[blowout.home.rosterID].name)})</div>` : ``}</div>
                            vs
                            <div class="${"center svelte-g4jcp2"}">${escape(blowout.away.manager.name)} (${escape(round(blowout.away.fpts))})
                                ${!allTime && cleanName(blowout.away.manager.name) != cleanName(currentManagers[blowout.away.rosterID].name) ? `<div class="${"curRecordManager svelte-g4jcp2"}">(${escape(currentManagers[blowout.away.rosterID].name)})</div>` : ``}</div>
                        `
          })}
                        ${validate_component(Cell, "Cell").$$render($$result, {}, {}, {
            default: () => `${escape(allTime ? blowout.year + " " : "")}Week ${escape(blowout.week)}`
          })}
                        ${validate_component(Cell, "Cell").$$render($$result, {}, {}, {
            default: () => `${escape(round(blowout.differential))}`
          })}
                    `
        })}`)}`
      })}`
    })}` : ``}

    ${closestMatchups && closestMatchups.length ? `${validate_component(DataTable, "DataTable").$$render($$result, { class: "recordTable" }, {}, {
      default: () => `${validate_component(Head, "Head").$$render($$result, {}, {}, {
        default: () => `${validate_component(Row, "Row").$$render($$result, {}, {}, {
          default: () => `${validate_component(Cell, "Cell").$$render($$result, { class: "header", colspan: "4" }, {}, {
            default: () => `${escape(prefix)} Narrowest Wins`
          })}`
        })}
                ${validate_component(Row, "Row").$$render($$result, {}, {}, {
          default: () => `${validate_component(Cell, "Cell").$$render($$result, { class: "header rank" }, {}, {})}
                    ${validate_component(Cell, "Cell").$$render($$result, { class: "header" }, {}, { default: () => `Matchup` })}
                    ${validate_component(Cell, "Cell").$$render($$result, { class: "header" }, {}, { default: () => `Week` })}
                    ${validate_component(Cell, "Cell").$$render($$result, { class: "header" }, {}, { default: () => `Differential` })}`
        })}`
      })}
            ${validate_component(Body2, "Body").$$render($$result, {}, {}, {
        default: () => `${each(closestMatchups, (closestMatchup, ix) => `${validate_component(Row, "Row").$$render($$result, {}, {}, {
          default: () => `${validate_component(Cell, "Cell").$$render($$result, { class: "rank" }, {}, { default: () => `${escape(ix + 1)}` })}
                        ${validate_component(Cell, "Cell").$$render($$result, {
            class: "cellName center differentialName"
          }, {}, {
            default: () => `<div class="${"center svelte-g4jcp2"}">${escape(closestMatchup.home.manager.name)} (${escape(round(closestMatchup.home.fpts))})
                                ${!allTime && cleanName(closestMatchup.home.manager.name) != cleanName(currentManagers[closestMatchup.home.rosterID].name) ? `<div class="${"curRecordManager svelte-g4jcp2"}">(${escape(currentManagers[closestMatchup.home.rosterID].name)})</div>` : ``}</div>
                            vs
                            <div class="${"center svelte-g4jcp2"}">${escape(closestMatchup.away.manager.name)} (${escape(round(closestMatchup.away.fpts))})
                                ${!allTime && cleanName(closestMatchup.away.manager.name) != cleanName(currentManagers[closestMatchup.away.rosterID].name) ? `<div class="${"curRecordManager svelte-g4jcp2"}">(${escape(currentManagers[closestMatchup.away.rosterID].name)})</div>` : ``}</div>
                        `
          })}
                        ${validate_component(Cell, "Cell").$$render($$result, {}, {}, {
            default: () => `${escape(allTime ? closestMatchup.year + " " : "")}Week ${escape(closestMatchup.week)}`
          })}
                        ${validate_component(Cell, "Cell").$$render($$result, {}, {}, {
            default: () => `${escape(round(closestMatchup.differential))}`
          })}
                    `
        })}`)}`
      })}`
    })}` : ``}</div>

<h4 class="${"svelte-g4jcp2"}">${escape(prefix)} Rankings</h4>

${validate_component(BarChart, "BarChart").$$render($$result, { maxWidth: innerWidth, graphs, curGraph }, {
      curGraph: ($$value) => {
        curGraph = $$value;
        $$settled = false;
      }
    }, {})}

<div class="${"rankingHolder svelte-g4jcp2"}"><div class="${"rankingInner svelte-g4jcp2"}" style="${"margin-left: -" + escape(100 * curTable) + "%;"}">${((_e = lineupIQs[0]) == null ? void 0 : _e.potentialPoints) ? `<div class="${"rankingTableWrapper svelte-g4jcp2"}">${validate_component(DataTable, "DataTable").$$render($$result, { class: "rankingTable" }, {}, {
      default: () => `${validate_component(Head, "Head").$$render($$result, {}, {}, {
        default: () => `${validate_component(Row, "Row").$$render($$result, {}, {}, {
          default: () => `${validate_component(Cell, "Cell").$$render($$result, { class: "header", colspan: "5" }, {}, {
            default: () => `${escape(prefix)} Lineup IQ Rankings
                                <div class="${"subTitle svelte-g4jcp2"}">The percentage of potential points each manager has captured
                                </div>`
          })}`
        })}
                        ${validate_component(Row, "Row").$$render($$result, {}, {}, {
          default: () => `${validate_component(Cell, "Cell").$$render($$result, { class: "header" }, {}, {})}
                            ${validate_component(Cell, "Cell").$$render($$result, { class: "header" }, {}, { default: () => `Manager` })}
                            ${validate_component(Cell, "Cell").$$render($$result, { class: "header" }, {}, { default: () => `Lineup IQ` })}
                            ${validate_component(Cell, "Cell").$$render($$result, { class: "header" }, {}, { default: () => `Points` })}
                            ${validate_component(Cell, "Cell").$$render($$result, { class: "header" }, {}, { default: () => `Potential Points` })}`
        })}`
      })}
                    ${validate_component(Body2, "Body").$$render($$result, {}, {}, {
        default: () => `${each(lineupIQs, (lineupIQ, ix) => `${validate_component(Row, "Row").$$render($$result, {}, {}, {
          default: () => `${validate_component(Cell, "Cell").$$render($$result, {}, {}, { default: () => `${escape(ix + 1)}` })}
                                ${validate_component(Cell, "Cell").$$render($$result, { class: "cellName" }, {}, {
            default: () => `${escape(lineupIQ.manager.name)}
                                    ${!allTime && cleanName(lineupIQ.manager.name) != cleanName(currentManagers[lineupIQ.rosterID].name) ? `<div class="${"curRecordManager svelte-g4jcp2"}">(${escape(currentManagers[lineupIQ.rosterID].name)})</div>` : ``}
                                `
          })}
                                ${validate_component(Cell, "Cell").$$render($$result, {}, {}, { default: () => `${escape(lineupIQ.iq)}%` })}
                                ${validate_component(Cell, "Cell").$$render($$result, {}, {}, {
            default: () => `${escape(lineupIQ.fpts)}`
          })}
                                ${validate_component(Cell, "Cell").$$render($$result, {}, {}, {
            default: () => `${escape(lineupIQ.potentialPoints)}`
          })}
                            `
        })}`)}`
      })}`
    })}</div>` : ``}

        <div class="${"rankingTableWrapper svelte-g4jcp2"}">${validate_component(DataTable, "DataTable").$$render($$result, { class: "rankingTable" }, {}, {
      default: () => `${validate_component(Head, "Head").$$render($$result, {}, {}, {
        default: () => `${validate_component(Row, "Row").$$render($$result, {}, {}, {
          default: () => `${validate_component(Cell, "Cell").$$render($$result, { class: "header", colspan: "6" }, {}, {
            default: () => `${escape(prefix)} Win Percentages Rankings`
          })}`
        })}
                    ${validate_component(Row, "Row").$$render($$result, {}, {}, {
          default: () => `${validate_component(Cell, "Cell").$$render($$result, { class: "header" }, {}, {})}
                        ${validate_component(Cell, "Cell").$$render($$result, { class: "header" }, {}, { default: () => `Manager` })}
                        ${validate_component(Cell, "Cell").$$render($$result, { class: "header" }, {}, { default: () => `Win %` })}
                        ${validate_component(Cell, "Cell").$$render($$result, { class: "header" }, {}, { default: () => `Wins` })}
                        ${showTies ? `${validate_component(Cell, "Cell").$$render($$result, { class: "header" }, {}, { default: () => `Ties` })}` : ``}
                        ${validate_component(Cell, "Cell").$$render($$result, { class: "header" }, {}, { default: () => `Losses` })}`
        })}`
      })}
                ${validate_component(Body2, "Body").$$render($$result, {}, {}, {
        default: () => `${each(winPercentages, (winPercentage, ix) => `${validate_component(Row, "Row").$$render($$result, {}, {}, {
          default: () => `${validate_component(Cell, "Cell").$$render($$result, {}, {}, { default: () => `${escape(ix + 1)}` })}
                            ${validate_component(Cell, "Cell").$$render($$result, { class: "cellName" }, {}, {
            default: () => `${escape(winPercentage.manager.name)}
                                ${!allTime && cleanName(winPercentage.manager.name) != cleanName(currentManagers[winPercentage.rosterID].name) ? `<div class="${"curRecordManager svelte-g4jcp2"}">(${escape(currentManagers[winPercentage.rosterID].name)})</div>` : ``}
                            `
          })}
                            ${validate_component(Cell, "Cell").$$render($$result, {}, {}, {
            default: () => `${escape(winPercentage.percentage)}%`
          })}
                            ${validate_component(Cell, "Cell").$$render($$result, {}, {}, {
            default: () => `${escape(winPercentage.wins)}`
          })}
                            ${showTies ? `${validate_component(Cell, "Cell").$$render($$result, {}, {}, {
            default: () => `${escape(winPercentage.ties)}`
          })}` : ``}
                            ${validate_component(Cell, "Cell").$$render($$result, {}, {}, {
            default: () => `${escape(winPercentage.losses)}`
          })}
                        `
        })}`)}`
      })}`
    })}</div>

        <div class="${"rankingTableWrapper svelte-g4jcp2"}">${validate_component(DataTable, "DataTable").$$render($$result, { class: "rankingTable" }, {}, {
      default: () => `${validate_component(Head, "Head").$$render($$result, {}, {}, {
        default: () => `${validate_component(Row, "Row").$$render($$result, {}, {}, {
          default: () => `${validate_component(Cell, "Cell").$$render($$result, { class: "header", colspan: "4" }, {}, {
            default: () => `${escape(prefix)} Fantasy Points Rankings
                        `
          })}`
        })}
                    ${validate_component(Row, "Row").$$render($$result, {}, {}, {
          default: () => `${validate_component(Cell, "Cell").$$render($$result, { class: "header" }, {}, {})}
                        ${validate_component(Cell, "Cell").$$render($$result, { class: "header" }, {}, { default: () => `Manager` })}
                        ${validate_component(Cell, "Cell").$$render($$result, { class: "header" }, {}, { default: () => `Points For` })}
                        ${validate_component(Cell, "Cell").$$render($$result, { class: "header" }, {}, { default: () => `Points Against` })}`
        })}`
      })}
                ${validate_component(Body2, "Body").$$render($$result, {}, {}, {
        default: () => `${each(fptsHistories, (fptsHistory, ix) => `${validate_component(Row, "Row").$$render($$result, {}, {}, {
          default: () => `${validate_component(Cell, "Cell").$$render($$result, {}, {}, { default: () => `${escape(ix + 1)}` })}
                            ${validate_component(Cell, "Cell").$$render($$result, { class: "cellName" }, {}, {
            default: () => `${escape(fptsHistory.manager.name)}
                                ${!allTime && cleanName(fptsHistory.manager.name) != cleanName(currentManagers[fptsHistory.rosterID].name) ? `<div class="${"curRecordManager svelte-g4jcp2"}">(${escape(currentManagers[fptsHistory.rosterID].name)})</div>` : ``}
                            `
          })}
                            ${validate_component(Cell, "Cell").$$render($$result, {}, {}, {
            default: () => `${escape(fptsHistory.fptsFor)}`
          })}
                            ${validate_component(Cell, "Cell").$$render($$result, {}, {}, {
            default: () => `${escape(fptsHistory.fptsAgainst)}`
          })}
                        `
        })}`)}`
      })}`
    })}</div>

        <div class="${"rankingTableWrapper svelte-g4jcp2"}">${validate_component(DataTable, "DataTable").$$render($$result, { class: "rankingTable" }, {}, {
      default: () => `${validate_component(Head, "Head").$$render($$result, {}, {}, {
        default: () => `${validate_component(Row, "Row").$$render($$result, {}, {}, {
          default: () => `${validate_component(Cell, "Cell").$$render($$result, { class: "header", colspan: "4" }, {}, {
            default: () => `${escape(prefix)} Transaction Totals
                        `
          })}`
        })}
                    ${validate_component(Row, "Row").$$render($$result, {}, {}, {
          default: () => `${validate_component(Cell, "Cell").$$render($$result, { class: "header" }, {}, {})}
                        ${validate_component(Cell, "Cell").$$render($$result, { class: "header" }, {}, { default: () => `Manager` })}
                        ${validate_component(Cell, "Cell").$$render($$result, { class: "header" }, {}, { default: () => `Trades` })}
                        ${validate_component(Cell, "Cell").$$render($$result, { class: "header" }, {}, { default: () => `Waivers` })}`
        })}`
      })}
                ${validate_component(Body2, "Body").$$render($$result, {}, {}, {
        default: () => `${each(transactions, (transaction, ix) => `${validate_component(Row, "Row").$$render($$result, {}, {}, {
          default: () => `${validate_component(Cell, "Cell").$$render($$result, {}, {}, { default: () => `${escape(ix + 1)}` })}
                            ${validate_component(Cell, "Cell").$$render($$result, { class: "cellName" }, {}, {
            default: () => `${escape(transaction.manager.name)}
                                ${!allTime && cleanName(transaction.manager.name) != cleanName(currentManagers[transaction.rosterID].name) ? `<div class="${"curRecordManager svelte-g4jcp2"}">(${escape(currentManagers[transaction.rosterID].name)})</div>` : ``}
                            `
          })}
                            ${validate_component(Cell, "Cell").$$render($$result, {}, {}, {
            default: () => `${escape(transaction.trades)}`
          })}
                            ${validate_component(Cell, "Cell").$$render($$result, {}, {}, {
            default: () => `${escape(transaction.waivers)}`
          })}
                        `
        })}`)}`
      })}`
    })}</div></div></div>

<div class="${"buttonHolder svelte-g4jcp2"}">${validate_component(Group, "Group").$$render($$result, { variant: "outlined" }, {}, {
      default: () => `${each(tables, (table, ix) => `${validate_component(Button_1, "Button").$$render($$result, {
        class: "selectionButtons",
        variant: curTable == ix ? "raised" : "outlined"
      }, {}, {
        default: () => `${validate_component(CommonLabel, "Label").$$render($$result, {}, {}, { default: () => `${escape(table)}` })}
            `
      })}`)}`
    })}</div>

${!last ? `<hr>` : ``}`;
  } while (!$$settled);
  return $$rendered;
});
var AllTimeRecords = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let { leagueRosterRecords, leagueWeekRecords, allTimeBiggestBlowouts, allTimeClosestMatchups, currentManagers, mostSeasonLongPoints, transactionTotals } = $$props;
  let winPercentages = [];
  let lineupIQs = [];
  const fptsHistories = [];
  const tradesData = [];
  const waiversData = [];
  let showTies = false;
  for (const rosterID in transactionTotals.allTime) {
    tradesData.push({
      rosterID,
      manager: currentManagers[rosterID],
      trades: transactionTotals.allTime[rosterID].trade
    });
    waiversData.push({
      rosterID,
      manager: currentManagers[rosterID],
      waivers: transactionTotals.allTime[rosterID].waiver
    });
  }
  for (const key in leagueRosterRecords) {
    const leagueRosterRecord = leagueRosterRecords[key];
    winPercentages.push({
      rosterID: key,
      manager: currentManagers[key],
      percentage: round((leagueRosterRecord.wins + leagueRosterRecord.ties / 2) / (leagueRosterRecord.wins + leagueRosterRecord.ties + leagueRosterRecord.losses) * 100),
      wins: leagueRosterRecord.wins,
      ties: leagueRosterRecord.ties,
      losses: leagueRosterRecord.losses
    });
    let lineupIQ = {
      rosterID: key,
      manager: currentManagers[key],
      fpts: round(leagueRosterRecord.fptsFor)
    };
    if (leagueRosterRecord.potentialPoints) {
      lineupIQ.iq = round(leagueRosterRecord.fptsFor / leagueRosterRecord.potentialPoints * 100);
      lineupIQ.potentialPoints = round(leagueRosterRecord.potentialPoints);
    }
    lineupIQs.push(lineupIQ);
    fptsHistories.push({
      rosterID: key,
      manager: currentManagers[key],
      fptsFor: round(leagueRosterRecord.fptsFor),
      fptsAgainst: round(leagueRosterRecord.fptsAgainst)
    });
    if (leagueRosterRecord.ties > 0)
      showTies = true;
  }
  winPercentages.sort((a, b) => b.percentage - a.percentage);
  lineupIQs.sort((a, b) => b.iq - a.iq);
  fptsHistories.sort((a, b) => b.fptsFor - a.fptsFor);
  tradesData.sort((a, b) => b.trades - a.trades);
  waiversData.sort((a, b) => b.waivers - a.waivers);
  if ($$props.leagueRosterRecords === void 0 && $$bindings.leagueRosterRecords && leagueRosterRecords !== void 0)
    $$bindings.leagueRosterRecords(leagueRosterRecords);
  if ($$props.leagueWeekRecords === void 0 && $$bindings.leagueWeekRecords && leagueWeekRecords !== void 0)
    $$bindings.leagueWeekRecords(leagueWeekRecords);
  if ($$props.allTimeBiggestBlowouts === void 0 && $$bindings.allTimeBiggestBlowouts && allTimeBiggestBlowouts !== void 0)
    $$bindings.allTimeBiggestBlowouts(allTimeBiggestBlowouts);
  if ($$props.allTimeClosestMatchups === void 0 && $$bindings.allTimeClosestMatchups && allTimeClosestMatchups !== void 0)
    $$bindings.allTimeClosestMatchups(allTimeClosestMatchups);
  if ($$props.currentManagers === void 0 && $$bindings.currentManagers && currentManagers !== void 0)
    $$bindings.currentManagers(currentManagers);
  if ($$props.mostSeasonLongPoints === void 0 && $$bindings.mostSeasonLongPoints && mostSeasonLongPoints !== void 0)
    $$bindings.mostSeasonLongPoints(mostSeasonLongPoints);
  if ($$props.transactionTotals === void 0 && $$bindings.transactionTotals && transactionTotals !== void 0)
    $$bindings.transactionTotals(transactionTotals);
  return `${validate_component(RecordsAndRankings, "RecordsAndRankings").$$render($$result, {
    currentManagers,
    blowouts: allTimeBiggestBlowouts,
    closestMatchups: allTimeClosestMatchups,
    weekRecords: leagueWeekRecords,
    seasonLongRecords: mostSeasonLongPoints,
    showTies,
    winPercentages,
    fptsHistories,
    lineupIQs,
    tradesData,
    waiversData,
    prefix: "All-Time",
    allTime: true
  }, {}, {})}`;
});
var PerSeasonRecords = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let { leagueRosterRecords, seasonWeekRecords, currentManagers, currentYear, lastYear, transactionTotals } = $$props;
  const yearsObj = {};
  const years = [];
  let loopYear = currentYear;
  while (loopYear >= lastYear) {
    yearsObj[loopYear] = {
      seasonLongRecords: [],
      winPercentages: [],
      lineupIQs: [],
      fptsHistories: [],
      tradesData: [],
      waiversData: [],
      blowouts: [],
      closestMatchups: [],
      showTies: false,
      year: loopYear
    };
    loopYear--;
  }
  for (const seasonWeekRecord of seasonWeekRecords) {
    yearsObj[seasonWeekRecord.year].weekRecords = seasonWeekRecord.seasonPointsRecords;
    yearsObj[seasonWeekRecord.year].blowouts = seasonWeekRecord.biggestBlowouts;
    yearsObj[seasonWeekRecord.year].closestMatchups = seasonWeekRecord.closestMatchups;
  }
  for (const season in transactionTotals.seasons) {
    if (!yearsObj[season])
      continue;
    for (const rosterID in transactionTotals.seasons[season]) {
      yearsObj[season].tradesData.push({
        rosterID,
        manager: transactionTotals.seasons[season][rosterID].manager,
        trades: transactionTotals.seasons[season][rosterID].trade
      });
      yearsObj[season].waiversData.push({
        rosterID,
        manager: transactionTotals.seasons[season][rosterID].manager,
        waivers: transactionTotals.seasons[season][rosterID].waiver
      });
    }
  }
  for (const rosterID in leagueRosterRecords) {
    const leagueRosterRecord = leagueRosterRecords[rosterID];
    for (const season of leagueRosterRecord.years) {
      if (season.ties > 0) {
        yearsObj[season.year].showTies = true;
      }
      const fpts = round(season.fpts);
      yearsObj[season.year].seasonLongRecords.push({
        manager: season.manager,
        rosterID,
        fpts,
        year: null
      });
      yearsObj[season.year].winPercentages.push({
        rosterID,
        manager: season.manager,
        percentage: round((season.wins + season.ties / 2) / (season.wins + season.ties + season.losses) * 100),
        wins: season.wins,
        ties: season.ties,
        losses: season.losses
      });
      let lineupIQ = {
        rosterID,
        manager: season.manager,
        fpts: round(season.fpts)
      };
      if (season.potentialPoints) {
        lineupIQ.iq = round(season.fpts / season.potentialPoints * 100);
        lineupIQ.potentialPoints = round(season.potentialPoints);
      }
      yearsObj[season.year].lineupIQs.push(lineupIQ);
      yearsObj[season.year].fptsHistories.push({
        rosterID,
        manager: season.manager,
        fptsFor: round(season.fpts),
        fptsAgainst: round(season.fptsAgainst)
      });
    }
  }
  for (const key in yearsObj) {
    yearsObj[key].seasonLongRecords = yearsObj[key].seasonLongRecords.sort((a, b) => b.fpts - a.fpts).slice(0, 10);
    yearsObj[key].winPercentages.sort((a, b) => b.percentage - a.percentage);
    yearsObj[key].lineupIQs.sort((a, b) => b.iq - a.iq);
    yearsObj[key].fptsHistories.sort((a, b) => b.fptsFor - a.fptsFor);
    yearsObj[key].tradesData.sort((a, b) => b.trades - a.trades);
    yearsObj[key].waiversData.sort((a, b) => b.waivers - a.waivers);
    years.push(yearsObj[key]);
  }
  years.sort((a, b) => b.year - a.year);
  if ($$props.leagueRosterRecords === void 0 && $$bindings.leagueRosterRecords && leagueRosterRecords !== void 0)
    $$bindings.leagueRosterRecords(leagueRosterRecords);
  if ($$props.seasonWeekRecords === void 0 && $$bindings.seasonWeekRecords && seasonWeekRecords !== void 0)
    $$bindings.seasonWeekRecords(seasonWeekRecords);
  if ($$props.currentManagers === void 0 && $$bindings.currentManagers && currentManagers !== void 0)
    $$bindings.currentManagers(currentManagers);
  if ($$props.currentYear === void 0 && $$bindings.currentYear && currentYear !== void 0)
    $$bindings.currentYear(currentYear);
  if ($$props.lastYear === void 0 && $$bindings.lastYear && lastYear !== void 0)
    $$bindings.lastYear(lastYear);
  if ($$props.transactionTotals === void 0 && $$bindings.transactionTotals && transactionTotals !== void 0)
    $$bindings.transactionTotals(transactionTotals);
  return `${each(years, ({ waiversData, tradesData, weekRecords, seasonLongRecords, showTies, winPercentages, fptsHistories, lineupIQs, year, blowouts, closestMatchups }, ix) => `${validate_component(RecordsAndRankings, "RecordsAndRankings").$$render($$result, {
    waiversData,
    tradesData,
    weekRecords,
    seasonLongRecords,
    showTies,
    winPercentages,
    fptsHistories,
    lineupIQs,
    blowouts,
    closestMatchups,
    prefix: year,
    currentManagers,
    last: ix == years.length - 1
  }, {}, {})}`)}`;
});
var css$l = {
  code: ".rankingsWrapper.svelte-tbu7xb{margin:0 auto;width:100%;max-width:1200px}.empty.svelte-tbu7xb{margin:10em 0 4em;text-align:center}",
  map: `{"version":3,"file":"index.svelte","sources":["index.svelte"],"sourcesContent":["<script>\\n    import { getLeagueRecords, getLeagueTransactions } from '$lib/utils/helper';\\n\\n    import AllTimeRecords from './AllTimeRecords.svelte';\\n    import PerSeasonRecords from './PerSeasonRecords.svelte';\\n\\n    export let leagueRecords, totals, stale;\\n\\n    const refreshTransactions = async () => {\\n        const newTransactions = await getLeagueTransactions(false, true);\\n        totals = newTransactions.totals;\\n    }\\n\\n    let {leagueRosterRecords, leagueWeekRecords, allTimeClosestMatchups, allTimeBiggestBlowouts, currentManagers, mostSeasonLongPoints, seasonWeekRecords, currentYear, lastYear} = leagueRecords;\\n\\n    const refreshRecords = async () => {\\n        const newRecords = await getLeagueRecords(true);\\n\\n        // update values with new data\\n        leagueRecords = newRecords;\\n        leagueRosterRecords = newRecords.leagueRosterRecords;\\n        leagueWeekRecords = newRecords.leagueWeekRecords;\\n        allTimeClosestMatchups = newRecords.allTimeClosestMatchups;\\n        allTimeBiggestBlowouts = newRecords.allTimeBiggestBlowouts;\\n        currentManagers = newRecords.currentManagers;\\n        mostSeasonLongPoints = newRecords.mostSeasonLongPoints;\\n        seasonWeekRecords = newRecords.seasonWeekRecords;\\n        currentYear = newRecords.currentYear;\\n        lastYear = newRecords.lastYear;\\n    }\\n\\n    if(stale) {\\n        refreshTransactions();\\n    }\\n\\n    if(leagueRecords.stale) {\\n        refreshRecords();\\n    }\\n\\n<\/script>\\n\\n<style>\\n    .rankingsWrapper {\\n        margin: 0 auto;\\n        width: 100%;\\n        max-width: 1200px;\\n    }\\n\\n    .empty {\\n        margin: 10em 0 4em;\\n        text-align: center;\\n    }\\n</style>\\n\\n<div class=\\"rankingsWrapper\\">\\n    {#if leagueWeekRecords.length}\\n        <AllTimeRecords transactionTotals={totals} {allTimeClosestMatchups} {allTimeBiggestBlowouts} {leagueRosterRecords} {leagueWeekRecords} {currentManagers} {mostSeasonLongPoints} />\\n    {:else}\\n        <p class=\\"empty\\">No records <i>yet</i>...</p>\\n    {/if}\\n    <PerSeasonRecords transactionTotals={totals} {leagueRosterRecords} {seasonWeekRecords} {currentManagers} {currentYear} {lastYear} />\\n</div>\\n"],"names":[],"mappings":"AA0CI,gBAAgB,cAAC,CAAC,AACd,MAAM,CAAE,CAAC,CAAC,IAAI,CACd,KAAK,CAAE,IAAI,CACX,SAAS,CAAE,MAAM,AACrB,CAAC,AAED,MAAM,cAAC,CAAC,AACJ,MAAM,CAAE,IAAI,CAAC,CAAC,CAAC,GAAG,CAClB,UAAU,CAAE,MAAM,AACtB,CAAC"}`
};
var Records = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let { leagueRecords, totals, stale } = $$props;
  const refreshTransactions = async () => {
    const newTransactions = await getLeagueTransactions(false, true);
    totals = newTransactions.totals;
  };
  let { leagueRosterRecords, leagueWeekRecords, allTimeClosestMatchups, allTimeBiggestBlowouts, currentManagers, mostSeasonLongPoints, seasonWeekRecords, currentYear, lastYear } = leagueRecords;
  const refreshRecords = async () => {
    const newRecords = await getLeagueRecords(true);
    leagueRecords = newRecords;
    leagueRosterRecords = newRecords.leagueRosterRecords;
    leagueWeekRecords = newRecords.leagueWeekRecords;
    allTimeClosestMatchups = newRecords.allTimeClosestMatchups;
    allTimeBiggestBlowouts = newRecords.allTimeBiggestBlowouts;
    currentManagers = newRecords.currentManagers;
    mostSeasonLongPoints = newRecords.mostSeasonLongPoints;
    seasonWeekRecords = newRecords.seasonWeekRecords;
    currentYear = newRecords.currentYear;
    lastYear = newRecords.lastYear;
  };
  if (stale) {
    refreshTransactions();
  }
  if (leagueRecords.stale) {
    refreshRecords();
  }
  if ($$props.leagueRecords === void 0 && $$bindings.leagueRecords && leagueRecords !== void 0)
    $$bindings.leagueRecords(leagueRecords);
  if ($$props.totals === void 0 && $$bindings.totals && totals !== void 0)
    $$bindings.totals(totals);
  if ($$props.stale === void 0 && $$bindings.stale && stale !== void 0)
    $$bindings.stale(stale);
  $$result.css.add(css$l);
  return `<div class="${"rankingsWrapper svelte-tbu7xb"}">${leagueWeekRecords.length ? `${validate_component(AllTimeRecords, "AllTimeRecords").$$render($$result, {
    transactionTotals: totals,
    allTimeClosestMatchups,
    allTimeBiggestBlowouts,
    leagueRosterRecords,
    leagueWeekRecords,
    currentManagers,
    mostSeasonLongPoints
  }, {}, {})}` : `<p class="${"empty svelte-tbu7xb"}">No records <i>yet</i>...</p>`}
    ${validate_component(PerSeasonRecords, "PerSeasonRecords").$$render($$result, {
    transactionTotals: totals,
    leagueRosterRecords,
    seasonWeekRecords,
    currentManagers,
    currentYear,
    lastYear
  }, {}, {})}</div>`;
});
var css$k = {
  code: ".manager.svelte-9hqn7f{display:flex;justify-content:left;align-items:center;padding:1em 0;background-color:var(--fff);margin:0.5em 0;border-radius:2em;border:1px solid var(--ccc);box-shadow:0 0 6px 0 var(--bbb);cursor:pointer}.manager.svelte-9hqn7f:hover{box-shadow:0 0 10px 0 bar(--g999);background-color:bar(--eee)}.photo.svelte-9hqn7f{height:40px;width:40px;border-radius:100%;vertical-align:middle;margin-left:1em;box-shadow:0 0 2px 1px var(--bbb)}.name.svelte-9hqn7f{text-align:center;display:inline-block;color:var(--g555);line-height:1.2em;margin-left:1em;font-weight:700}.team.svelte-9hqn7f{text-align:center;display:inline-block;font-style:italic;line-height:1.2em;color:var(--g555);font-weight:300;margin-left:1em}.spacer.svelte-9hqn7f{flex-grow:1}.info.svelte-9hqn7f{display:flex}.infoSlot.svelte-9hqn7f{text-align:center;margin:0 0.5em;width:63px}.infoIcon.svelte-9hqn7f{display:inline-flex;height:40px;width:40px;justify-content:center;align-items:center;border-radius:100%;border:1px solid #ccc;overflow:hidden;background-color:var(--fff)}.infoImg.svelte-9hqn7f{height:30px}.infoAnswer.svelte-9hqn7f{font-size:0.8em;color:var(--g555);width:63px;text-align:center;line-height:1.2em}@media(max-width: 665px){.name.svelte-9hqn7f{font-size:0.9em;margin-left:0.5em}.team.svelte-9hqn7f{font-size:0.8em;margin-left:0.5em}}@media(max-width: 595px){.manager.svelte-9hqn7f{padding:0.5em 0;margin:0.3em 0;border-radius:1.5em}.photo.svelte-9hqn7f{height:30px;width:30px;margin-left:0.5em}.infoSlot.svelte-9hqn7f{text-align:center;margin:0 0.4em;width:56px}.infoIcon.svelte-9hqn7f{height:30px;width:30px}.infoImg.svelte-9hqn7f{height:25px}.infoAnswer.svelte-9hqn7f{font-size:0.7em;width:56px}}@media(max-width: 475px){.name.svelte-9hqn7f{font-size:0.8em;margin-left:0.4em}.team.svelte-9hqn7f{font-size:0.7em;margin-left:0.4em}.photo.svelte-9hqn7f{height:25px;width:25px}.infoSlot.svelte-9hqn7f{text-align:center;margin:0 0.4em;width:49px}.infoIcon.svelte-9hqn7f{height:25px;width:25px}.infoImg.svelte-9hqn7f{height:22px}.infoAnswer.svelte-9hqn7f{font-size:0.6em;width:49px}}@media(max-width: 370px){.infoTeam.svelte-9hqn7f{display:none}}.question.svelte-9hqn7f{background-color:#fff}",
  map: `{"version":3,"file":"ManagerRow.svelte","sources":["ManagerRow.svelte"],"sourcesContent":["<script>\\n    import { goto } from \\"$app/navigation\\";\\n    import {dynasty} from \\"$lib/utils/leagueInfo\\"\\n\\n\\n    export let manager, rosters, users, key;\\n\\n    const roster = rosters.rosters[manager.roster - 1];\\n    const user = users[roster.owner_id];\\n<\/script>\\n\\n<style>\\n    .manager {\\n        display: flex;\\n        justify-content: left;\\n        align-items: center;\\n        padding: 1em 0;\\n        background-color: var(--fff);\\n        margin: 0.5em 0;\\n        border-radius: 2em;\\n        border: 1px solid var(--ccc);\\n        box-shadow: 0 0 6px 0 var(--bbb);\\n        cursor: pointer;\\n    }\\n\\n    .manager:hover {\\n        box-shadow: 0 0 10px 0 bar(--g999);\\n        background-color: bar(--eee);\\n    }\\n\\n    .photo {\\n        height: 40px;\\n        width: 40px;\\n        border-radius: 100%;\\n        vertical-align: middle;\\n        margin-left: 1em;\\n        box-shadow: 0 0 2px 1px var(--bbb);\\n    }\\n\\n    .name {\\n        text-align: center;\\n        display: inline-block;\\n        color: var(--g555);\\n        line-height: 1.2em;\\n        margin-left: 1em;\\n        font-weight: 700;\\n    }\\n\\n    .team {\\n        text-align: center;\\n        display: inline-block;\\n        font-style: italic;\\n        line-height: 1.2em;\\n        color: var(--g555);\\n        font-weight: 300;\\n        margin-left: 1em;\\n    }\\n\\n    .spacer {\\n        flex-grow: 1;\\n    }\\n\\n    .info {\\n        display: flex;\\n    }\\n\\n    .infoSlot {\\n        text-align: center;\\n        margin: 0 0.5em;\\n        width: 63px;\\n    }\\n\\n    .infoIcon {\\n        display: inline-flex;\\n        height: 40px;\\n        width: 40px;\\n        justify-content: center;\\n        align-items: center;\\n        border-radius: 100%;\\n        border: 1px solid #ccc;\\n        overflow: hidden;\\n        background-color: var(--fff);\\n    }\\n\\n    .infoImg {\\n        height: 30px;\\n    }\\n\\n    .infoAnswer {\\n        font-size: 0.8em;\\n        color: var(--g555);\\n        width: 63px;\\n        text-align: center;\\n        line-height: 1.2em;\\n    }\\n\\n\\t@media (max-width: 665px) {\\n        .name {\\n            font-size: 0.9em;\\n            margin-left: 0.5em;\\n        }\\n\\n        .team {\\n            font-size: 0.8em;\\n            margin-left: 0.5em;\\n        }\\n    }\\n\\n\\t@media (max-width: 595px) {\\n        .manager {\\n            padding: 0.5em 0;\\n            margin: 0.3em 0;\\n            border-radius: 1.5em;\\n        }\\n\\n        .photo {\\n            height: 30px;\\n            width: 30px;\\n            margin-left: 0.5em;\\n        }\\n\\n        .infoSlot {\\n            text-align: center;\\n            margin: 0 0.4em;\\n            width: 56px;\\n        }\\n\\n        .infoIcon {\\n            height: 30px;\\n            width: 30px;\\n        }\\n\\n        .infoImg {\\n            height: 25px;\\n        }\\n\\n        .infoAnswer {\\n            font-size: 0.7em;\\n            width: 56px;\\n        }\\n    }\\n\\n    @media (max-width: 475px) {\\n        .name {\\n            font-size: 0.8em;\\n            margin-left: 0.4em;\\n        }\\n\\n        .team {\\n            font-size: 0.7em;\\n            margin-left: 0.4em;\\n        }\\n\\n        .photo {\\n            height: 25px;\\n            width: 25px;\\n        }\\n\\n        .infoSlot {\\n            text-align: center;\\n            margin: 0 0.4em;\\n            width: 49px;\\n        }\\n\\n        .infoIcon {\\n            height: 25px;\\n            width: 25px;\\n        }\\n\\n        .infoImg {\\n            height: 22px;\\n        }\\n\\n        .infoAnswer {\\n            font-size: 0.6em;\\n            width: 49px;\\n        }\\n    }\\n\\n    @media (max-width: 370px) {\\n        .infoTeam {\\n            display: none;\\n        }\\n    }\\n\\n    .question {\\n        background-color: #fff;\\n    }\\n</style>\\n\\n<div class=\\"manager\\" on:click={() => goto(\`/managers?manager=\${key}\`)}>\\n    <img class=\\"photo\\" src=\\"{manager.photo}\\" alt=\\"{manager.name}\\" />\\n    <div class=\\"name\\">{manager.name}</div>\\n    <div class=\\"team\\">{user.metadata.team_name ? user.metadata.team_name : user.display_name}</div>\\n    <div class=\\"spacer\\" />\\n    <div class=\\"info\\">\\n        <!-- Favorite team (optional) -->\\n        <div class=\\"infoSlot infoTeam\\">\\n            {#if manager.favoriteTeam}\\n                <div class=\\"infoIcon\\">\\n                    <img class=\\"infoImg\\" src=\\"https://sleepercdn.com/images/team_logos/nfl/{manager.favoriteTeam}.png\\" alt=\\"favorite team\\"/>\\n                </div>\\n            {:else}\\n                <div class=\\"infoIcon question\\">\\n                    <img class=\\"infoImg\\" src=\\"/managers/question.jpg\\" alt=\\"favorite team\\"/>\\n                </div>\\n            {/if}\\n        </div>\\n        <!-- Preferred contact -->\\n        <div class=\\"infoSlot\\">\\n            {#if manager.preferredContact}\\n                <div class=\\"infoIcon\\">\\n                    <img class=\\"infoImg\\" src=\\"/{manager.preferredContact}.png\\" alt=\\"{manager.preferredContact}\\"/>\\n                </div>\\n                <div class=\\"infoAnswer\\">\\n                    {manager.preferredContact}\\n                </div>\\n            {:else}\\n                <div class=\\"infoIcon question\\">\\n                    <img class=\\"infoImg\\" src=\\"/managers/question.jpg\\" alt=\\"favorite team\\"/>\\n                </div>\\n            {/if}\\n        </div>\\n        <!-- Rebuild mode (optional and only displayed for dynasty leagues) -->\\n        {#if dynasty}\\n            <div class=\\"infoSlot infoRebuild\\">\\n                {#if manager.mode}\\n                    <div class=\\"infoIcon\\">\\n                        <img class=\\"infoImg\\" src=\\"/{manager.mode.replace(' ', '%20')}.png\\" alt=\\"win now or rebuild\\"/>\\n                    </div>\\n                    <div class=\\"infoAnswer\\">\\n                        {manager.mode}\\n                    </div>\\n                {:else}\\n                    <div class=\\"infoIcon question\\">\\n                        <img class=\\"infoImg\\" src=\\"/managers/question.jpg\\" alt=\\"favorite team\\"/>\\n                    </div>\\n                {/if}\\n            </div>\\n        {/if}\\n    </div>\\n</div>"],"names":[],"mappings":"AAYI,QAAQ,cAAC,CAAC,AACN,OAAO,CAAE,IAAI,CACb,eAAe,CAAE,IAAI,CACrB,WAAW,CAAE,MAAM,CACnB,OAAO,CAAE,GAAG,CAAC,CAAC,CACd,gBAAgB,CAAE,IAAI,KAAK,CAAC,CAC5B,MAAM,CAAE,KAAK,CAAC,CAAC,CACf,aAAa,CAAE,GAAG,CAClB,MAAM,CAAE,GAAG,CAAC,KAAK,CAAC,IAAI,KAAK,CAAC,CAC5B,UAAU,CAAE,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,IAAI,KAAK,CAAC,CAChC,MAAM,CAAE,OAAO,AACnB,CAAC,AAED,sBAAQ,MAAM,AAAC,CAAC,AACZ,UAAU,CAAE,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,IAAI,MAAM,CAAC,CAClC,gBAAgB,CAAE,IAAI,KAAK,CAAC,AAChC,CAAC,AAED,MAAM,cAAC,CAAC,AACJ,MAAM,CAAE,IAAI,CACZ,KAAK,CAAE,IAAI,CACX,aAAa,CAAE,IAAI,CACnB,cAAc,CAAE,MAAM,CACtB,WAAW,CAAE,GAAG,CAChB,UAAU,CAAE,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI,KAAK,CAAC,AACtC,CAAC,AAED,KAAK,cAAC,CAAC,AACH,UAAU,CAAE,MAAM,CAClB,OAAO,CAAE,YAAY,CACrB,KAAK,CAAE,IAAI,MAAM,CAAC,CAClB,WAAW,CAAE,KAAK,CAClB,WAAW,CAAE,GAAG,CAChB,WAAW,CAAE,GAAG,AACpB,CAAC,AAED,KAAK,cAAC,CAAC,AACH,UAAU,CAAE,MAAM,CAClB,OAAO,CAAE,YAAY,CACrB,UAAU,CAAE,MAAM,CAClB,WAAW,CAAE,KAAK,CAClB,KAAK,CAAE,IAAI,MAAM,CAAC,CAClB,WAAW,CAAE,GAAG,CAChB,WAAW,CAAE,GAAG,AACpB,CAAC,AAED,OAAO,cAAC,CAAC,AACL,SAAS,CAAE,CAAC,AAChB,CAAC,AAED,KAAK,cAAC,CAAC,AACH,OAAO,CAAE,IAAI,AACjB,CAAC,AAED,SAAS,cAAC,CAAC,AACP,UAAU,CAAE,MAAM,CAClB,MAAM,CAAE,CAAC,CAAC,KAAK,CACf,KAAK,CAAE,IAAI,AACf,CAAC,AAED,SAAS,cAAC,CAAC,AACP,OAAO,CAAE,WAAW,CACpB,MAAM,CAAE,IAAI,CACZ,KAAK,CAAE,IAAI,CACX,eAAe,CAAE,MAAM,CACvB,WAAW,CAAE,MAAM,CACnB,aAAa,CAAE,IAAI,CACnB,MAAM,CAAE,GAAG,CAAC,KAAK,CAAC,IAAI,CACtB,QAAQ,CAAE,MAAM,CAChB,gBAAgB,CAAE,IAAI,KAAK,CAAC,AAChC,CAAC,AAED,QAAQ,cAAC,CAAC,AACN,MAAM,CAAE,IAAI,AAChB,CAAC,AAED,WAAW,cAAC,CAAC,AACT,SAAS,CAAE,KAAK,CAChB,KAAK,CAAE,IAAI,MAAM,CAAC,CAClB,KAAK,CAAE,IAAI,CACX,UAAU,CAAE,MAAM,CAClB,WAAW,CAAE,KAAK,AACtB,CAAC,AAEJ,MAAM,AAAC,YAAY,KAAK,CAAC,AAAC,CAAC,AACpB,KAAK,cAAC,CAAC,AACH,SAAS,CAAE,KAAK,CAChB,WAAW,CAAE,KAAK,AACtB,CAAC,AAED,KAAK,cAAC,CAAC,AACH,SAAS,CAAE,KAAK,CAChB,WAAW,CAAE,KAAK,AACtB,CAAC,AACL,CAAC,AAEJ,MAAM,AAAC,YAAY,KAAK,CAAC,AAAC,CAAC,AACpB,QAAQ,cAAC,CAAC,AACN,OAAO,CAAE,KAAK,CAAC,CAAC,CAChB,MAAM,CAAE,KAAK,CAAC,CAAC,CACf,aAAa,CAAE,KAAK,AACxB,CAAC,AAED,MAAM,cAAC,CAAC,AACJ,MAAM,CAAE,IAAI,CACZ,KAAK,CAAE,IAAI,CACX,WAAW,CAAE,KAAK,AACtB,CAAC,AAED,SAAS,cAAC,CAAC,AACP,UAAU,CAAE,MAAM,CAClB,MAAM,CAAE,CAAC,CAAC,KAAK,CACf,KAAK,CAAE,IAAI,AACf,CAAC,AAED,SAAS,cAAC,CAAC,AACP,MAAM,CAAE,IAAI,CACZ,KAAK,CAAE,IAAI,AACf,CAAC,AAED,QAAQ,cAAC,CAAC,AACN,MAAM,CAAE,IAAI,AAChB,CAAC,AAED,WAAW,cAAC,CAAC,AACT,SAAS,CAAE,KAAK,CAChB,KAAK,CAAE,IAAI,AACf,CAAC,AACL,CAAC,AAED,MAAM,AAAC,YAAY,KAAK,CAAC,AAAC,CAAC,AACvB,KAAK,cAAC,CAAC,AACH,SAAS,CAAE,KAAK,CAChB,WAAW,CAAE,KAAK,AACtB,CAAC,AAED,KAAK,cAAC,CAAC,AACH,SAAS,CAAE,KAAK,CAChB,WAAW,CAAE,KAAK,AACtB,CAAC,AAED,MAAM,cAAC,CAAC,AACJ,MAAM,CAAE,IAAI,CACZ,KAAK,CAAE,IAAI,AACf,CAAC,AAED,SAAS,cAAC,CAAC,AACP,UAAU,CAAE,MAAM,CAClB,MAAM,CAAE,CAAC,CAAC,KAAK,CACf,KAAK,CAAE,IAAI,AACf,CAAC,AAED,SAAS,cAAC,CAAC,AACP,MAAM,CAAE,IAAI,CACZ,KAAK,CAAE,IAAI,AACf,CAAC,AAED,QAAQ,cAAC,CAAC,AACN,MAAM,CAAE,IAAI,AAChB,CAAC,AAED,WAAW,cAAC,CAAC,AACT,SAAS,CAAE,KAAK,CAChB,KAAK,CAAE,IAAI,AACf,CAAC,AACL,CAAC,AAED,MAAM,AAAC,YAAY,KAAK,CAAC,AAAC,CAAC,AACvB,SAAS,cAAC,CAAC,AACP,OAAO,CAAE,IAAI,AACjB,CAAC,AACL,CAAC,AAED,SAAS,cAAC,CAAC,AACP,gBAAgB,CAAE,IAAI,AAC1B,CAAC"}`
};
var ManagerRow = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let { manager, rosters, users: users2, key } = $$props;
  const roster = rosters.rosters[manager.roster - 1];
  const user = users2[roster.owner_id];
  if ($$props.manager === void 0 && $$bindings.manager && manager !== void 0)
    $$bindings.manager(manager);
  if ($$props.rosters === void 0 && $$bindings.rosters && rosters !== void 0)
    $$bindings.rosters(rosters);
  if ($$props.users === void 0 && $$bindings.users && users2 !== void 0)
    $$bindings.users(users2);
  if ($$props.key === void 0 && $$bindings.key && key !== void 0)
    $$bindings.key(key);
  $$result.css.add(css$k);
  return `<div class="${"manager svelte-9hqn7f"}"><img class="${"photo svelte-9hqn7f"}"${add_attribute("src", manager.photo, 0)}${add_attribute("alt", manager.name, 0)}>
    <div class="${"name svelte-9hqn7f"}">${escape(manager.name)}</div>
    <div class="${"team svelte-9hqn7f"}">${escape(user.metadata.team_name ? user.metadata.team_name : user.display_name)}</div>
    <div class="${"spacer svelte-9hqn7f"}"></div>
    <div class="${"info svelte-9hqn7f"}">
        <div class="${"infoSlot infoTeam svelte-9hqn7f"}">${manager.favoriteTeam ? `<div class="${"infoIcon svelte-9hqn7f"}"><img class="${"infoImg svelte-9hqn7f"}" src="${"https://sleepercdn.com/images/team_logos/nfl/" + escape(manager.favoriteTeam) + ".png"}" alt="${"favorite team"}"></div>` : `<div class="${"infoIcon question svelte-9hqn7f"}"><img class="${"infoImg svelte-9hqn7f"}" src="${"/managers/question.jpg"}" alt="${"favorite team"}"></div>`}</div>
        
        <div class="${"infoSlot svelte-9hqn7f"}">${manager.preferredContact ? `<div class="${"infoIcon svelte-9hqn7f"}"><img class="${"infoImg svelte-9hqn7f"}" src="${"/" + escape(manager.preferredContact) + ".png"}"${add_attribute("alt", manager.preferredContact, 0)}></div>
                <div class="${"infoAnswer svelte-9hqn7f"}">${escape(manager.preferredContact)}</div>` : `<div class="${"infoIcon question svelte-9hqn7f"}"><img class="${"infoImg svelte-9hqn7f"}" src="${"/managers/question.jpg"}" alt="${"favorite team"}"></div>`}</div>
        
        ${`<div class="${"infoSlot infoRebuild svelte-9hqn7f"}">${manager.mode ? `<div class="${"infoIcon svelte-9hqn7f"}"><img class="${"infoImg svelte-9hqn7f"}" src="${"/" + escape(manager.mode.replace(" ", "%20")) + ".png"}" alt="${"win now or rebuild"}"></div>
                    <div class="${"infoAnswer svelte-9hqn7f"}">${escape(manager.mode)}</div>` : `<div class="${"infoIcon question svelte-9hqn7f"}"><img class="${"infoImg svelte-9hqn7f"}" src="${"/managers/question.jpg"}" alt="${"favorite team"}"></div>`}</div>`}</div></div>`;
});
var css$j = {
  code: ".managerContainer.svelte-168w153{width:100%;margin:2em 0 5em}.managerConstrained.svelte-168w153{width:97%;max-width:800px;margin:0 auto}h2.svelte-168w153{text-align:center;font-size:2.8em;margin:2em 0 1.5em;line-height:1em}@media(max-width: 520px){h2.svelte-168w153{text-align:center;font-size:2em;margin:1.5em 0 1em;line-height:1em}}",
  map: `{"version":3,"file":"AllManagers.svelte","sources":["AllManagers.svelte"],"sourcesContent":["<script>\\n    import { leagueName } from '$lib/utils/helper';\\n    import ManagerRow from './ManagerRow.svelte'\\n\\n    export let managers, rosters, users;\\n\\n    let innerWidth;\\n<\/script>\\n\\n<svelte:window bind:innerWidth={innerWidth} />\\n\\n<style>\\n    .managerContainer {\\n        width: 100%;\\n        margin: 2em 0 5em;\\n    }\\n\\n    .managerConstrained {\\n        width: 97%;\\n        max-width: 800px;\\n        margin: 0 auto;\\n    }\\n\\n    h2 {\\n        text-align: center;\\n        font-size: 2.8em;\\n        margin: 2em 0 1.5em;\\n        line-height: 1em;\\n    }\\n\\n    @media (max-width: 520px) {\\n        h2 {\\n            text-align: center;\\n            font-size: 2em;\\n            margin: 1.5em 0 1em;\\n            line-height: 1em;\\n        }\\n    }\\n</style>\\n\\n<div class=\\"managerContainer\\">\\n    <h2>{leagueName} Managers</h2>\\n    <div class=\\"managerConstrained\\">\\n        {#each managers as manager, key}\\n            <ManagerRow {manager} {rosters} {users} {key} />\\n        {/each}\\n    </div>\\n\\n</div>"],"names":[],"mappings":"AAYI,iBAAiB,eAAC,CAAC,AACf,KAAK,CAAE,IAAI,CACX,MAAM,CAAE,GAAG,CAAC,CAAC,CAAC,GAAG,AACrB,CAAC,AAED,mBAAmB,eAAC,CAAC,AACjB,KAAK,CAAE,GAAG,CACV,SAAS,CAAE,KAAK,CAChB,MAAM,CAAE,CAAC,CAAC,IAAI,AAClB,CAAC,AAED,EAAE,eAAC,CAAC,AACA,UAAU,CAAE,MAAM,CAClB,SAAS,CAAE,KAAK,CAChB,MAAM,CAAE,GAAG,CAAC,CAAC,CAAC,KAAK,CACnB,WAAW,CAAE,GAAG,AACpB,CAAC,AAED,MAAM,AAAC,YAAY,KAAK,CAAC,AAAC,CAAC,AACvB,EAAE,eAAC,CAAC,AACA,UAAU,CAAE,MAAM,CAClB,SAAS,CAAE,GAAG,CACd,MAAM,CAAE,KAAK,CAAC,CAAC,CAAC,GAAG,CACnB,WAAW,CAAE,GAAG,AACpB,CAAC,AACL,CAAC"}`
};
var AllManagers = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let { managers: managers2, rosters, users: users2 } = $$props;
  if ($$props.managers === void 0 && $$bindings.managers && managers2 !== void 0)
    $$bindings.managers(managers2);
  if ($$props.rosters === void 0 && $$bindings.rosters && rosters !== void 0)
    $$bindings.rosters(rosters);
  if ($$props.users === void 0 && $$bindings.users && users2 !== void 0)
    $$bindings.users(users2);
  $$result.css.add(css$j);
  return `



<div class="${"managerContainer svelte-168w153"}"><h2 class="${"svelte-168w153"}">${escape(leagueName)} Managers</h2>
    <div class="${"managerConstrained svelte-168w153"}">${each(managers2, (manager, key) => `${validate_component(ManagerRow, "ManagerRow").$$render($$result, { manager, rosters, users: users2, key }, {}, {})}`)}</div></div>`;
});
var css$i = {
  code: ".awardsCase.svelte-7q111m{background-color:var(--fff);padding:0 0 2em;margin:3em 0 4em;border-bottom:1px solid var(--aaa);border-top:1px solid var(--aaa);box-shadow:0 0 8px 4px var(--ccc)}.awardsCaseInner.svelte-7q111m{display:flex;justify-content:space-evenly;flex-wrap:wrap}h3.svelte-7q111m{text-align:center;font-size:1.5em;margin:1.5em 0 0.5em;font-weight:200}.award.svelte-7q111m{display:flex;flex-direction:column;justify-content:flex-start;align-items:center;margin:1em 0.5em 2em}.awardHeader.svelte-7q111m,.awardLabel.svelte-7q111m,.subText.svelte-7q111m{text-align:center;line-height:1.2em}.awardHeader.svelte-7q111m{height:2.4em;font-size:0.85em;width:110px;margin-bottom:0.5em}.awardLabel.svelte-7q111m{font-size:0.9em;margin-top:1em;font-weight:500;width:130px}.subText.svelte-7q111m{font-size:0.8em;width:130px;color:var(--g555);margin-top:0.3em;font-style:italic}.sad.svelte-7q111m{color:var(--g999);font-style:italic}.awardIcon.svelte-7q111m{height:80px;width:80px;border-radius:100%;box-shadow:0 0 4px 1px var(--ccc);text-align:center;overflow:hidden}.awardImage.svelte-7q111m{height:100%}.disclaimer.svelte-7q111m{font-size:0.8em;color:var(--g999);font-style:italic;text-align:center;margin:0;line-height:1em}@media(max-width: 730px){.awardHeader.svelte-7q111m{height:3.6em;font-size:0.8em;width:90px}.awardLabel.svelte-7q111m{width:90px}.subText.svelte-7q111m{width:90px}}@media(max-width: 530px){.awardIcon.svelte-7q111m{height:60px;width:60px}.awardHeader.svelte-7q111m{height:3.6em;font-size:0.58em;width:65px}.awardLabel.svelte-7q111m{font-size:0.7em;width:65px}.subText.svelte-7q111m{font-size:0.6em;width:65px}}",
  map: `{"version":3,"file":"ManagerAwards.svelte","sources":["ManagerAwards.svelte"],"sourcesContent":["<script>\\n    import { round } from \\"$lib/utils/helper\\";\\n\\n    export let awards, records, roster, tookOver;\\n\\n    let displayAwards = [];\\n\\n    const capitalizeFirstLetter = (string) => {\\n        return string.charAt(0).toUpperCase() + string.slice(1);\\n    }\\n    \\n    let formerGlobal = false;\\n\\n    const computePodiums = (currentRoster) => {\\n        formerGlobal = false;\\n        displayAwards = [];\\n\\n        // first lookl through annual awards (champion, second, etc)\\n        for(const podium of awards.podiums) {\\n            for(const award in podium) {\\n                if(podium[award]?.rosterID == currentRoster.roster_id) {\\n                    const former = tookOver && tookOver > podium.year;\\n                    if(former) {\\n                        formerGlobal = true;\\n                    }\\n                    displayAwards.push({\\n                        award: capitalizeFirstLetter(award),\\n                        icon: '/awards/' + award + '.png',\\n                        type: 'award',\\n                        originalName: podium[award].name,\\n                        year: podium.year,\\n                        former\\n                    })\\n                }\\n                if(award == 'divisions') {\\n                    for(const division of podium[award]) {\\n                        if(division.roster == currentRoster.roster_id) {\\n                            const former = tookOver && tookOver > podium.year;\\n                            if(former) {\\n                                formerGlobal = true;\\n                            }\\n                            let awardTitle = 'Regular Season Champion';\\n                            if(division.name) {\\n                                awardTitle = \`\${division.name} Division Champion\`;\\n                            }\\n                            displayAwards.push({\\n                                award: awardTitle,\\n                                icon: '/awards/division.png',\\n                                type: 'award',\\n                                originalName: division.manager.name,\\n                                year: podium.year,\\n                                former\\n                            })\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        // Next look through record books\\n        const leagueRosterRecords = [];\\n        for(const key in records.leagueRosterRecords) {\\n            const record = records.leagueRosterRecords[key];\\n            record.rosterID = key;\\n            leagueRosterRecords.push(record);\\n        }\\n        const winRecords = [...leagueRosterRecords].sort((a, b) => b.wins - a.wins);\\n        const pointsRecords = [...leagueRosterRecords].sort((a, b) => b.fptsFor - a.fptsFor);\\n        const iqRecords = [...leagueRosterRecords].sort((a, b) => (b.fptsFor/b.potentialPoints) - (a.fptsFor/a.potentialPoints));\\n\\n        for(let i = 0; i < records.leagueWeekRecords.length; i++) {\\n            const leagueWeekRecord = records.leagueWeekRecords[i];\\n            const seasonLongRecord = records.mostSeasonLongPoints[i];\\n            const winRecord = winRecords[i];\\n            const pointsRecord = pointsRecords[i];\\n            const iqRecord = iqRecords[i];\\n\\n            if(winRecord?.rosterID == currentRoster.roster_id && i < 3) {\\n                displayAwards.push({\\n                    award: i + 1,\\n                    icon: '/awards/record-' + (i+1) + '.png',\\n                    type: 'All-Time Wins Record',\\n                    extraInfo: winRecord.wins,\\n                    wins: true\\n                })\\n            }\\n\\n            if(pointsRecord?.rosterID == currentRoster.roster_id && i < 3) {\\n                displayAwards.push({\\n                    award: i + 1,\\n                    icon: '/awards/record-' + (i+1) + '.png',\\n                    type: 'All-Time Fantasy Points Record',\\n                    extraInfo: round(pointsRecord.fptsFor)\\n                })\\n            }\\n\\n            if(iqRecord?.rosterID == currentRoster.roster_id && i < 3) {\\n                displayAwards.push({\\n                    award: i + 1,\\n                    icon: '/awards/record-' + (i+1) + '.png',\\n                    type: 'All-Time Lineup IQ Record',\\n                    extraInfo: round(iqRecord.fptsFor * 100 / iqRecord.potentialPoints),\\n                    iq: true\\n                })\\n            }\\n\\n            if(leagueWeekRecord.rosterID == currentRoster.roster_id) {\\n                const former = tookOver && tookOver > leagueWeekRecord.year;\\n                if(former) {\\n                    formerGlobal = true;\\n                }\\n                displayAwards.push({\\n                    award: i + 1,\\n                    icon: '/awards/' + (i < 3 ? \`record-\${i+1}\` : 'generic') + '.png',\\n                    type: 'All-Time Single Week Record',\\n                    originalName: leagueWeekRecord.manager.name,\\n                    year: leagueWeekRecord.year,\\n                    week: leagueWeekRecord.week,\\n                    extraInfo: leagueWeekRecord.fpts,\\n                    former\\n                })\\n            }\\n\\n            if(seasonLongRecord.rosterID == currentRoster.roster_id) {\\n                const former = tookOver && tookOver > seasonLongRecord.year;\\n                if(former) {\\n                    formerGlobal = true;\\n                }\\n                displayAwards.push({\\n                    award: i + 1,\\n                    icon: '/awards/' + (i < 3 ? \`record-\${i+1}\` : 'generic') + '.png',\\n                    type: 'All-Time Season Long Points',\\n                    originalName: seasonLongRecord.manager.name,\\n                    year: seasonLongRecord.year,\\n                    extraInfo: seasonLongRecord.fpts,\\n                    former\\n                })\\n            }\\n        }\\n        for(const yearRecords of records.seasonWeekRecords) {\\n            for(let i = 0; i < 3; i++) {\\n                const seasonPointsRecord = yearRecords.seasonPointsRecords[i];\\n\\n                if(seasonPointsRecord.rosterID == currentRoster.roster_id) {\\n                    const former = tookOver && tookOver > yearRecords.year;\\n                if(former) {\\n                    formerGlobal = true;\\n                }\\n                    displayAwards.push({\\n                        award: i + 1,\\n                        icon: '/awards/' + (i < 3 ? \`record-\${i+1}\` : 'generic') + '.png',\\n                        type: \`\${yearRecords.year} Single Week Record\`,\\n                        originalName: seasonPointsRecord.manager.name,\\n                        year: null,\\n                        week: seasonPointsRecord.week,\\n                        extraInfo: seasonPointsRecord.fpts,\\n                        former\\n                    })\\n                }\\n            }\\n        }\\n    }\\n\\n    $: computePodiums(roster);\\n\\n    const computeAward = (award) => {\\n        switch (award) {\\n            case 1:\\n                return '1st Place'\\n            case 2:\\n                return '2nd Place'\\n            case 3:\\n                return '3rd Place'\\n            case 4:\\n            case 5:\\n            case 6:\\n            case 7:\\n            case 8:\\n            case 9:\\n            case 10:\\n                return award + 'th Place';\\n            case 'Champion':\\n                return award\\n            case 'Second':\\n            case 'Third':\\n                return award + ' Place'\\n            case 'Toilet':\\n                return award + ' Bowl'\\n            default:\\n                return award;\\n        }\\n    }\\n<\/script>\\n\\n<style>\\n    .awardsCase {\\n        background-color: var(--fff);\\n        padding: 0 0 2em;\\n        margin: 3em 0 4em;\\n        border-bottom: 1px solid var(--aaa);\\n        border-top: 1px solid var(--aaa);\\n        box-shadow: 0 0 8px 4px var(--ccc);\\n    }\\n\\n    .awardsCaseInner {\\n        display: flex;\\n        justify-content: space-evenly;\\n        flex-wrap: wrap;\\n    }\\n\\n    h3 {\\n        text-align: center;\\n        font-size: 1.5em;\\n        margin: 1.5em 0 0.5em;\\n        font-weight: 200;\\n    }\\n\\n    .award {\\n        display: flex;\\n        flex-direction: column;\\n        justify-content: flex-start;\\n        align-items: center;\\n        margin: 1em 0.5em 2em;\\n    }\\n\\n    .awardHeader, .awardLabel, .subText {\\n        text-align: center;\\n        line-height: 1.2em;\\n    }\\n\\n    .awardHeader {\\n        height: 2.4em;\\n        font-size: 0.85em;\\n        width: 110px;\\n        margin-bottom: 0.5em;\\n    }\\n\\n    .awardLabel {\\n        font-size: 0.9em;\\n        margin-top: 1em;\\n        font-weight: 500;\\n        width: 130px;\\n    }\\n\\n    .subText {\\n        font-size: 0.8em;\\n        width: 130px;\\n        color: var(--g555);\\n        margin-top: 0.3em;\\n        font-style: italic;\\n    }\\n\\n    .sad {\\n        color: var(--g999);\\n        font-style: italic;\\n    }\\n\\n    .awardIcon {\\n        height: 80px;\\n        width: 80px;\\n        border-radius: 100%;\\n        box-shadow: 0 0 4px 1px var(--ccc);\\n        text-align: center;\\n        overflow: hidden;\\n    }\\n\\n    .awardImage{\\n        height: 100%;\\n    }\\n    \\n    .disclaimer {\\n        font-size: 0.8em;\\n        color: var(--g999);\\n        font-style: italic;\\n        text-align: center;\\n        margin: 0;\\n        line-height: 1em;\\n    }\\n\\n    @media (max-width: 730px) {\\n        .awardHeader {\\n            height: 3.6em;\\n            font-size: 0.8em;\\n            width: 90px;\\n        }\\n\\n        .awardLabel {\\n            width: 90px;\\n        }\\n\\n        .subText {\\n            width: 90px;\\n        }\\n    }\\n\\n    @media (max-width: 530px) {\\n        .awardIcon {\\n            height: 60px;\\n            width: 60px;\\n        }\\n\\n        .awardHeader {\\n            height: 3.6em;\\n            font-size: 0.58em;\\n            width: 65px;\\n        }\\n\\n        .awardLabel {\\n            font-size: 0.7em;\\n            width: 65px;\\n        }\\n\\n        .subText {\\n            font-size: 0.6em;\\n            width: 65px;\\n        }\\n    }\\n\\n\\n</style>\\n\\n<div class=\\"awardsCase\\">\\n    <h3>Team Awards & Records</h3>\\n    <div class=\\"awardsCaseInner\\">\\n        {#each displayAwards as award}\\n            <div class=\\"award\\">\\n                <div class=\\"awardHeader\\">{award.type != 'award' ? award.type : ''}</div>\\n                <div class=\\"awardIcon\\">\\n                    <img class=\\"awardImage\\" src=\\"{award.icon}\\" alt=\\"trophy\\" />\\n                </div>\\n                <div class=\\"awardLabel\\">{award.type == 'award' ? \`\${award.year} \` : ''}{computeAward(award.award)}{award.former ? '*' : ''}</div>\\n                {#if award.extraInfo}\\n                    <div class=\\"subText\\">{award.year ? \`\${award.year} \` : ''}{award.week ? \`Week \${award.week} \` : ''}{award.year || award.week ? ' - ' : ''}{award.extraInfo}{award.wins ? ' Wins' : ''}{award.iq ? '%' : ''}{!award.wins && !award.iq ? 'pts' : ''}</div>\\n                {/if}\\n            </div>\\n        {:else}\\n            <p class=\\"sad\\">...nothing yet</p>\\n        {/each}\\n    </div>\\n    {#if formerGlobal}\\n        <p class=\\"disclaimer\\">*Awarded under a previous manager</p>\\n    {/if}\\n</div>"],"names":[],"mappings":"AAmMI,WAAW,cAAC,CAAC,AACT,gBAAgB,CAAE,IAAI,KAAK,CAAC,CAC5B,OAAO,CAAE,CAAC,CAAC,CAAC,CAAC,GAAG,CAChB,MAAM,CAAE,GAAG,CAAC,CAAC,CAAC,GAAG,CACjB,aAAa,CAAE,GAAG,CAAC,KAAK,CAAC,IAAI,KAAK,CAAC,CACnC,UAAU,CAAE,GAAG,CAAC,KAAK,CAAC,IAAI,KAAK,CAAC,CAChC,UAAU,CAAE,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI,KAAK,CAAC,AACtC,CAAC,AAED,gBAAgB,cAAC,CAAC,AACd,OAAO,CAAE,IAAI,CACb,eAAe,CAAE,YAAY,CAC7B,SAAS,CAAE,IAAI,AACnB,CAAC,AAED,EAAE,cAAC,CAAC,AACA,UAAU,CAAE,MAAM,CAClB,SAAS,CAAE,KAAK,CAChB,MAAM,CAAE,KAAK,CAAC,CAAC,CAAC,KAAK,CACrB,WAAW,CAAE,GAAG,AACpB,CAAC,AAED,MAAM,cAAC,CAAC,AACJ,OAAO,CAAE,IAAI,CACb,cAAc,CAAE,MAAM,CACtB,eAAe,CAAE,UAAU,CAC3B,WAAW,CAAE,MAAM,CACnB,MAAM,CAAE,GAAG,CAAC,KAAK,CAAC,GAAG,AACzB,CAAC,AAED,0BAAY,CAAE,yBAAW,CAAE,QAAQ,cAAC,CAAC,AACjC,UAAU,CAAE,MAAM,CAClB,WAAW,CAAE,KAAK,AACtB,CAAC,AAED,YAAY,cAAC,CAAC,AACV,MAAM,CAAE,KAAK,CACb,SAAS,CAAE,MAAM,CACjB,KAAK,CAAE,KAAK,CACZ,aAAa,CAAE,KAAK,AACxB,CAAC,AAED,WAAW,cAAC,CAAC,AACT,SAAS,CAAE,KAAK,CAChB,UAAU,CAAE,GAAG,CACf,WAAW,CAAE,GAAG,CAChB,KAAK,CAAE,KAAK,AAChB,CAAC,AAED,QAAQ,cAAC,CAAC,AACN,SAAS,CAAE,KAAK,CAChB,KAAK,CAAE,KAAK,CACZ,KAAK,CAAE,IAAI,MAAM,CAAC,CAClB,UAAU,CAAE,KAAK,CACjB,UAAU,CAAE,MAAM,AACtB,CAAC,AAED,IAAI,cAAC,CAAC,AACF,KAAK,CAAE,IAAI,MAAM,CAAC,CAClB,UAAU,CAAE,MAAM,AACtB,CAAC,AAED,UAAU,cAAC,CAAC,AACR,MAAM,CAAE,IAAI,CACZ,KAAK,CAAE,IAAI,CACX,aAAa,CAAE,IAAI,CACnB,UAAU,CAAE,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI,KAAK,CAAC,CAClC,UAAU,CAAE,MAAM,CAClB,QAAQ,CAAE,MAAM,AACpB,CAAC,AAED,yBAAW,CAAC,AACR,MAAM,CAAE,IAAI,AAChB,CAAC,AAED,WAAW,cAAC,CAAC,AACT,SAAS,CAAE,KAAK,CAChB,KAAK,CAAE,IAAI,MAAM,CAAC,CAClB,UAAU,CAAE,MAAM,CAClB,UAAU,CAAE,MAAM,CAClB,MAAM,CAAE,CAAC,CACT,WAAW,CAAE,GAAG,AACpB,CAAC,AAED,MAAM,AAAC,YAAY,KAAK,CAAC,AAAC,CAAC,AACvB,YAAY,cAAC,CAAC,AACV,MAAM,CAAE,KAAK,CACb,SAAS,CAAE,KAAK,CAChB,KAAK,CAAE,IAAI,AACf,CAAC,AAED,WAAW,cAAC,CAAC,AACT,KAAK,CAAE,IAAI,AACf,CAAC,AAED,QAAQ,cAAC,CAAC,AACN,KAAK,CAAE,IAAI,AACf,CAAC,AACL,CAAC,AAED,MAAM,AAAC,YAAY,KAAK,CAAC,AAAC,CAAC,AACvB,UAAU,cAAC,CAAC,AACR,MAAM,CAAE,IAAI,CACZ,KAAK,CAAE,IAAI,AACf,CAAC,AAED,YAAY,cAAC,CAAC,AACV,MAAM,CAAE,KAAK,CACb,SAAS,CAAE,MAAM,CACjB,KAAK,CAAE,IAAI,AACf,CAAC,AAED,WAAW,cAAC,CAAC,AACT,SAAS,CAAE,KAAK,CAChB,KAAK,CAAE,IAAI,AACf,CAAC,AAED,QAAQ,cAAC,CAAC,AACN,SAAS,CAAE,KAAK,CAChB,KAAK,CAAE,IAAI,AACf,CAAC,AACL,CAAC"}`
};
var ManagerAwards = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let { awards: awards2, records: records2, roster, tookOver } = $$props;
  let displayAwards = [];
  const capitalizeFirstLetter = (string) => {
    return string.charAt(0).toUpperCase() + string.slice(1);
  };
  let formerGlobal = false;
  const computePodiums = (currentRoster) => {
    var _a;
    formerGlobal = false;
    displayAwards = [];
    for (const podium of awards2.podiums) {
      for (const award in podium) {
        if (((_a = podium[award]) == null ? void 0 : _a.rosterID) == currentRoster.roster_id) {
          const former = tookOver && tookOver > podium.year;
          if (former) {
            formerGlobal = true;
          }
          displayAwards.push({
            award: capitalizeFirstLetter(award),
            icon: "/awards/" + award + ".png",
            type: "award",
            originalName: podium[award].name,
            year: podium.year,
            former
          });
        }
        if (award == "divisions") {
          for (const division of podium[award]) {
            if (division.roster == currentRoster.roster_id) {
              const former = tookOver && tookOver > podium.year;
              if (former) {
                formerGlobal = true;
              }
              let awardTitle = "Regular Season Champion";
              if (division.name) {
                awardTitle = `${division.name} Division Champion`;
              }
              displayAwards.push({
                award: awardTitle,
                icon: "/awards/division.png",
                type: "award",
                originalName: division.manager.name,
                year: podium.year,
                former
              });
            }
          }
        }
      }
    }
    const leagueRosterRecords = [];
    for (const key in records2.leagueRosterRecords) {
      const record = records2.leagueRosterRecords[key];
      record.rosterID = key;
      leagueRosterRecords.push(record);
    }
    const winRecords = [...leagueRosterRecords].sort((a, b) => b.wins - a.wins);
    const pointsRecords = [...leagueRosterRecords].sort((a, b) => b.fptsFor - a.fptsFor);
    const iqRecords = [...leagueRosterRecords].sort((a, b) => b.fptsFor / b.potentialPoints - a.fptsFor / a.potentialPoints);
    for (let i = 0; i < records2.leagueWeekRecords.length; i++) {
      const leagueWeekRecord = records2.leagueWeekRecords[i];
      const seasonLongRecord = records2.mostSeasonLongPoints[i];
      const winRecord = winRecords[i];
      const pointsRecord = pointsRecords[i];
      const iqRecord = iqRecords[i];
      if ((winRecord == null ? void 0 : winRecord.rosterID) == currentRoster.roster_id && i < 3) {
        displayAwards.push({
          award: i + 1,
          icon: "/awards/record-" + (i + 1) + ".png",
          type: "All-Time Wins Record",
          extraInfo: winRecord.wins,
          wins: true
        });
      }
      if ((pointsRecord == null ? void 0 : pointsRecord.rosterID) == currentRoster.roster_id && i < 3) {
        displayAwards.push({
          award: i + 1,
          icon: "/awards/record-" + (i + 1) + ".png",
          type: "All-Time Fantasy Points Record",
          extraInfo: round(pointsRecord.fptsFor)
        });
      }
      if ((iqRecord == null ? void 0 : iqRecord.rosterID) == currentRoster.roster_id && i < 3) {
        displayAwards.push({
          award: i + 1,
          icon: "/awards/record-" + (i + 1) + ".png",
          type: "All-Time Lineup IQ Record",
          extraInfo: round(iqRecord.fptsFor * 100 / iqRecord.potentialPoints),
          iq: true
        });
      }
      if (leagueWeekRecord.rosterID == currentRoster.roster_id) {
        const former = tookOver && tookOver > leagueWeekRecord.year;
        if (former) {
          formerGlobal = true;
        }
        displayAwards.push({
          award: i + 1,
          icon: "/awards/" + (i < 3 ? `record-${i + 1}` : "generic") + ".png",
          type: "All-Time Single Week Record",
          originalName: leagueWeekRecord.manager.name,
          year: leagueWeekRecord.year,
          week: leagueWeekRecord.week,
          extraInfo: leagueWeekRecord.fpts,
          former
        });
      }
      if (seasonLongRecord.rosterID == currentRoster.roster_id) {
        const former = tookOver && tookOver > seasonLongRecord.year;
        if (former) {
          formerGlobal = true;
        }
        displayAwards.push({
          award: i + 1,
          icon: "/awards/" + (i < 3 ? `record-${i + 1}` : "generic") + ".png",
          type: "All-Time Season Long Points",
          originalName: seasonLongRecord.manager.name,
          year: seasonLongRecord.year,
          extraInfo: seasonLongRecord.fpts,
          former
        });
      }
    }
    for (const yearRecords of records2.seasonWeekRecords) {
      for (let i = 0; i < 3; i++) {
        const seasonPointsRecord = yearRecords.seasonPointsRecords[i];
        if (seasonPointsRecord.rosterID == currentRoster.roster_id) {
          const former = tookOver && tookOver > yearRecords.year;
          if (former) {
            formerGlobal = true;
          }
          displayAwards.push({
            award: i + 1,
            icon: "/awards/" + (i < 3 ? `record-${i + 1}` : "generic") + ".png",
            type: `${yearRecords.year} Single Week Record`,
            originalName: seasonPointsRecord.manager.name,
            year: null,
            week: seasonPointsRecord.week,
            extraInfo: seasonPointsRecord.fpts,
            former
          });
        }
      }
    }
  };
  const computeAward = (award) => {
    switch (award) {
      case 1:
        return "1st Place";
      case 2:
        return "2nd Place";
      case 3:
        return "3rd Place";
      case 4:
      case 5:
      case 6:
      case 7:
      case 8:
      case 9:
      case 10:
        return award + "th Place";
      case "Champion":
        return award;
      case "Second":
      case "Third":
        return award + " Place";
      case "Toilet":
        return award + " Bowl";
      default:
        return award;
    }
  };
  if ($$props.awards === void 0 && $$bindings.awards && awards2 !== void 0)
    $$bindings.awards(awards2);
  if ($$props.records === void 0 && $$bindings.records && records2 !== void 0)
    $$bindings.records(records2);
  if ($$props.roster === void 0 && $$bindings.roster && roster !== void 0)
    $$bindings.roster(roster);
  if ($$props.tookOver === void 0 && $$bindings.tookOver && tookOver !== void 0)
    $$bindings.tookOver(tookOver);
  $$result.css.add(css$i);
  {
    computePodiums(roster);
  }
  return `<div class="${"awardsCase svelte-7q111m"}"><h3 class="${"svelte-7q111m"}">Team Awards &amp; Records</h3>
    <div class="${"awardsCaseInner svelte-7q111m"}">${displayAwards.length ? each(displayAwards, (award) => `<div class="${"award svelte-7q111m"}"><div class="${"awardHeader svelte-7q111m"}">${escape(award.type != "award" ? award.type : "")}</div>
                <div class="${"awardIcon svelte-7q111m"}"><img class="${"awardImage svelte-7q111m"}"${add_attribute("src", award.icon, 0)} alt="${"trophy"}"></div>
                <div class="${"awardLabel svelte-7q111m"}">${escape(award.type == "award" ? `${award.year} ` : "")}${escape(computeAward(award.award))}${escape(award.former ? "*" : "")}</div>
                ${award.extraInfo ? `<div class="${"subText svelte-7q111m"}">${escape(award.year ? `${award.year} ` : "")}${escape(award.week ? `Week ${award.week} ` : "")}${escape(award.year || award.week ? " - " : "")}${escape(award.extraInfo)}${escape(award.wins ? " Wins" : "")}${escape(award.iq ? "%" : "")}${escape(!award.wins && !award.iq ? "pts" : "")}</div>` : ``}
            </div>`) : `<p class="${"sad svelte-7q111m"}">...nothing yet</p>`}</div>
    ${formerGlobal ? `<p class="${"disclaimer svelte-7q111m"}">*Awarded under a previous manager</p>` : ``}</div>`;
});
var css$h = {
  code: ".managerContainer.svelte-12f8478.svelte-12f8478{width:100%;margin:2em 0 5em}.managerConstrained.svelte-12f8478.svelte-12f8478{width:97%;max-width:800px;margin:0 auto 4em}.managerPhoto.svelte-12f8478.svelte-12f8478{display:block;border-radius:100%;width:70%;max-width:200px;height:auto;margin:5em auto 1em;box-shadow:0 0 8px 4px #aaa}h2.svelte-12f8478.svelte-12f8478{text-align:center;font-size:2.8em;margin:1em 0 0em;line-height:1em}h3.svelte-12f8478.svelte-12f8478{text-align:center;font-size:1.5em;margin:1.5em 0 0.5em;font-weight:200}.basicInfo.svelte-12f8478.svelte-12f8478{display:flex;justify-content:space-evenly;align-items:center;height:24px;margin:2em 0}.basicInfo.svelte-12f8478 span.svelte-12f8478{color:#888;font-size:0.9em}.infoChild.svelte-12f8478.svelte-12f8478{font-style:italic}.infoContact.svelte-12f8478.svelte-12f8478{height:20px;vertical-align:middle;padding-left:1em}.infoTeam.svelte-12f8478.svelte-12f8478{height:48px}.bio.svelte-12f8478.svelte-12f8478{margin:2em 1.5em 2em;text-indent:4em}.philosophy.svelte-12f8478.svelte-12f8478{margin:2em 1.5em 2em;text-indent:4em}.loading.svelte-12f8478.svelte-12f8478{display:block;width:85%;max-width:500px;margin:80px auto}.teamSub.svelte-12f8478.svelte-12f8478{font-size:0.4em;line-height:1em;color:#666}.managerNav.svelte-12f8478.svelte-12f8478{margin:4em 0 2em;text-align:center}.upper.svelte-12f8478.svelte-12f8478{margin-top:0}@media(max-width: 505px){.selectionButtons span{font-size:0.8em}}@media(max-width: 435px){.selectionButtons span{line-height:1.2em;font-size:0.8em}}@media(max-width: 450px){.basicInfo.svelte-12f8478.svelte-12f8478{height:20px}.basicInfo.svelte-12f8478 span.svelte-12f8478{font-size:0.75em}.infoTeam.svelte-12f8478.svelte-12f8478{height:30px}}@media(max-width: 370px){.basicInfo.svelte-12f8478.svelte-12f8478{height:18px}.basicInfo.svelte-12f8478 span.svelte-12f8478{font-size:0.6em}.infoTeam.svelte-12f8478.svelte-12f8478{height:24px}}",
  map: `{"version":3,"file":"Manager.svelte","sources":["Manager.svelte"],"sourcesContent":["<script>\\n    import Button, { Group, Label } from '@smui/button';\\n\\timport LinearProgress from '@smui/linear-progress';\\n    import {loadPlayers} from '$lib/utils/helper';\\n\\timport Roster from '../Rosters/Roster.svelte';\\n\\timport TransactionsPage from '../Transactions/TransactionsPage.svelte';\\n    import { goto } from '$app/navigation';\\n    import ManagerFantasyInfo from './ManagerFantasyInfo.svelte';\\n    import ManagerAwards from './ManagerAwards.svelte';\\n    import { onMount } from 'svelte';\\n\\n    export let manager, managers, rostersData, users, rosterPositions, transactions, currentManagers, awards, records;\\n\\n    let viewManager = managers[manager];\\n\\n    let teamTransactions = transactions.filter(t => t.rosters.indexOf(viewManager.roster) > -1);\\n\\n    let startersAndReserve = rostersData.startersAndReserve;\\n    let rosters = rostersData.rosters;\\n\\n    let rosterArrNum = viewManager.roster-1;\\n\\n    let roster = rosters[rosterArrNum];\\n\\n    let user = users[roster.owner_id];\\n\\n    let players, playersInfo;\\n    let loading = true;\\n\\n    onMount(async () => {\\n        const playerData = await loadPlayers();\\n        playersInfo = playerData;\\n        players = playerData.players;\\n        loading = false;\\n\\n        if(playerData.stale) {\\n            const newPlayerData = await loadPlayers(true);\\n            playersInfo = newPlayerData;\\n            players = newPlayerData.players;\\n        }\\n    })\\n\\n    const changeManager = (newManager, noscroll = false) => {\\n        manager = newManager;\\n        viewManager = managers[newManager];\\n\\n        teamTransactions = transactions.filter(t => t.rosters.indexOf(viewManager.roster) > -1);\\n\\n        startersAndReserve = rostersData.startersAndReserve;\\n        rosters = rostersData.rosters;\\n\\n        rosterArrNum = viewManager.roster-1;\\n\\n        roster = rosters[rosterArrNum];\\n\\n        user = users[roster.owner_id];\\n        goto(\`/managers?manager=\${manager}\`, {noscroll})\\n    }\\n\\n    let el, masterOffset, innerWidth;\\n\\n    const setOffset = (w) => {\\n        return el?.getBoundingClientRect() ? el?.getBoundingClientRect().left  : 0;\\n    }\\n\\n    $: masterOffset = setOffset(innerWidth);\\n<\/script>\\n\\n<svelte:window bind:innerWidth={innerWidth} />\\n\\n<style>\\n    .managerContainer {\\n        width: 100%;\\n        margin: 2em 0 5em;\\n    }\\n\\n    .managerConstrained {\\n        width: 97%;\\n        max-width: 800px;\\n        margin: 0 auto 4em;\\n    }\\n\\n    .managerPhoto {\\n        display: block;\\n        border-radius: 100%;\\n        width: 70%;\\n        max-width: 200px;\\n        height: auto;\\n        margin: 5em auto 1em;\\n        box-shadow: 0 0 8px 4px #aaa;\\n    }\\n\\n    h2 {\\n        text-align: center;\\n        font-size: 2.8em;\\n        margin: 1em 0 0em;\\n        line-height: 1em;\\n    }\\n\\n    h3 {\\n        text-align: center;\\n        font-size: 1.5em;\\n        margin: 1.5em 0 0.5em;\\n        font-weight: 200;\\n    }\\n\\n    .basicInfo {\\n        display: flex;\\n        justify-content: space-evenly;\\n        align-items: center;\\n        height: 24px;\\n        margin: 2em 0;\\n    }\\n\\n    .basicInfo span {\\n        color: #888;\\n        font-size: 0.9em;\\n    }\\n\\n    .infoChild {\\n        font-style: italic;\\n    }\\n\\n    .infoContact {\\n        height: 20px;\\n        vertical-align: middle;\\n        padding-left: 1em;\\n    }\\n\\n    .infoTeam {\\n        height: 48px;\\n    }\\n\\n    .bio {\\n        margin: 2em 1.5em 2em;\\n        text-indent: 4em;\\n    }\\n\\n    .philosophy {\\n        margin: 2em 1.5em 2em;\\n        text-indent: 4em;\\n    }\\n\\n    .loading {\\n        display: block;\\n        width: 85%;\\n        max-width: 500px;\\n        margin: 80px auto;\\n    }\\n\\n    .teamSub {\\n        font-size: 0.4em;\\n        line-height: 1em;\\n        color: #666;\\n    }\\n\\n    .managerNav {\\n        margin: 4em 0 2em;\\n        text-align: center;\\n    }\\n\\n    .upper {\\n        margin-top: 0;\\n    }\\n\\n    /* media queries */\\n\\n    @media (max-width: 505px) {\\n        :global(.selectionButtons span) {\\n            font-size: 0.8em;\\n        }\\n    }\\n\\n    @media (max-width: 435px) {\\n        :global(.selectionButtons span) {\\n            line-height: 1.2em;\\n            font-size: 0.8em;\\n        }\\n    }\\n\\n\\t@media (max-width: 450px) {\\n\\n        .basicInfo {\\n            height: 20px;\\n        }\\n\\n        .basicInfo span {\\n            font-size: 0.75em;\\n        }\\n\\n        .infoTeam {\\n            height: 30px;\\n        }\\n\\t}\\n\\n    @media (max-width: 370px) {\\n\\n        .basicInfo {\\n            height: 18px;\\n        }\\n\\n        .basicInfo span {\\n            font-size: 0.6em;\\n        }\\n\\n        .infoTeam {\\n            height: 24px;\\n        }\\n    }\\n</style>\\n\\n<div class=\\"managerContainer\\">\\n    <div class=\\"managerConstrained\\">\\n        <img class=\\"managerPhoto\\" src=\\"{viewManager.photo}\\" alt=\\"manager\\"/>\\n        <h2>\\n            {viewManager.name}\\n            <div class=\\"teamSub\\">{roster.co_owners ? 'Co-' : ''}Manager of <i>{user.metadata.team_name ? user.metadata.team_name : user.display_name}</i></div>\\n        </h2>\\n        \\n        <div class=\\"basicInfo\\">\\n            <span class=\\"infoChild\\">{viewManager.location || 'Undisclosed Location'}</span>\\n            {#if viewManager.fantasyStart}\\n                <!-- fantasyStart is an optional field -->\\n                <span class=\\"seperator\\">|</span>\\n                <span class=\\"infoChild\\">Playing ff since '{viewManager.fantasyStart.toString().substr(2)}</span>\\n            {/if}\\n            {#if viewManager.preferredContact}\\n                <!-- preferredContact is an optional field -->\\n                <span class=\\"seperator\\">|</span>\\n                <span class=\\"infoChild\\">{viewManager.preferredContact}<img class=\\"infoChild infoContact\\" src=\\"/{viewManager.preferredContact}.png\\" alt=\\"favorite team\\"/></span>\\n            {/if}\\n            <!-- <span class=\\"infoChild\\">{viewManager.preferredContact}</span> -->\\n            {#if viewManager.favoriteTeam}\\n                <!-- favoriteTeam is an optional field -->\\n                <span class=\\"seperator\\">|</span>\\n                <img class=\\"infoChild infoTeam\\" src=\\"https://sleepercdn.com/images/team_logos/nfl/{viewManager.favoriteTeam}.png\\" alt=\\"favorite team\\"/>\\n            {/if}\\n        </div>\\n\\n        <div class=\\"managerNav upper\\">\\n            <Group variant=\\"outlined\\">\\n                {#if manager == 0}\\n                    <Button disabled class=\\"selectionButtons\\" on:click={() => changeManager(parseInt(manager) - 1, true)} variant=\\"outlined\\">\\n                        <Label>Previous Manager</Label>\\n                    </Button>\\n                {:else}\\n                    <Button class=\\"selectionButtons\\" on:click={() => changeManager(parseInt(manager) - 1, true)} variant=\\"outlined\\">\\n                        <Label>Previous Manager</Label>\\n                    </Button>\\n                {/if}\\n                <Button class=\\"selectionButtons\\" on:click={() => goto('/managers')} variant=\\"outlined\\">\\n                    <Label>All Managers</Label>\\n                </Button>\\n                {#if manager == managers.length - 1}\\n                    <Button disabled class=\\"selectionButtons\\" on:click={() => changeManager(parseInt(manager) + 1, true)} variant=\\"outlined\\">\\n                        <Label>Next Manager</Label>\\n                    </Button>\\n                {:else}\\n                    <Button class=\\"selectionButtons\\" on:click={() => changeManager(parseInt(manager) + 1, true)} variant=\\"outlined\\">\\n                        <Label>Next Manager</Label>\\n                    </Button>\\n                {/if}\\n            </Group>\\n        </div>\\n\\n        <p class=\\"bio\\">{@html viewManager.bio}</p>\\n\\n        {#if viewManager.philosophy}\\n            <!-- philosophy is an optional field -->\\n            <h3>Team Philosophy</h3>\\n            <p class=\\"philosophy\\">{@html viewManager.philosophy}</p>\\n        {/if}\\n    </div>\\n\\n    {#if !loading}\\n        <!-- Favorite player -->\\n        <ManagerFantasyInfo {viewManager} {players} />\\n    {/if}\\n\\n    <ManagerAwards tookOver={viewManager.tookOver} {awards} {records} {roster} />\\n\\n    {#if loading}\\n        <!-- promise is pending -->\\n        <div class=\\"loading\\">\\n            <p>Retrieving players...</p>\\n            <LinearProgress indeterminate />\\n        </div>\\n    {:else}\\n        <Roster division=\\"1\\" expanded={false} {rosterPositions} {roster} {users} {players} {startersAndReserve} />\\n    {/if}\\n\\n    <h3>Team Transactions</h3>\\n    <div class=\\"managerConstrained\\" bind:this={el}>\\n        {#if loading}\\n            <!-- promise is pending -->\\n            <div class=\\"loading\\">\\n                <p>Retrieving players...</p>\\n                <LinearProgress indeterminate />\\n            </div>\\n        {:else}\\n            <TransactionsPage {playersInfo} transactions={teamTransactions} {currentManagers} {masterOffset} show='both' query='' page={0} perPage={5} />\\n        {/if}\\n    </div>\\n\\n    <div class=\\"managerNav\\">\\n        <Group variant=\\"outlined\\">\\n            {#if manager == 0}\\n                <Button disabled class=\\"selectionButtons\\" on:click={() => changeManager(parseInt(manager) - 1)} variant=\\"outlined\\">\\n                    <Label>Previous Manager</Label>\\n                </Button>\\n            {:else}\\n                <Button class=\\"selectionButtons\\" on:click={() => changeManager(parseInt(manager) - 1)} variant=\\"outlined\\">\\n                    <Label>Previous Manager</Label>\\n                </Button>\\n            {/if}\\n            <Button class=\\"selectionButtons\\" on:click={() => goto('/managers')} variant=\\"outlined\\">\\n                <Label>All Managers</Label>\\n            </Button>\\n            {#if manager == managers.length - 1}\\n                <Button disabled class=\\"selectionButtons\\" on:click={() => changeManager(parseInt(manager) + 1)} variant=\\"outlined\\">\\n                    <Label>Next Manager</Label>\\n                </Button>\\n            {:else}\\n                <Button class=\\"selectionButtons\\" on:click={() => changeManager(parseInt(manager) + 1)} variant=\\"outlined\\">\\n                    <Label>Next Manager</Label>\\n                </Button>\\n            {/if}\\n        </Group>\\n    </div>\\n\\n</div>"],"names":[],"mappings":"AAuEI,iBAAiB,8BAAC,CAAC,AACf,KAAK,CAAE,IAAI,CACX,MAAM,CAAE,GAAG,CAAC,CAAC,CAAC,GAAG,AACrB,CAAC,AAED,mBAAmB,8BAAC,CAAC,AACjB,KAAK,CAAE,GAAG,CACV,SAAS,CAAE,KAAK,CAChB,MAAM,CAAE,CAAC,CAAC,IAAI,CAAC,GAAG,AACtB,CAAC,AAED,aAAa,8BAAC,CAAC,AACX,OAAO,CAAE,KAAK,CACd,aAAa,CAAE,IAAI,CACnB,KAAK,CAAE,GAAG,CACV,SAAS,CAAE,KAAK,CAChB,MAAM,CAAE,IAAI,CACZ,MAAM,CAAE,GAAG,CAAC,IAAI,CAAC,GAAG,CACpB,UAAU,CAAE,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI,AAChC,CAAC,AAED,EAAE,8BAAC,CAAC,AACA,UAAU,CAAE,MAAM,CAClB,SAAS,CAAE,KAAK,CAChB,MAAM,CAAE,GAAG,CAAC,CAAC,CAAC,GAAG,CACjB,WAAW,CAAE,GAAG,AACpB,CAAC,AAED,EAAE,8BAAC,CAAC,AACA,UAAU,CAAE,MAAM,CAClB,SAAS,CAAE,KAAK,CAChB,MAAM,CAAE,KAAK,CAAC,CAAC,CAAC,KAAK,CACrB,WAAW,CAAE,GAAG,AACpB,CAAC,AAED,UAAU,8BAAC,CAAC,AACR,OAAO,CAAE,IAAI,CACb,eAAe,CAAE,YAAY,CAC7B,WAAW,CAAE,MAAM,CACnB,MAAM,CAAE,IAAI,CACZ,MAAM,CAAE,GAAG,CAAC,CAAC,AACjB,CAAC,AAED,yBAAU,CAAC,IAAI,eAAC,CAAC,AACb,KAAK,CAAE,IAAI,CACX,SAAS,CAAE,KAAK,AACpB,CAAC,AAED,UAAU,8BAAC,CAAC,AACR,UAAU,CAAE,MAAM,AACtB,CAAC,AAED,YAAY,8BAAC,CAAC,AACV,MAAM,CAAE,IAAI,CACZ,cAAc,CAAE,MAAM,CACtB,YAAY,CAAE,GAAG,AACrB,CAAC,AAED,SAAS,8BAAC,CAAC,AACP,MAAM,CAAE,IAAI,AAChB,CAAC,AAED,IAAI,8BAAC,CAAC,AACF,MAAM,CAAE,GAAG,CAAC,KAAK,CAAC,GAAG,CACrB,WAAW,CAAE,GAAG,AACpB,CAAC,AAED,WAAW,8BAAC,CAAC,AACT,MAAM,CAAE,GAAG,CAAC,KAAK,CAAC,GAAG,CACrB,WAAW,CAAE,GAAG,AACpB,CAAC,AAED,QAAQ,8BAAC,CAAC,AACN,OAAO,CAAE,KAAK,CACd,KAAK,CAAE,GAAG,CACV,SAAS,CAAE,KAAK,CAChB,MAAM,CAAE,IAAI,CAAC,IAAI,AACrB,CAAC,AAED,QAAQ,8BAAC,CAAC,AACN,SAAS,CAAE,KAAK,CAChB,WAAW,CAAE,GAAG,CAChB,KAAK,CAAE,IAAI,AACf,CAAC,AAED,WAAW,8BAAC,CAAC,AACT,MAAM,CAAE,GAAG,CAAC,CAAC,CAAC,GAAG,CACjB,UAAU,CAAE,MAAM,AACtB,CAAC,AAED,MAAM,8BAAC,CAAC,AACJ,UAAU,CAAE,CAAC,AACjB,CAAC,AAID,MAAM,AAAC,YAAY,KAAK,CAAC,AAAC,CAAC,AACf,sBAAsB,AAAE,CAAC,AAC7B,SAAS,CAAE,KAAK,AACpB,CAAC,AACL,CAAC,AAED,MAAM,AAAC,YAAY,KAAK,CAAC,AAAC,CAAC,AACf,sBAAsB,AAAE,CAAC,AAC7B,WAAW,CAAE,KAAK,CAClB,SAAS,CAAE,KAAK,AACpB,CAAC,AACL,CAAC,AAEJ,MAAM,AAAC,YAAY,KAAK,CAAC,AAAC,CAAC,AAEpB,UAAU,8BAAC,CAAC,AACR,MAAM,CAAE,IAAI,AAChB,CAAC,AAED,yBAAU,CAAC,IAAI,eAAC,CAAC,AACb,SAAS,CAAE,MAAM,AACrB,CAAC,AAED,SAAS,8BAAC,CAAC,AACP,MAAM,CAAE,IAAI,AAChB,CAAC,AACR,CAAC,AAEE,MAAM,AAAC,YAAY,KAAK,CAAC,AAAC,CAAC,AAEvB,UAAU,8BAAC,CAAC,AACR,MAAM,CAAE,IAAI,AAChB,CAAC,AAED,yBAAU,CAAC,IAAI,eAAC,CAAC,AACb,SAAS,CAAE,KAAK,AACpB,CAAC,AAED,SAAS,8BAAC,CAAC,AACP,MAAM,CAAE,IAAI,AAChB,CAAC,AACL,CAAC"}`
};
var Manager = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let { manager, managers: managers2, rostersData, users: users2, rosterPositions, transactions, currentManagers, awards: awards2, records: records2 } = $$props;
  let viewManager = managers2[manager];
  transactions.filter((t) => t.rosters.indexOf(viewManager.roster) > -1);
  rostersData.startersAndReserve;
  let rosters = rostersData.rosters;
  let rosterArrNum = viewManager.roster - 1;
  let roster = rosters[rosterArrNum];
  let user = users2[roster.owner_id];
  let el;
  const setOffset = (w) => {
    return (el == null ? void 0 : el.getBoundingClientRect()) ? el == null ? void 0 : el.getBoundingClientRect().left : 0;
  };
  if ($$props.manager === void 0 && $$bindings.manager && manager !== void 0)
    $$bindings.manager(manager);
  if ($$props.managers === void 0 && $$bindings.managers && managers2 !== void 0)
    $$bindings.managers(managers2);
  if ($$props.rostersData === void 0 && $$bindings.rostersData && rostersData !== void 0)
    $$bindings.rostersData(rostersData);
  if ($$props.users === void 0 && $$bindings.users && users2 !== void 0)
    $$bindings.users(users2);
  if ($$props.rosterPositions === void 0 && $$bindings.rosterPositions && rosterPositions !== void 0)
    $$bindings.rosterPositions(rosterPositions);
  if ($$props.transactions === void 0 && $$bindings.transactions && transactions !== void 0)
    $$bindings.transactions(transactions);
  if ($$props.currentManagers === void 0 && $$bindings.currentManagers && currentManagers !== void 0)
    $$bindings.currentManagers(currentManagers);
  if ($$props.awards === void 0 && $$bindings.awards && awards2 !== void 0)
    $$bindings.awards(awards2);
  if ($$props.records === void 0 && $$bindings.records && records2 !== void 0)
    $$bindings.records(records2);
  $$result.css.add(css$h);
  setOffset();
  return `



<div class="${"managerContainer svelte-12f8478"}"><div class="${"managerConstrained svelte-12f8478"}"><img class="${"managerPhoto svelte-12f8478"}"${add_attribute("src", viewManager.photo, 0)} alt="${"manager"}">
        <h2 class="${"svelte-12f8478"}">${escape(viewManager.name)}
            <div class="${"teamSub svelte-12f8478"}">${escape(roster.co_owners ? "Co-" : "")}Manager of <i>${escape(user.metadata.team_name ? user.metadata.team_name : user.display_name)}</i></div></h2>
        
        <div class="${"basicInfo svelte-12f8478"}"><span class="${"infoChild svelte-12f8478"}">${escape(viewManager.location || "Undisclosed Location")}</span>
            ${viewManager.fantasyStart ? `
                <span class="${"seperator svelte-12f8478"}">|</span>
                <span class="${"infoChild svelte-12f8478"}">Playing ff since &#39;${escape(viewManager.fantasyStart.toString().substr(2))}</span>` : ``}
            ${viewManager.preferredContact ? `
                <span class="${"seperator svelte-12f8478"}">|</span>
                <span class="${"infoChild svelte-12f8478"}">${escape(viewManager.preferredContact)}<img class="${"infoChild infoContact svelte-12f8478"}" src="${"/" + escape(viewManager.preferredContact) + ".png"}" alt="${"favorite team"}"></span>` : ``}
            
            ${viewManager.favoriteTeam ? `
                <span class="${"seperator svelte-12f8478"}">|</span>
                <img class="${"infoChild infoTeam svelte-12f8478"}" src="${"https://sleepercdn.com/images/team_logos/nfl/" + escape(viewManager.favoriteTeam) + ".png"}" alt="${"favorite team"}">` : ``}</div>

        <div class="${"managerNav upper svelte-12f8478"}">${validate_component(Group, "Group").$$render($$result, { variant: "outlined" }, {}, {
    default: () => `${manager == 0 ? `${validate_component(Button_1, "Button").$$render($$result, {
      disabled: true,
      class: "selectionButtons",
      variant: "outlined"
    }, {}, {
      default: () => `${validate_component(CommonLabel, "Label").$$render($$result, {}, {}, { default: () => `Previous Manager` })}`
    })}` : `${validate_component(Button_1, "Button").$$render($$result, {
      class: "selectionButtons",
      variant: "outlined"
    }, {}, {
      default: () => `${validate_component(CommonLabel, "Label").$$render($$result, {}, {}, { default: () => `Previous Manager` })}`
    })}`}
                ${validate_component(Button_1, "Button").$$render($$result, {
      class: "selectionButtons",
      variant: "outlined"
    }, {}, {
      default: () => `${validate_component(CommonLabel, "Label").$$render($$result, {}, {}, { default: () => `All Managers` })}`
    })}
                ${manager == managers2.length - 1 ? `${validate_component(Button_1, "Button").$$render($$result, {
      disabled: true,
      class: "selectionButtons",
      variant: "outlined"
    }, {}, {
      default: () => `${validate_component(CommonLabel, "Label").$$render($$result, {}, {}, { default: () => `Next Manager` })}`
    })}` : `${validate_component(Button_1, "Button").$$render($$result, {
      class: "selectionButtons",
      variant: "outlined"
    }, {}, {
      default: () => `${validate_component(CommonLabel, "Label").$$render($$result, {}, {}, { default: () => `Next Manager` })}`
    })}`}`
  })}</div>

        <p class="${"bio svelte-12f8478"}"><!-- HTML_TAG_START -->${viewManager.bio}<!-- HTML_TAG_END --></p>

        ${viewManager.philosophy ? `
            <h3 class="${"svelte-12f8478"}">Team Philosophy</h3>
            <p class="${"philosophy svelte-12f8478"}"><!-- HTML_TAG_START -->${viewManager.philosophy}<!-- HTML_TAG_END --></p>` : ``}</div>

    ${``}

    ${validate_component(ManagerAwards, "ManagerAwards").$$render($$result, {
    tookOver: viewManager.tookOver,
    awards: awards2,
    records: records2,
    roster
  }, {}, {})}

    ${`
        <div class="${"loading svelte-12f8478"}"><p>Retrieving players...</p>
            ${validate_component(LinearProgress, "LinearProgress").$$render($$result, { indeterminate: true }, {}, {})}</div>`}

    <h3 class="${"svelte-12f8478"}">Team Transactions</h3>
    <div class="${"managerConstrained svelte-12f8478"}"${add_attribute("this", el, 0)}>${`
            <div class="${"loading svelte-12f8478"}"><p>Retrieving players...</p>
                ${validate_component(LinearProgress, "LinearProgress").$$render($$result, { indeterminate: true }, {}, {})}</div>`}</div>

    <div class="${"managerNav svelte-12f8478"}">${validate_component(Group, "Group").$$render($$result, { variant: "outlined" }, {}, {
    default: () => `${manager == 0 ? `${validate_component(Button_1, "Button").$$render($$result, {
      disabled: true,
      class: "selectionButtons",
      variant: "outlined"
    }, {}, {
      default: () => `${validate_component(CommonLabel, "Label").$$render($$result, {}, {}, { default: () => `Previous Manager` })}`
    })}` : `${validate_component(Button_1, "Button").$$render($$result, {
      class: "selectionButtons",
      variant: "outlined"
    }, {}, {
      default: () => `${validate_component(CommonLabel, "Label").$$render($$result, {}, {}, { default: () => `Previous Manager` })}`
    })}`}
            ${validate_component(Button_1, "Button").$$render($$result, {
      class: "selectionButtons",
      variant: "outlined"
    }, {}, {
      default: () => `${validate_component(CommonLabel, "Label").$$render($$result, {}, {}, { default: () => `All Managers` })}`
    })}
            ${manager == managers2.length - 1 ? `${validate_component(Button_1, "Button").$$render($$result, {
      disabled: true,
      class: "selectionButtons",
      variant: "outlined"
    }, {}, {
      default: () => `${validate_component(CommonLabel, "Label").$$render($$result, {}, {}, { default: () => `Next Manager` })}`
    })}` : `${validate_component(Button_1, "Button").$$render($$result, {
      class: "selectionButtons",
      variant: "outlined"
    }, {}, {
      default: () => `${validate_component(CommonLabel, "Label").$$render($$result, {}, {}, { default: () => `Next Manager` })}`
    })}`}`
  })}</div></div>`;
});
var Managers = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let { managers: managers2, manager, rostersData, users: users2, leagueData: leagueData2, transactionsData, awards: awards2, records: records2 } = $$props;
  const refreshTransactions = async () => {
    const newTransactions = await getLeagueTransactions(false, true);
    transactionsData = newTransactions;
  };
  if (transactionsData.stale) {
    refreshTransactions();
  }
  if ($$props.managers === void 0 && $$bindings.managers && managers2 !== void 0)
    $$bindings.managers(managers2);
  if ($$props.manager === void 0 && $$bindings.manager && manager !== void 0)
    $$bindings.manager(manager);
  if ($$props.rostersData === void 0 && $$bindings.rostersData && rostersData !== void 0)
    $$bindings.rostersData(rostersData);
  if ($$props.users === void 0 && $$bindings.users && users2 !== void 0)
    $$bindings.users(users2);
  if ($$props.leagueData === void 0 && $$bindings.leagueData && leagueData2 !== void 0)
    $$bindings.leagueData(leagueData2);
  if ($$props.transactionsData === void 0 && $$bindings.transactionsData && transactionsData !== void 0)
    $$bindings.transactionsData(transactionsData);
  if ($$props.awards === void 0 && $$bindings.awards && awards2 !== void 0)
    $$bindings.awards(awards2);
  if ($$props.records === void 0 && $$bindings.records && records2 !== void 0)
    $$bindings.records(records2);
  return `<div class="${"matchups"}">${manager ? `
        ${validate_component(Manager, "Manager").$$render($$result, {
    awards: awards2,
    records: records2,
    manager,
    managers: managers2,
    rostersData,
    users: users2,
    rosterPositions: leagueData2.roster_positions,
    transactions: transactionsData.transactions,
    currentManagers: transactionsData.currentManagers
  }, {}, {})}` : `${validate_component(AllManagers, "AllManagers").$$render($$result, { managers: managers2, rosters: rostersData, users: users2 }, {}, {})}`}</div>`;
});
var css$g = {
  code: ".enclosure.svelte-opznfs{display:block;position:relative;width:100%}",
  map: `{"version":3,"file":"PowerRankingsDisplay.svelte","sources":["PowerRankingsDisplay.svelte"],"sourcesContent":["<script>\\n    import BarChart from '$lib/BarChart.svelte';\\n    import { generateGraph, round, predictScores, loadPlayers } from '$lib/utils/helper';\\n    export let nflState, rostersData, users, playersInfo, leagueData;\\n\\n    const rosters = rostersData.rosters;\\n\\n    const currentManagers = {};\\n\\n    for(const roster of rosters) {\\n        const user = users[roster.owner_id];\\n        currentManagers[roster.roster_id] = {\\n            avatar: \`https://sleepercdn.com/avatars/thumbs/\${user.avatar}\`,\\n            name: user.metadata.team_name ? user.metadata.team_name : user.display_name,\\n        }\\n    }\\n\\n    let validGraph = false;\\n\\n    let graphs = [];\\n\\n    const buildRankings = () => {\\n        const rosterPowers = [];\\n        let week = nflState.week;\\n        if(week == 0) {\\n            week = 1;\\n        }\\n        let max = 0;\\n\\n        for(const roster of rosters) {\\n            // make sure the roster has players on it\\n            if(!roster.players) continue;\\n            // if at least one team has players, create the graph\\n            validGraph = true;\\n\\n            const rosterPlayers = [];\\n\\n            for(const rosterPlayer of roster.players) {\\n                rosterPlayers.push({\\n                    name: players[rosterPlayer].ln,\\n                    pos: players[rosterPlayer].pos,\\n                    wi: players[rosterPlayer].wi\\n                })\\n            }\\n\\n            const rosterPower = {\\n                rosterID: roster.roster_id,\\n                manager: currentManagers[roster.roster_id],\\n                powerScore: 0,\\n            }\\n            const seasonEnd = 18;\\n            for(let i = week; i < seasonEnd; i++) {\\n                rosterPower.powerScore += predictScores(rosterPlayers, i, leagueData);\\n            }\\n            if(rosterPower.powerScore > max) {\\n                max = rosterPower.powerScore;\\n            }\\n            rosterPowers.push(rosterPower);\\n        }\\n\\n        for(const rosterPower of rosterPowers) {\\n            rosterPower.powerScore = round(rosterPower.powerScore/max * 100);\\n        }\\n\\n        const powerGraph = {\\n            stats: rosterPowers,\\n            x: \\"Manager\\",\\n            y: \\"Power Ranking\\",\\n            stat: \\"\\",\\n            header: \\"Rest of Season Power Rankings\\",\\n            field: \\"powerScore\\",\\n            short: \\"ROS Power Ranking\\"\\n        };\\n\\n        graphs = [\\n            generateGraph(powerGraph, 10)\\n        ]\\n    }\\n\\n    let players = playersInfo.players;\\n\\n    buildRankings();\\n\\n    const refreshPlayers = async () => {\\n        const newPlayersInfo = await loadPlayers(true);\\n        players = newPlayersInfo.players;\\n        buildRankings();\\n    }\\n\\n    if(playersInfo.stale) {\\n        refreshPlayers();\\n    }\\n\\n    let curGraph = 0;\\n\\n    let el;\\n    let maxWidth = 620;\\n\\n\\n    const resize = (w) => {\\n        const left = el?.getBoundingClientRect() ? el?.getBoundingClientRect().left  : 0;\\n        const right = el?.getBoundingClientRect() ? el?.getBoundingClientRect().right  : 0;\\n\\n        maxWidth = right - left;\\n    }\\n    let innerWidth;\\n\\n    $: resize(innerWidth);\\n\\n<\/script>\\n\\n<svelte:window bind:innerWidth={innerWidth} />\\n\\n<style>\\n    .enclosure {\\n        display: block;\\n        position: relative;\\n        width: 100%;\\n    }\\n</style>\\n\\n{#if validGraph}\\n    <div class=\\"enclosure\\" bind:this={el}>\\n        <BarChart {maxWidth} {graphs} bind:curGraph={curGraph} />\\n    </div>\\n{/if}"],"names":[],"mappings":"AAkHI,UAAU,cAAC,CAAC,AACR,OAAO,CAAE,KAAK,CACd,QAAQ,CAAE,QAAQ,CAClB,KAAK,CAAE,IAAI,AACf,CAAC"}`
};
var PowerRankingsDisplay = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let { nflState: nflState2, rostersData, users: users2, playersInfo, leagueData: leagueData2 } = $$props;
  const rosters = rostersData.rosters;
  const currentManagers = {};
  for (const roster of rosters) {
    const user = users2[roster.owner_id];
    currentManagers[roster.roster_id] = {
      avatar: `https://sleepercdn.com/avatars/thumbs/${user.avatar}`,
      name: user.metadata.team_name ? user.metadata.team_name : user.display_name
    };
  }
  let validGraph = false;
  let graphs = [];
  const buildRankings = () => {
    const rosterPowers = [];
    let week = nflState2.week;
    if (week == 0) {
      week = 1;
    }
    let max2 = 0;
    for (const roster of rosters) {
      if (!roster.players)
        continue;
      validGraph = true;
      const rosterPlayers = [];
      for (const rosterPlayer of roster.players) {
        rosterPlayers.push({
          name: players2[rosterPlayer].ln,
          pos: players2[rosterPlayer].pos,
          wi: players2[rosterPlayer].wi
        });
      }
      const rosterPower = {
        rosterID: roster.roster_id,
        manager: currentManagers[roster.roster_id],
        powerScore: 0
      };
      const seasonEnd = 18;
      for (let i = week; i < seasonEnd; i++) {
        rosterPower.powerScore += predictScores(rosterPlayers, i, leagueData2);
      }
      if (rosterPower.powerScore > max2) {
        max2 = rosterPower.powerScore;
      }
      rosterPowers.push(rosterPower);
    }
    for (const rosterPower of rosterPowers) {
      rosterPower.powerScore = round(rosterPower.powerScore / max2 * 100);
    }
    const powerGraph = {
      stats: rosterPowers,
      x: "Manager",
      y: "Power Ranking",
      stat: "",
      header: "Rest of Season Power Rankings",
      field: "powerScore",
      short: "ROS Power Ranking"
    };
    graphs = [generateGraph(powerGraph, 10)];
  };
  let players2 = playersInfo.players;
  buildRankings();
  const refreshPlayers = async () => {
    const newPlayersInfo = await loadPlayers(true);
    players2 = newPlayersInfo.players;
    buildRankings();
  };
  if (playersInfo.stale) {
    refreshPlayers();
  }
  let curGraph = 0;
  let el;
  let maxWidth = 620;
  const resize = (w) => {
    const left = (el == null ? void 0 : el.getBoundingClientRect()) ? el == null ? void 0 : el.getBoundingClientRect().left : 0;
    const right = (el == null ? void 0 : el.getBoundingClientRect()) ? el == null ? void 0 : el.getBoundingClientRect().right : 0;
    maxWidth = right - left;
  };
  if ($$props.nflState === void 0 && $$bindings.nflState && nflState2 !== void 0)
    $$bindings.nflState(nflState2);
  if ($$props.rostersData === void 0 && $$bindings.rostersData && rostersData !== void 0)
    $$bindings.rostersData(rostersData);
  if ($$props.users === void 0 && $$bindings.users && users2 !== void 0)
    $$bindings.users(users2);
  if ($$props.playersInfo === void 0 && $$bindings.playersInfo && playersInfo !== void 0)
    $$bindings.playersInfo(playersInfo);
  if ($$props.leagueData === void 0 && $$bindings.leagueData && leagueData2 !== void 0)
    $$bindings.leagueData(leagueData2);
  $$result.css.add(css$g);
  let $$settled;
  let $$rendered;
  do {
    $$settled = true;
    {
      resize();
    }
    $$rendered = `



${validGraph ? `<div class="${"enclosure svelte-opznfs"}"${add_attribute("this", el, 0)}>${validate_component(BarChart, "BarChart").$$render($$result, { maxWidth, graphs, curGraph }, {
      curGraph: ($$value) => {
        curGraph = $$value;
        $$settled = false;
      }
    }, {})}</div>` : ``}`;
  } while (!$$settled);
  return $$rendered;
});
var css$f = {
  code: ".loading.svelte-1dl9ot{display:block;width:85%;max-width:500px;margin:80px auto}",
  map: `{"version":3,"file":"index.svelte","sources":["index.svelte"],"sourcesContent":["<script>\\n    import {getNflState, getLeagueRosters, getLeagueUsers, waitForAll, getLeagueRecords, loadPlayers, getLeagueData} from '$lib/utils/helper';\\n    import PowerRankingsDisplay from './PowerRankingsDisplay.svelte';\\n    import LinearProgress from '@smui/linear-progress';\\n    \\n    const helperPromises = waitForAll(\\n        getNflState(),\\n        getLeagueRosters(),\\n        getLeagueUsers(),\\n        getLeagueRecords(),\\n        getLeagueData(),\\n        loadPlayers(),\\n    );\\n\\n<\/script>\\n\\n<style>\\n    .loading {\\n        display: block;\\n        width: 85%;\\n        max-width: 500px;\\n        margin: 80px auto;\\n    }\\n</style>\\n\\n{#await helperPromises}\\n    <!-- promise is pending -->\\n    <div class=\\"loading\\">\\n        <p>Calculating power rankings...</p>\\n        <LinearProgress indeterminate />\\n    </div>\\n{:then [nflState, rostersData, users, records, leagueData, playersInfo]}\\n    {#if leagueData.status != 'pre_draft'}\\n        <PowerRankingsDisplay {nflState} {rostersData} {users} {leagueData} {records} {playersInfo} />\\n    {/if}\\n{:catch error}\\n\\t<!-- promise was rejected -->\\n\\t<p>Something went wrong: {error.message}</p>\\n{/await}\\n\\n\\n\\n"],"names":[],"mappings":"AAiBI,QAAQ,cAAC,CAAC,AACN,OAAO,CAAE,KAAK,CACd,KAAK,CAAE,GAAG,CACV,SAAS,CAAE,KAAK,CAChB,MAAM,CAAE,IAAI,CAAC,IAAI,AACrB,CAAC"}`
};
var PowerRankings = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  const helperPromises = waitForAll(getNflState(), getLeagueRosters(), getLeagueUsers(), getLeagueRecords(), getLeagueData(), loadPlayers());
  $$result.css.add(css$f);
  return `${function(__value) {
    if (is_promise(__value)) {
      __value.then(null, noop);
      return `
    
    <div class="${"loading svelte-1dl9ot"}"><p>Calculating power rankings...</p>
        ${validate_component(LinearProgress, "LinearProgress").$$render($$result, { indeterminate: true }, {}, {})}</div>
`;
    }
    return function([nflState2, rostersData, users2, records2, leagueData2, playersInfo]) {
      return `
    ${leagueData2.status != "pre_draft" ? `${validate_component(PowerRankingsDisplay, "PowerRankingsDisplay").$$render($$result, {
        nflState: nflState2,
        rostersData,
        users: users2,
        leagueData: leagueData2,
        records: records2,
        playersInfo
      }, {}, {})}` : ``}
`;
    }(__value);
  }(helperPromises)}`;
});
classAdderBuilder({
  class: "mdc-dialog__header",
  component: Div,
  contexts: {
    "SMUI:icon-button:context": "dialog:header"
  }
});
classAdderBuilder({
  class: "mdc-dialog__title",
  component: H2
});
classAdderBuilder({
  class: "mdc-dialog__content",
  component: Div
});
classAdderBuilder({
  class: "mdc-dialog__actions",
  component: Div,
  classMap: {
    "smui-dialog__actions--reversed": "SMUI:dialog:actions:reversed"
  },
  contexts: {
    "SMUI:button:context": "dialog:action"
  }
});
var css$e = {
  code: "h2.svelte-7ftbrx{font-size:3em;text-align:center;margin-bottom:0.2em}.loading.svelte-7ftbrx{display:block;position:relative;z-index:1;width:85%;max-width:500px;margin:80px auto}.filter.svelte-7ftbrx{display:inline-flex;color:#fff;border-radius:2em;font-size:0.8em;padding:0.25em 1em}.noUnderline.svelte-7ftbrx{margin:0.5em;text-decoration:none}.filterClear.svelte-7ftbrx{background-color:#920505}.filterClear.svelte-7ftbrx:hover{background-color:#720404}.filterLink.svelte-7ftbrx{background-color:#00316b}.filterLink.svelte-7ftbrx:not(.noHover):hover{background-color:#0082c3}.noHover.svelte-7ftbrx{cursor:default}.filterButtons.svelte-7ftbrx{display:flex;flex-wrap:wrap;justify-content:center;margin:1em 0 3em}.filteringBy.svelte-7ftbrx{font-size:1em}",
  map: `{"version":3,"file":"Posts.svelte","sources":["Posts.svelte"],"sourcesContent":["<script>\\n    import { goto } from \\"$app/navigation\\";\\n    import Pagination from \\"$lib/Pagination.svelte\\";\\n    import { getBlogPosts, leagueName } from \\"$lib/utils/helper\\";\\n    import LinearProgress from \\"@smui/linear-progress\\";\\n    import { onMount } from \\"svelte\\";\\n    import Post from \\"./Post.svelte\\";\\n\\n    export let postsData, usersData, rostersData, queryPage = 1, filterKey = '';\\n\\n    let page = queryPage - 1;\\n\\n    const lang = \\"en-US\\";\\n\\n    let loading = true;\\n    let allPosts = [];\\n    let posts = [];\\n    let users = {};\\n    let rosters = [];\\n\\n    let categories;\\n\\n    const filterPosts = (ap, fk) => {\\n        if(ap.length && fk != '') {\\n            posts = ap.filter(p => p.fields.type[lang] == fk);\\n        } else {\\n            posts = ap;\\n        }\\n    }\\n\\n    $: filterPosts(allPosts, filterKey);\\n\\n    onMount(async ()=> {\\n        const startPostData = await postsData;\\n        users = await usersData;\\n        const rostersInfo = await rostersData;\\n        rosters = rostersInfo.rosters;\\n        allPosts = startPostData.posts;\\n        loading = false;\\n\\n        const categoryMap = new Set();\\n        for(const post of startPostData.posts) {\\n            categoryMap.add(post.fields.type[lang]);\\n        }\\n        categories = [...categoryMap];\\n\\n        if(!startPostData.fresh) {\\n            const blogResponse = await getBlogPosts(true);\\n            allPosts = blogResponse.posts;\\n            const categoryMap = new Set();\\n            for(const post of blogResponse.posts) {\\n                categoryMap.add(post.fields.type[lang]);\\n            }\\n            categories = [...categoryMap];\\n        }\\n    })\\n\\n    const perPage = 10;\\n    $: total = posts.length;\\n\\n    let el;\\n    $: top = el?.getBoundingClientRect() ? el?.getBoundingClientRect().bottom  : 0\\n\\n    $: displayPosts = posts.slice(page * perPage, (page + 1) * perPage);\\n\\n    let direction = 1;\\n\\n    const changePage = (dest) => {\\n        if(dest + 1 > queryPage) {\\n            direction = 1;\\n        } else {\\n            direction = -1;\\n        }\\n        setTimeout(() => {goto(\`/blog?page=\${dest + 1}&filter=\${filterKey}\`, {noscroll: true,  keepfocus: true})}, 800);\\n    }\\n\\n\\t$: changePage(page);\\n<\/script>\\n\\n<style>\\n    h2 {\\n        font-size: 3em;\\n        text-align: center;\\n        margin-bottom: 0.2em;\\n    }\\n\\t.loading {\\n\\t\\tdisplay: block;\\n\\t\\tposition: relative;\\n\\t\\tz-index: 1;\\n\\t\\twidth: 85%;\\n\\t\\tmax-width: 500px;\\n\\t\\tmargin: 80px auto;\\n\\t}\\n    .filter {\\n        display: inline-flex;\\n        color: #fff;\\n        border-radius: 2em;\\n        font-size: 0.8em;\\n        padding: 0.25em 1em;\\n    }\\n\\n    .noUnderline {\\n        margin: 0.5em;\\n        text-decoration: none;\\n    }\\n\\n    .filterClear {\\n        background-color: #920505;\\n    }\\n\\n    .filterClear:hover {\\n        background-color: #720404;\\n    }\\n\\n    .filterLink {\\n        background-color: #00316b;\\n    }\\n\\n    .filterLink:not(.noHover):hover {\\n        background-color: #0082c3;\\n    }\\n\\n    .noHover {\\n        cursor: default;\\n    }\\n\\n    .filterButtons {\\n        display: flex;\\n        flex-wrap: wrap;\\n        justify-content: center;\\n        margin: 1em 0 3em;\\n    }\\n\\n    .filteringBy {\\n        font-size: 1em;\\n    }\\n</style>\\n\\n<h2 bind:this={el}>{leagueName} Blog</h2>\\n\\n{#if loading}\\n    <div class=\\"loading\\" >\\n        <p>Loading league blog posts...</p>\\n        <LinearProgress indeterminate />\\n    </div>\\n{:else}\\n    <div class=\\"filterButtons\\">\\n        {#if filterKey == ''}\\n            {#each categories as category}\\n                <a class=\\"noUnderline\\" href=\\"/blog?filter={category}&page=1\\"><div class=\\"filter filterLink\\">{category}</div></a>\\n            {/each}\\n        {:else}\\n            <div class=\\"filteringBy\\">Showing <div class=\\"filter filterLink noHover\\">{filterKey}</div> posts <a class=\\"noUnderline\\" href=\\"/blog?filter=&page=1\\"><div class=\\"filter filterClear\\">Clear Filter</div></a></div>\\n        {/if}\\n    </div>\\n\\n    <Pagination {perPage} {total} bind:page={page} target={top} scroll={false} />\\n\\n    {#each displayPosts as post}\\n        <Post {rosters} {users} createdAt={post.sys.createdAt} post={post.fields} id={post.sys.id} {direction} />\\n    {/each}\\n    <Pagination {perPage} {total} bind:page={page} target={top} scroll={true} />\\n{/if}\\n"],"names":[],"mappings":"AAgFI,EAAE,cAAC,CAAC,AACA,SAAS,CAAE,GAAG,CACd,UAAU,CAAE,MAAM,CAClB,aAAa,CAAE,KAAK,AACxB,CAAC,AACJ,QAAQ,cAAC,CAAC,AACT,OAAO,CAAE,KAAK,CACd,QAAQ,CAAE,QAAQ,CAClB,OAAO,CAAE,CAAC,CACV,KAAK,CAAE,GAAG,CACV,SAAS,CAAE,KAAK,CAChB,MAAM,CAAE,IAAI,CAAC,IAAI,AAClB,CAAC,AACE,OAAO,cAAC,CAAC,AACL,OAAO,CAAE,WAAW,CACpB,KAAK,CAAE,IAAI,CACX,aAAa,CAAE,GAAG,CAClB,SAAS,CAAE,KAAK,CAChB,OAAO,CAAE,MAAM,CAAC,GAAG,AACvB,CAAC,AAED,YAAY,cAAC,CAAC,AACV,MAAM,CAAE,KAAK,CACb,eAAe,CAAE,IAAI,AACzB,CAAC,AAED,YAAY,cAAC,CAAC,AACV,gBAAgB,CAAE,OAAO,AAC7B,CAAC,AAED,0BAAY,MAAM,AAAC,CAAC,AAChB,gBAAgB,CAAE,OAAO,AAC7B,CAAC,AAED,WAAW,cAAC,CAAC,AACT,gBAAgB,CAAE,OAAO,AAC7B,CAAC,AAED,yBAAW,KAAK,QAAQ,CAAC,MAAM,AAAC,CAAC,AAC7B,gBAAgB,CAAE,OAAO,AAC7B,CAAC,AAED,QAAQ,cAAC,CAAC,AACN,MAAM,CAAE,OAAO,AACnB,CAAC,AAED,cAAc,cAAC,CAAC,AACZ,OAAO,CAAE,IAAI,CACb,SAAS,CAAE,IAAI,CACf,eAAe,CAAE,MAAM,CACvB,MAAM,CAAE,GAAG,CAAC,CAAC,CAAC,GAAG,AACrB,CAAC,AAED,YAAY,cAAC,CAAC,AACV,SAAS,CAAE,GAAG,AAClB,CAAC"}`
};
var lang = "en-US";
var perPage$1 = 10;
var Posts = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let { postsData, usersData, rostersData, queryPage = 1, filterKey = "" } = $$props;
  let page = queryPage - 1;
  let allPosts = [];
  let posts = [];
  const filterPosts = (ap, fk) => {
    if (ap.length && fk != "") {
      posts = ap.filter((p) => p.fields.type[lang] == fk);
    } else {
      posts = ap;
    }
  };
  let el;
  const changePage = (dest) => {
    setTimeout(() => {
      goto(`/blog?page=${dest + 1}&filter=${filterKey}`, { noscroll: true, keepfocus: true });
    }, 800);
  };
  if ($$props.postsData === void 0 && $$bindings.postsData && postsData !== void 0)
    $$bindings.postsData(postsData);
  if ($$props.usersData === void 0 && $$bindings.usersData && usersData !== void 0)
    $$bindings.usersData(usersData);
  if ($$props.rostersData === void 0 && $$bindings.rostersData && rostersData !== void 0)
    $$bindings.rostersData(rostersData);
  if ($$props.queryPage === void 0 && $$bindings.queryPage && queryPage !== void 0)
    $$bindings.queryPage(queryPage);
  if ($$props.filterKey === void 0 && $$bindings.filterKey && filterKey !== void 0)
    $$bindings.filterKey(filterKey);
  $$result.css.add(css$e);
  let $$settled;
  let $$rendered;
  do {
    $$settled = true;
    {
      filterPosts(allPosts, filterKey);
    }
    (el == null ? void 0 : el.getBoundingClientRect()) ? el == null ? void 0 : el.getBoundingClientRect().bottom : 0;
    posts.slice(page * perPage$1, (page + 1) * perPage$1);
    {
      changePage(page);
    }
    $$rendered = `<h2 class="${"svelte-7ftbrx"}"${add_attribute("this", el, 0)}>${escape(leagueName)} Blog</h2>

${`<div class="${"loading svelte-7ftbrx"}"><p>Loading league blog posts...</p>
        ${validate_component(LinearProgress, "LinearProgress").$$render($$result, { indeterminate: true }, {}, {})}</div>`}`;
  } while (!$$settled);
  return $$rendered;
});
var css$d = {
  code: ".loading.svelte-coyrw9{display:block;width:85%;max-width:500px;margin:80px auto}.center{text-align:center}.wrappable{white-space:normal;line-height:1.2em}h1.svelte-coyrw9{font-size:2.2em;line-height:1.3em;margin:1.5em 0 2em}.standingsTable.svelte-coyrw9{max-width:100%;overflow-x:scroll;margin:0.5em 0 5em}",
  map: `{"version":3,"file":"index.svelte","sources":["index.svelte"],"sourcesContent":["<script>\\n    import { leagueName, round } from '$lib/utils/helper';\\n  \\timport DataTable, { Head, Body, Row, Cell } from '@smui/data-table';\\n\\timport LinearProgress from '@smui/linear-progress';\\n    import { onMount } from 'svelte';\\n    import Standing from './Standing.svelte';\\n\\n    export let standingsData, usersData;\\n\\n    // Least important to most important (i.e. the most important [usually wins] goes last)\\n    // Edit this to match your leagues settings\\n    const sortOrder = [\\"fptsAgainst\\", \\"divisionTies\\", \\"divisionWins\\", \\"fpts\\", \\"ties\\", \\"wins\\"];\\n\\n    // Column order from left to right\\n    const columnOrder = [{name: \\"W\\", field: \\"wins\\"}, {name: \\"T\\", field: \\"ties\\"}, {name: \\"L\\", field: \\"losses\\"}, {name: \\"Div W\\", field: \\"divisionWins\\"}, {name: \\"Div T\\", field: \\"divisionTies\\"}, {name: \\"Div L\\", field: \\"divisionLosses\\"}, {name: \\"FPTS\\", field: \\"fpts\\"}, {name: \\"FPTS Against\\", field: \\"fptsAgainst\\"}]\\n\\n    let loading = true;\\n    let rosters, standings, year, users;\\n    onMount(async () => {\\n        const {standingsInfo, yearData, rostersData} = await standingsData;\\n        users = await usersData;\\n        rosters = rostersData;\\n        year = yearData;\\n        for(const standingKey in standingsInfo) {\\n            const roster = rosters[standingsInfo[standingKey].rosterID - 1];\\n            standingsInfo[standingKey].fpts = round(roster.settings.fpts + (roster.settings.fpts_decimal / 100));\\n            standingsInfo[standingKey].fptsAgainst = round(roster.settings.fpts_against + (roster.settings.fpts_against_decimal / 100));\\n        }\\n\\n        let finalStandings = Object.keys(standingsInfo).map((key) => standingsInfo[key]);\\n\\n        for(const sortType of sortOrder) {\\n            if(!finalStandings[0][sortType] && finalStandings[0][sortType] != 0) {\\n                continue;\\n            }\\n            finalStandings = [...finalStandings].sort((a,b) => b[sortType] - a[sortType]);\\n        }\\n\\n        standings = finalStandings;\\n        loading = false;\\n    })\\n\\n    let innerWidth;\\n\\n<\/script>\\n\\n<svelte:window bind:innerWidth={innerWidth} />\\n\\n<style>\\n    .loading {\\n        display: block;\\n        width: 85%;\\n        max-width: 500px;\\n        margin: 80px auto;\\n    }\\n\\n    :global(.center) {\\n        text-align: center;\\n    }\\n\\n    :global(.wrappable) {\\n        white-space: normal;\\n        line-height: 1.2em;\\n    }\\n\\n    h1 {\\n        font-size: 2.2em;\\n        line-height: 1.3em;\\n        margin: 1.5em 0 2em;\\n    }\\n\\n    .standingsTable {\\n        max-width: 100%;\\n        overflow-x: scroll;\\n        margin: 0.5em 0 5em;\\n    }\\n</style>\\n\\n<h1>{year} {leagueName} Standings</h1>\\n\\n{#if loading}\\n    <!-- promise is pending -->\\n    <div class=\\"loading\\">\\n        <p>Loading Standings...</p>\\n        <LinearProgress indeterminate />\\n    </div>\\n{:else}\\n    <div class=\\"standingsTable\\">\\n        <DataTable table$aria-label=\\"League Standings\\" >\\n            <Head> <!-- Team name  -->\\n                <Row>\\n                    <Cell class=\\"center\\">Team</Cell>\\n                    {#each columnOrder as column}\\n                        <Cell class=\\"center wrappable\\">{column.name}</Cell>\\n                    {/each}\\n                </Row>\\n            </Head>\\n            <Body>\\n                <!-- \\tStanding\\t -->\\n                {#each standings as standing}\\n                    <Standing {columnOrder} {standing} user={users[rosters[standing.rosterID - 1].owner_id]} roster={rosters[standing.rosterID - 1]} />\\n                {/each}\\n            </Body>\\n        </DataTable>\\n    </div>\\n{/if}\\n"],"names":[],"mappings":"AAiDI,QAAQ,cAAC,CAAC,AACN,OAAO,CAAE,KAAK,CACd,KAAK,CAAE,GAAG,CACV,SAAS,CAAE,KAAK,CAChB,MAAM,CAAE,IAAI,CAAC,IAAI,AACrB,CAAC,AAEO,OAAO,AAAE,CAAC,AACd,UAAU,CAAE,MAAM,AACtB,CAAC,AAEO,UAAU,AAAE,CAAC,AACjB,WAAW,CAAE,MAAM,CACnB,WAAW,CAAE,KAAK,AACtB,CAAC,AAED,EAAE,cAAC,CAAC,AACA,SAAS,CAAE,KAAK,CAChB,WAAW,CAAE,KAAK,CAClB,MAAM,CAAE,KAAK,CAAC,CAAC,CAAC,GAAG,AACvB,CAAC,AAED,eAAe,cAAC,CAAC,AACb,SAAS,CAAE,IAAI,CACf,UAAU,CAAE,MAAM,CAClB,MAAM,CAAE,KAAK,CAAC,CAAC,CAAC,GAAG,AACvB,CAAC"}`
};
var Standings = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let { standingsData, usersData } = $$props;
  let year;
  if ($$props.standingsData === void 0 && $$bindings.standingsData && standingsData !== void 0)
    $$bindings.standingsData(standingsData);
  if ($$props.usersData === void 0 && $$bindings.usersData && usersData !== void 0)
    $$bindings.usersData(usersData);
  $$result.css.add(css$d);
  return `



<h1 class="${"svelte-coyrw9"}">${escape(year)} ${escape(leagueName)} Standings</h1>

${`
    <div class="${"loading svelte-coyrw9"}"><p>Loading Standings...</p>
        ${validate_component(LinearProgress, "LinearProgress").$$render($$result, { indeterminate: true }, {}, {})}</div>`}`;
});
var load$a = async ({ page }) => ({ props: { activeTab: page.path } });
var _layout = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let { activeTab } = $$props;
  if ($$props.activeTab === void 0 && $$bindings.activeTab && activeTab !== void 0)
    $$bindings.activeTab(activeTab);
  let $$settled;
  let $$rendered;
  do {
    $$settled = true;
    $$rendered = `





<div>${validate_component(Nav, "Nav").$$render($$result, { activeTab }, {
      activeTab: ($$value) => {
        activeTab = $$value;
        $$settled = false;
      }
    }, {})} 
  
    ${slots.default ? slots.default({ activeTab }) : ``}

    ${validate_component(Footer, "Footer").$$render($$result, {}, {}, {})} </div>`;
  } while (!$$settled);
  return $$rendered;
});
var __layout = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": _layout,
  load: load$a
});
var css$c = {
  code: ".main.svelte-1vt4zap{position:relative;z-index:1}h4.svelte-1vt4zap,h5.svelte-1vt4zap{text-align:center}.footballHolder.svelte-1vt4zap{text-align:center;padding:2em 0}h4.svelte-1vt4zap{color:var(--blueOne);font-weight:700;margin:3em 0 1em}.football.svelte-1vt4zap{width:80%;max-width:300px;height:auto}",
  map: `{"version":3,"file":"__error.svelte","sources":["__error.svelte"],"sourcesContent":["<style>\\n    .main {\\n        position: relative;\\n        z-index: 1;\\n    }\\n\\n    h4, h5 {\\n        text-align: center;\\n    }\\n\\n    .footballHolder {\\n        text-align: center;\\n        padding: 2em 0;\\n    }\\n\\n    h4 {\\n        color: var(--blueOne);\\n        font-weight: 700;\\n        margin: 3em 0 1em;\\n    }\\n\\n    .football {\\n        width: 80%;\\n        max-width: 300px;\\n        height: auto;\\n    }\\n</style>\\n\\n<div class=\\"main\\">\\n    <h4>\\n        Hut, Hut, Blue 404!\\n    </h4>\\n    <div class='footballHolder'>\\n        <img class='football' src='/deflated-football.png' alt='deflated football' />\\n    </div>\\n    <h5>\\n        Nothing Here... Try Another Page!\\n    </h5>\\n</div>"],"names":[],"mappings":"AACI,KAAK,eAAC,CAAC,AACH,QAAQ,CAAE,QAAQ,CAClB,OAAO,CAAE,CAAC,AACd,CAAC,AAED,iBAAE,CAAE,EAAE,eAAC,CAAC,AACJ,UAAU,CAAE,MAAM,AACtB,CAAC,AAED,eAAe,eAAC,CAAC,AACb,UAAU,CAAE,MAAM,CAClB,OAAO,CAAE,GAAG,CAAC,CAAC,AAClB,CAAC,AAED,EAAE,eAAC,CAAC,AACA,KAAK,CAAE,IAAI,SAAS,CAAC,CACrB,WAAW,CAAE,GAAG,CAChB,MAAM,CAAE,GAAG,CAAC,CAAC,CAAC,GAAG,AACrB,CAAC,AAED,SAAS,eAAC,CAAC,AACP,KAAK,CAAE,GAAG,CACV,SAAS,CAAE,KAAK,CAChB,MAAM,CAAE,IAAI,AAChB,CAAC"}`
};
var _error = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  $$result.css.add(css$c);
  return `<div class="${"main svelte-1vt4zap"}"><h4 class="${"svelte-1vt4zap"}">Hut, Hut, Blue 404!
    </h4>
    <div class="${"footballHolder svelte-1vt4zap"}"><img class="${"football svelte-1vt4zap"}" src="${"/deflated-football.png"}" alt="${"deflated football"}"></div>
    <h5 class="${"svelte-1vt4zap"}">Nothing Here... Try Another Page!
    </h5></div>`;
});
var __error = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": _error
});
var css$b = {
  code: "#home.svelte-1kgzb7c{display:flex;flex-wrap:nowrap;position:relative;overflow-y:hidden;z-index:1}#main.svelte-1kgzb7c{flex-grow:1;min-width:320px;margin:0 auto;padding:60px 0}.text.svelte-1kgzb7c{padding:0 30px;max-width:620px;margin:0 auto}.leagueData.svelte-1kgzb7c{position:relative;z-index:1;width:100%;min-width:470px;max-width:470px;min-height:100%;background-color:var(--ebebeb);border-left:var(--eee);box-shadow:inset 0px 3px 3px -2px rgb(0 0 0 / 40%), inset 0px 3px 4px 0px rgb(0 0 0 / 28%), inset 0px 1px 8px 0px rgb(0 0 0 / 24%)}@media(max-width: 950px){.leagueData.svelte-1kgzb7c{max-width:100%;min-width:100%;width:100%}#home.svelte-1kgzb7c{flex-wrap:wrap}}.transactions.svelte-1kgzb7c{display:block;width:95%;margin:10px auto}.center.svelte-1kgzb7c{text-align:center}h6.svelte-1kgzb7c{text-align:center}#currentChamp.svelte-1kgzb7c{padding:25px 0;background-color:var(--f3f3f3);box-shadow:5px 0 8px var(--champShadow);border-left:1px solid var(--ddd)}#champ.svelte-1kgzb7c{position:relative;width:150px;height:150px;margin:0 auto;cursor:pointer}.first.svelte-1kgzb7c{position:absolute;transform:translate(-50%, -50%);width:80px;height:80px;border-radius:100%;border:1px solid #ccc;left:50%;top:43%}.laurel.svelte-1kgzb7c{position:absolute;transform:translate(-50%, -50%);width:135px;height:auto;left:50%;top:50%}h4.svelte-1kgzb7c{text-align:center;font-size:1.6em;margin:10px}.label.svelte-1kgzb7c{display:table;text-align:center;line-height:1.1em;padding:6px 20px;background-color:var(--fff);border:1px solid #aaa;margin:10px auto 0;cursor:pointer}.curOwner{font-size:0.75em;color:#bbb;font-style:italic}",
  map: `{"version":3,"file":"index.svelte","sources":["index.svelte"],"sourcesContent":["<script>\\n\\timport LinearProgress from '@smui/linear-progress';\\n\\timport { getNflState, cleanName, leagueName, homepageText, managers, gotoManager, enableBlog } from '$lib/utils/helper';\\n\\timport { Transactions, PowerRankings, HomePost} from '$lib/components';\\n    import { getAwards } from \\"$lib/utils/helper\\"\\n\\n    let nflState = getNflState();\\n    let podiumsData = getAwards();\\n\\n    const getNames = (name, rosterID, currentManagers) => {\\n\\t\\tif(cleanName(name) != cleanName(currentManagers[rosterID].name)) {\\n\\t\\t\\treturn \`\${name}<div class=\\"curOwner\\">(\${currentManagers[rosterID].name})</div>\`;\\n\\t\\t}\\n\\t\\treturn name;\\n\\t}\\n\\n    let el, left;\\n\\n    const resize = (w) => {\\n        left = el?.getBoundingClientRect() ? el?.getBoundingClientRect().left  : 0;\\n    }\\n\\n    $: resize(innerWidth);\\n\\n    let innerWidth;\\n\\n<\/script>\\n\\n<svelte:window bind:innerWidth={innerWidth} />\\n\\n<style>\\n    #home {\\n        display: flex;\\n        flex-wrap: nowrap;\\n        position: relative;\\n        overflow-y: hidden;\\n        z-index: 1;\\n    }\\n\\n    #main {\\n        flex-grow: 1;\\n        min-width: 320px;\\n        margin: 0 auto;\\n        padding: 60px 0;\\n    }\\n\\n    .text {\\n        padding: 0 30px;\\n        max-width: 620px;\\n        margin: 0 auto;\\n    }\\n\\n    .leagueData {\\n        position: relative;\\n        z-index: 1;\\n        width: 100%;\\n        min-width: 470px;\\n        max-width: 470px;\\n        min-height: 100%;\\n\\t\\tbackground-color: var(--ebebeb);\\n        border-left: var(--eee);\\n\\t\\tbox-shadow: inset 0px 3px 3px -2px rgb(0 0 0 / 40%), inset 0px 3px 4px 0px rgb(0 0 0 / 28%), inset 0px 1px 8px 0px rgb(0 0 0 / 24%);\\n    }\\n\\n    @media (max-width: 950px) {\\n        .leagueData {\\n            max-width: 100%;\\n            min-width: 100%;\\n            width: 100%;\\n        }\\n        #home {\\n            flex-wrap: wrap;\\n        }\\n    }\\n\\n    .transactions {\\n        display: block;\\n        width: 95%;\\n        margin: 10px auto;\\n    }\\n\\n    .center {\\n        text-align: center;\\n    }\\n\\n    h6 {\\n        text-align: center;\\n    }\\n\\n    /* champ styling */\\n    #currentChamp {\\n        padding: 25px 0;\\n\\t\\tbackground-color: var(--f3f3f3);\\n        box-shadow: 5px 0 8px var(--champShadow);\\n        border-left: 1px solid var(--ddd);\\n    }\\n\\n    #champ {\\n        position: relative;\\n        width: 150px;\\n        height: 150px;\\n        margin: 0 auto;\\n        cursor: pointer;\\n    }\\n\\n    .first {\\n        position: absolute;\\n        transform: translate(-50%, -50%);\\n        width: 80px;\\n        height: 80px;\\n        border-radius: 100%;\\n        border: 1px solid #ccc;\\n        left: 50%;\\n        top: 43%;\\n    }\\n\\n    .laurel {\\n        position: absolute;\\n        transform: translate(-50%, -50%);\\n        width: 135px;\\n        height: auto;\\n        left: 50%;\\n        top: 50%;\\n    }\\n\\n    h4 {\\n        text-align: center;\\n        font-size: 1.6em;\\n        margin: 10px;\\n    }\\n\\n    .label {\\n        display: table;\\n        text-align: center;\\n        line-height: 1.1em;\\n        padding: 6px 20px;\\n        background-color: var(--fff);\\n        border: 1px solid #aaa;\\n        margin: 10px auto 0;\\n        cursor: pointer;\\n    }\\n    \\n\\t:global(.curOwner) {\\n\\t\\tfont-size: 0.75em;\\n\\t\\tcolor: #bbb;\\n\\t\\tfont-style: italic;\\n\\t}\\n</style>\\n\\n<div id=\\"home\\">\\n    <div id=\\"main\\">\\n        <div class=\\"text\\">\\n            <h6>{leagueName}</h6>\\n            <!-- homepageText contains the intro text for your league, this gets edited in /src/lib/utils/leagueInfo.js -->\\n            {@html homepageText }\\n            <!-- Most recent Blog Post (if enabled) -->\\n            {#if enableBlog}\\n                <HomePost />\\n            {/if}\\n        </div>\\n        <PowerRankings />\\n    </div>\\n    \\n    <div class=\\"leagueData\\">\\n        <div class=\\"homeBanner\\">\\n            {#await nflState}\\n                <p class=\\"center\\">Retrieving NFL state...</p>\\n                <LinearProgress indeterminate />\\n            {:then nflStateData}\\n                <p class=\\"center\\">NFL {nflStateData.season} \\n                    {#if nflStateData.season_type == 'pre'}\\n                        Preseason\\n                    {:else if nflStateData.season_type == 'post'}\\n                        Postseason\\n                    {:else}\\n                        {nflStateData.week > 0 ? \`Week \${nflStateData.week}\` : \\"Preseason\\"}\\n                    {/if}\\n                </p>\\n            {:catch error}\\n                <p class=\\"center\\">Something went wrong: {error.message}</p>\\n            {/await}\\n        </div>\\n\\n        <div id=\\"currentChamp\\">\\n            {#await podiumsData}\\n                <p class=\\"center\\">Retrieving awards...</p>\\n                <LinearProgress indeterminate />\\n            {:then {podiums, currentManagers}}\\n                {#if podiums[0]}\\n                    <h4>{podiums[0].year} Champ</h4>\\n                    <div id=\\"champ\\" on:click={() => {if(managers.length) gotoManager(parseInt(podiums[0].champion.rosterID))}} >\\n                        <img src=\\"{podiums[0].champion.avatar}\\" class=\\"first\\" alt=\\"champion\\" />\\n                        <img src=\\"./laurel.png\\" class=\\"laurel\\" alt=\\"laurel\\" />\\n                    </div>\\n                    <span class=\\"label\\" on:click={() => gotoManager(parseInt(podiums[0].champion.rosterID))} >{@html getNames(podiums[0].champion.name, podiums[0].champion.rosterID, currentManagers)}</span>\\n                {:else}\\n                    <p class=\\"center\\">No former champs.</p>\\n                {/if}\\n            {:catch error}\\n                <p class=\\"center\\">Something went wrong: {error.message}</p>\\n            {/await}\\n        </div>\\n\\n        <div class=\\"transactions\\" bind:this={el} >\\n            <Transactions masterOffset={left} />\\n        </div>\\n    </div>\\n</div>"],"names":[],"mappings":"AA+BI,KAAK,eAAC,CAAC,AACH,OAAO,CAAE,IAAI,CACb,SAAS,CAAE,MAAM,CACjB,QAAQ,CAAE,QAAQ,CAClB,UAAU,CAAE,MAAM,CAClB,OAAO,CAAE,CAAC,AACd,CAAC,AAED,KAAK,eAAC,CAAC,AACH,SAAS,CAAE,CAAC,CACZ,SAAS,CAAE,KAAK,CAChB,MAAM,CAAE,CAAC,CAAC,IAAI,CACd,OAAO,CAAE,IAAI,CAAC,CAAC,AACnB,CAAC,AAED,KAAK,eAAC,CAAC,AACH,OAAO,CAAE,CAAC,CAAC,IAAI,CACf,SAAS,CAAE,KAAK,CAChB,MAAM,CAAE,CAAC,CAAC,IAAI,AAClB,CAAC,AAED,WAAW,eAAC,CAAC,AACT,QAAQ,CAAE,QAAQ,CAClB,OAAO,CAAE,CAAC,CACV,KAAK,CAAE,IAAI,CACX,SAAS,CAAE,KAAK,CAChB,SAAS,CAAE,KAAK,CAChB,UAAU,CAAE,IAAI,CACtB,gBAAgB,CAAE,IAAI,QAAQ,CAAC,CACzB,WAAW,CAAE,IAAI,KAAK,CAAC,CAC7B,UAAU,CAAE,KAAK,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,KAAK,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,KAAK,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,AACjI,CAAC,AAED,MAAM,AAAC,YAAY,KAAK,CAAC,AAAC,CAAC,AACvB,WAAW,eAAC,CAAC,AACT,SAAS,CAAE,IAAI,CACf,SAAS,CAAE,IAAI,CACf,KAAK,CAAE,IAAI,AACf,CAAC,AACD,KAAK,eAAC,CAAC,AACH,SAAS,CAAE,IAAI,AACnB,CAAC,AACL,CAAC,AAED,aAAa,eAAC,CAAC,AACX,OAAO,CAAE,KAAK,CACd,KAAK,CAAE,GAAG,CACV,MAAM,CAAE,IAAI,CAAC,IAAI,AACrB,CAAC,AAED,OAAO,eAAC,CAAC,AACL,UAAU,CAAE,MAAM,AACtB,CAAC,AAED,EAAE,eAAC,CAAC,AACA,UAAU,CAAE,MAAM,AACtB,CAAC,AAGD,aAAa,eAAC,CAAC,AACX,OAAO,CAAE,IAAI,CAAC,CAAC,CACrB,gBAAgB,CAAE,IAAI,QAAQ,CAAC,CACzB,UAAU,CAAE,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC,IAAI,aAAa,CAAC,CACxC,WAAW,CAAE,GAAG,CAAC,KAAK,CAAC,IAAI,KAAK,CAAC,AACrC,CAAC,AAED,MAAM,eAAC,CAAC,AACJ,QAAQ,CAAE,QAAQ,CAClB,KAAK,CAAE,KAAK,CACZ,MAAM,CAAE,KAAK,CACb,MAAM,CAAE,CAAC,CAAC,IAAI,CACd,MAAM,CAAE,OAAO,AACnB,CAAC,AAED,MAAM,eAAC,CAAC,AACJ,QAAQ,CAAE,QAAQ,CAClB,SAAS,CAAE,UAAU,IAAI,CAAC,CAAC,IAAI,CAAC,CAChC,KAAK,CAAE,IAAI,CACX,MAAM,CAAE,IAAI,CACZ,aAAa,CAAE,IAAI,CACnB,MAAM,CAAE,GAAG,CAAC,KAAK,CAAC,IAAI,CACtB,IAAI,CAAE,GAAG,CACT,GAAG,CAAE,GAAG,AACZ,CAAC,AAED,OAAO,eAAC,CAAC,AACL,QAAQ,CAAE,QAAQ,CAClB,SAAS,CAAE,UAAU,IAAI,CAAC,CAAC,IAAI,CAAC,CAChC,KAAK,CAAE,KAAK,CACZ,MAAM,CAAE,IAAI,CACZ,IAAI,CAAE,GAAG,CACT,GAAG,CAAE,GAAG,AACZ,CAAC,AAED,EAAE,eAAC,CAAC,AACA,UAAU,CAAE,MAAM,CAClB,SAAS,CAAE,KAAK,CAChB,MAAM,CAAE,IAAI,AAChB,CAAC,AAED,MAAM,eAAC,CAAC,AACJ,OAAO,CAAE,KAAK,CACd,UAAU,CAAE,MAAM,CAClB,WAAW,CAAE,KAAK,CAClB,OAAO,CAAE,GAAG,CAAC,IAAI,CACjB,gBAAgB,CAAE,IAAI,KAAK,CAAC,CAC5B,MAAM,CAAE,GAAG,CAAC,KAAK,CAAC,IAAI,CACtB,MAAM,CAAE,IAAI,CAAC,IAAI,CAAC,CAAC,CACnB,MAAM,CAAE,OAAO,AACnB,CAAC,AAEI,SAAS,AAAE,CAAC,AACnB,SAAS,CAAE,MAAM,CACjB,KAAK,CAAE,IAAI,CACX,UAAU,CAAE,MAAM,AACnB,CAAC"}`
};
var Routes = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let nflState2 = getNflState();
  let podiumsData = getAwards();
  const getNames = (name, rosterID, currentManagers) => {
    if (cleanName(name) != cleanName(currentManagers[rosterID].name)) {
      return `${name}<div class="curOwner">(${currentManagers[rosterID].name})</div>`;
    }
    return name;
  };
  let el, left;
  const resize = (w) => {
    left = (el == null ? void 0 : el.getBoundingClientRect()) ? el == null ? void 0 : el.getBoundingClientRect().left : 0;
  };
  $$result.css.add(css$b);
  {
    resize();
  }
  return `



<div id="${"home"}" class="${"svelte-1kgzb7c"}"><div id="${"main"}" class="${"svelte-1kgzb7c"}"><div class="${"text svelte-1kgzb7c"}"><h6 class="${"svelte-1kgzb7c"}">${escape(leagueName)}</h6>
            
            <!-- HTML_TAG_START -->${homepageText}<!-- HTML_TAG_END -->
            
            ${``}</div>
        ${validate_component(PowerRankings, "PowerRankings").$$render($$result, {}, {}, {})}</div>
    
    <div class="${"leagueData svelte-1kgzb7c"}"><div class="${"homeBanner"}">${function(__value) {
    if (is_promise(__value)) {
      __value.then(null, noop);
      return `
                <p class="${"center svelte-1kgzb7c"}">Retrieving NFL state...</p>
                ${validate_component(LinearProgress, "LinearProgress").$$render($$result, { indeterminate: true }, {}, {})}
            `;
    }
    return function(nflStateData) {
      return `
                <p class="${"center svelte-1kgzb7c"}">NFL ${escape(nflStateData.season)} 
                    ${nflStateData.season_type == "pre" ? `Preseason` : `${nflStateData.season_type == "post" ? `Postseason` : `${escape(nflStateData.week > 0 ? `Week ${nflStateData.week}` : "Preseason")}`}`}</p>
            `;
    }(__value);
  }(nflState2)}</div>

        <div id="${"currentChamp"}" class="${"svelte-1kgzb7c"}">${function(__value) {
    if (is_promise(__value)) {
      __value.then(null, noop);
      return `
                <p class="${"center svelte-1kgzb7c"}">Retrieving awards...</p>
                ${validate_component(LinearProgress, "LinearProgress").$$render($$result, { indeterminate: true }, {}, {})}
            `;
    }
    return function({ podiums, currentManagers }) {
      return `
                ${podiums[0] ? `<h4 class="${"svelte-1kgzb7c"}">${escape(podiums[0].year)} Champ</h4>
                    <div id="${"champ"}" class="${"svelte-1kgzb7c"}"><img${add_attribute("src", podiums[0].champion.avatar, 0)} class="${"first svelte-1kgzb7c"}" alt="${"champion"}">
                        <img src="${"./laurel.png"}" class="${"laurel svelte-1kgzb7c"}" alt="${"laurel"}"></div>
                    <span class="${"label svelte-1kgzb7c"}"><!-- HTML_TAG_START -->${getNames(podiums[0].champion.name, podiums[0].champion.rosterID, currentManagers)}<!-- HTML_TAG_END --></span>` : `<p class="${"center svelte-1kgzb7c"}">No former champs.</p>`}
            `;
    }(__value);
  }(podiumsData)}</div>

        <div class="${"transactions svelte-1kgzb7c"}"${add_attribute("this", el, 0)}>${validate_component(Transactions$1, "Transactions").$$render($$result, { masterOffset: left }, {}, {})}</div></div></div>`;
});
var index$b = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Routes
});
var css$a = {
  code: ".constitution.svelte-1dfigg0.svelte-1dfigg0{position:relative;z-index:1;width:92%;max-width:800px;margin:8em auto 10em}h1.svelte-1dfigg0.svelte-1dfigg0{font-size:2em;line-height:1.2em;text-align:center;margin:2em 0 1.5em}h2.svelte-1dfigg0.svelte-1dfigg0{font-size:1.5em;line-height:1.2em}h3.svelte-1dfigg0.svelte-1dfigg0{text-decoration:underline;font-size:1.3em;line-height:1.2em}h4.svelte-1dfigg0.svelte-1dfigg0{text-decoration:underline;margin-left:2em;font-size:1.2em;line-height:1.2em}ol.svelte-1dfigg0.svelte-1dfigg0{list-style-type:lower-alpha}ol.svelte-1dfigg0 ol.svelte-1dfigg0{list-style-type:lower-roman}.sectionHeading.svelte-1dfigg0.svelte-1dfigg0{margin:4em 0 1.5em}.subSectionHeading.svelte-1dfigg0.svelte-1dfigg0{margin:1.5em 0 1.5em}.noUnderscore.svelte-1dfigg0.svelte-1dfigg0{text-decoration:none}.clickable.svelte-1dfigg0.svelte-1dfigg0{cursor:pointer}.clickable.svelte-1dfigg0.svelte-1dfigg0:hover{color:#00316b}",
  map: `{"version":3,"file":"index.svelte","sources":["index.svelte"],"sourcesContent":["<script context=\\"module\\">\\n\\texport const prerender = true;\\n<\/script>\\n\\n<script>\\n    import { dues } from '$lib/utils/helper';\\n    let a, a_1, a_2, a_3, a_4;\\n    let b, b_1, b_2, b_3, b_4;\\n    let c, c_1, c_2, c_3, c_4;\\n    let d;\\n    let e, e_1, e_2;\\n    let f, f_1, f_2, f_3, f_4;\\n    let g, g_1, g_2, g_3;\\n    let h, h_1, h_2;\\n\\n    const goToSection = (section) => {\\n        const top = section.getBoundingClientRect().top;\\n        window.scrollTo({left: 0, top, behavior: 'smooth'});\\n    }\\n<\/script>\\n\\n<style>\\n    .constitution {\\n        position: relative;\\n        z-index: 1;\\n        width: 92%;\\n        max-width: 800px;\\n        margin: 8em auto 10em;\\n    }\\n\\n    h1 {\\n        font-size: 2em;\\n        line-height: 1.2em;\\n        text-align: center;\\n        margin: 2em 0 1.5em;\\n    }\\n\\n    h2 {\\n        font-size: 1.5em;\\n        line-height: 1.2em;\\n    }\\n\\n    h3 {\\n        text-decoration: underline;\\n        font-size: 1.3em;\\n        line-height: 1.2em;\\n    }\\n\\n    h4 {\\n        text-decoration: underline;\\n        margin-left: 2em;\\n        font-size: 1.2em;\\n        line-height: 1.2em;\\n    }\\n\\n    ol {\\n        list-style-type: lower-alpha;\\n    }\\n\\n    ol ol {\\n        list-style-type: lower-roman;\\n    }\\n\\n    .subBlock {\\n        margin-left: 2.4em;\\n    }\\n\\n    .sectionHeading {\\n        margin: 4em 0 1.5em;\\n    }\\n\\n    .subSectionHeading {\\n        margin: 1.5em 0 1.5em;\\n    }\\n\\n    .underscore {\\n        text-decoration: underline;\\n    }\\n\\n    .right {\\n        text-align: right;\\n    }\\n\\n    .positionMaximums td {\\n        min-width: 3em;\\n    }\\n\\n    .noUnderscore {\\n        text-decoration: none;\\n    }\\n\\n    .clickable {\\n        cursor: pointer;\\n    }\\n\\n    .clickable:hover {\\n        color: #00316b;\\n    }\\n\\n    p {\\n        color: #777;\\n    }\\n</style>\\n\\n<div class=\\"constitution\\">\\n    <h1 class=\\"noUnderscore\\">TOMCAT DYNASTY LEAGUE CONSTITUTION</h1>\\n    <h1 class=\\"noUnderscore\\">RULE #1: Be nice to Scott.</h1>\\n    \\n    <h2 class=\\"noUnderscore\\">TABLE OF CONTENTS</h2>\\n    \\n    <h3 class=\\"noUnderscore clickable\\" on:click={() => goToSection(a)}>Section A: League Introduction & Integrity</h3>\\n        <h4 class=\\"noUnderscore clickable\\" on:click={() => goToSection(a_1)}>A.1 Intro & League Service</h4>\\n        <h4 class=\\"noUnderscore clickable\\" on:click={() => goToSection(a_2)}>A.2 League Integrity</h4>\\n        <h4 class=\\"noUnderscore clickable\\" on:click={() => goToSection(a_3)}>A.3 Comissioner Responsibilities</h4>\\n\\t\\n    <h3 class=\\"noUnderscore clickable\\" on:click={() => goToSection(b)}>Section B: Roster, Draft & Important Dates</h3>\\n        <h4 class=\\"noUnderscore clickable\\" on:click={() => goToSection(b_1)}>B.1 Roster</h4>\\n        <h4 class=\\"noUnderscore clickable\\" on:click={() => goToSection(b_2)}>B.2 Inaugural Draft</h4>\\n        <h4 class=\\"noUnderscore clickable\\" on:click={() => goToSection(b_3)}>B.3 Annual Rookie Draft</h4>\\n\\t    <h4 class=\\"noUnderscore clickable\\" on:click={() => goToSection(b_4)}>B.4 Important Dates</h4>\\n\\t\\n    <h3 class=\\"noUnderscore clickable\\" on:click={() => goToSection(c)}>Section C: Divisions, Schedule & Playoff Brackets</h3>\\n        <h4 class=\\"noUnderscore clickable\\" on:click={() => goToSection(c_1)}>C.1 Divisions</h4>\\n        <h4 class=\\"noUnderscore clickable\\" on:click={() => goToSection(c_2)}>C.2 Regular Season Schedule</h4>\\n        <h4 class=\\"noUnderscore clickable\\" on:click={() => goToSection(c_3)}>C.3 Loser's Bracket</h4>\\n\\t<h4 class=\\"noUnderscore clickable\\" on:click={() => goToSection(c_4)}>C.4 Winner's Bracket</h4>\\n\\t\\n    <h3 class=\\"noUnderscore clickable\\" on:click={() => goToSection(d)}>Section D: Buy-In & Pay Outs</h3>\\n\\t\\n    <h3 class=\\"noUnderscore clickable\\" on:click={() => goToSection(e)}>Section E: Waivers & Free Agency</h3>\\n        <h4 class=\\"noUnderscore clickable\\" on:click={() => goToSection(e_1)}>E.1 In Season Waivers</h4>\\n        <h4 class=\\"noUnderscore clickable\\" on:click={() => goToSection(e_2)}>E.2 Off-Season Free Agency</h4>\\n\\t\\n    <h3 class=\\"noUnderscore clickable\\" on:click={() => goToSection(f)}>Section F: Trading</h3>\\n        <h4 class=\\"noUnderscore clickable\\" on:click={() => goToSection(f_1)}>F.1 General Rules</h4>\\n        <h4 class=\\"noUnderscore clickable\\" on:click={() => goToSection(f_2)}>F.2 Conditional Trades</h4>\\n        <h4 class=\\"noUnderscore clickable\\" on:click={() => goToSection(f_3)}>F.3 Trade Vetoing</h4>\\n\\t   <h4 class=\\"noUnderscore clickable\\" on:click={() => goToSection(f_4)}>F.4 Trading Draft Picks</h4>\\n\\t\\n    <h3 class=\\"noUnderscore clickable\\" on:click={() => goToSection(g)}>Section G: Tie Breakers</h3>\\n        <h4 class=\\"noUnderscore clickable\\" on:click={() => goToSection(g_1)}>G.1 General Tiebreakers</h4>\\n        <h4 class=\\"noUnderscore clickable\\" on:click={() => goToSection(g_2)}>G.2 Waiver Bid Tie Breakers</h4>\\n        <h4 class=\\"noUnderscore clickable\\" on:click={() => goToSection(g_3)}>G.3 Playoff Tiebreakers</h4>\\n\\t\\n    <h3 class=\\"noUnderscore clickable\\" on:click={() => goToSection(h)}>Section H: Lineups & Scoring</h3>\\n        <h4 class=\\"noUnderscore clickable\\" on:click={() => goToSection(h_1)}>H.1 Lineups</h4>\\n        <h4 class=\\"noUnderscore clickable\\" on:click={() => goToSection(h_2)}>H.2 Scoring Settings</h4>\\n    \\n    <hr />\\n    \\n    <h2 class=\\"sectionHeading\\" bind:this={a}>Section A: League Introduction & Integrity/h2>\\n    \\n    <h3 class=\\"subSectionHeading\\" bind:this={a_1}>A.1 Intro & League Service</h3>\\n\\n    <ol>\\n        <li>\\n            This is a DYNASTY Fantasy Football league. It requires commitment over multiple seasons. You\u2019re in it for the long haul. Players remain on the same Franchise from one season to the next unless they are traded or released.\\n        </li>\\n        <li>\\n            Be active. Be involved. Set lineups. Propose trades. Respond to trades promptly. Send messages in group chat. It makes the experience better for everyone and increases league longevity.\\n        </li>\\n        <li>\\n            Roster & Scoring settings are fairly different from default settings. Make sure to read up on those sections below to be prepared.\\n        </li>\\n        <li>\\n            The league will be hosted on Sleeper. It is the best, free dynasty focused app for fantasy football on the market currently. Depending on the draft format, myfantasyleague may be used for the draft and exported.\\n        </li>\\n    </ol>\\n\\n\\n    <h3 class=\\"subSectionHeading\\" bind:this={a_2}>A.2 League Integrity</h3>\\n    \\n   <ol>\\n        <li>\\n            It is in the best interest of the league that all teams compete for all weeks of the year, when a team does not submit a competitive line up (resets each year):\\n            <ol>\\n                <li>\\n                    First Offense: Warning\\n                </li>\\n                <li>\\n                    Second Offense: Loss of 25% of total FAAB budget for the following season\\n                </li>\\n                <li>\\n                    Third Offense: Loss of 3rd round rookie pick (theirs, or other\u2019s they own) or the latest draft pick they own, otherwise.\\n                </li>\\n                <li>\\n                    4th Offense: Removal from league\\n                </li>\\n            </ol>\\n        </li>\\n        <li>\\n            Noncompetitive means when an owner submits a lineup that includes:\\n            <ol>\\n                <li>\\n                    Any player that is a Free Agent\\n                </li>\\n                <li>\\n                    Any player that is Suspended\\n                </li>\\n                <li>\\n                    Any player that is on Injured Reserve \\n                </li>\\n                <li>\\n                    A lineup with less than required starters\\n                </li>\\n                <li>\\n                    Any player that is OUT for multiple weeks. \\n                    <ul><li>\\n                        If a player gets downgraded to out on the same day of the game, that is allowed. If it becomes a trend then it may be looked at as an issue.\\n                    </li></ul>\\n                </li>\\n                <li>\\n                    The intent to lose a matchup on purpose (automatically elevates to 2nd offense)\\n                </li>\\n            </ol>\\n        </li>\\n        <li>\\n            It would be nice to see all owners return year to year; however we know that things happen so if an owner should choose not to return, the commissioner will find a replacement GM using whatever means necessary to keep the league stable.\\n        </li>\\n        <li>\\n            If a team is abandoned mid-season, the commissioner will assume control of setting lineups for the team until a new GM can be found. While under control of the commissioner, this team will be barred from making trades, and any monetary winnings it may make will be put towards the dynasty pool. GM\u2019s taking over an orphaned team mid season are not expected to pay an additional buy in.\\n        </li>\\n        <li>\\n            When ownership of a franchise changes, the new owner will keep the same players held by the previous owner. The new GM will also keep the drafting position held by the previous owner.\\n        </li>\\n        <li>\\n            Some things that will not be tolerated at all are collusion, cheating and hacking. \\n        </li>\\n        <li>\\n            All of these rules are set and any changes will require a vote for the next season only. Any GM can propose rules changes in the off-season. A \u2154 majority vote is required to make a rule change.\\n        </li>\\n        <li>\\n            Scoring is not subject to change, as it would cause changes of player values that owners would not have been expecting.\\n        </li>\\n    </ol>\\n    \\n\\n    <h3 class=\\"subSectionHeading\\" bind:this={a_3}>A.3 Comissioner Responsibilities</h3>\\n\\n    <ol>\\n        <li>\\n            Because of the inability to account for all possible scenarios, the commissioner will assume a governing position for the league.\\n        </li>\\n        <li>\\n            The commissioner is responsible for interpreting league rules, settling league disputes, and handling day-to-day operations.\\n        </li>\\n        <li>\\n            The commissioner reserves the right to protect the integrity of the league, especially in cases of clear collusion, cheating, or intentional sabotage of the league.\\n        </li>\\n        <li>\\n            If any situation arises that is not covered by these rules, the commissioner will use their discretion to determine the best course of action, and enforce whatever action is necessary to maintain fair, fun, and honest play.\\n        </li>\\n        <li>\\n            The commissioner will act in the best interest of the league at all times.\\n        </li>\\n    </ol>\\n\\n    <h3 class=\\"subSectionHeading\\" bind:this={a_4}>A.4 General Manager Responsibilities</h3>\\n\\n    <ol>\\n        <li>\\n            Each GM shall behave in a responsible manner that would not harm other owners or the league.\\n        </li>\\n        <li>\\n            It is the responsibility of each GM to refrain from participating in collusion or anti-competitive behavior.\\n        </li>\\n        <li>\\n            Each GM must keep their contact information updated with the commissioner and the rest of the league\\n        </li>\\n        <li>\\n            Each GM may only control one team in the league.\\n        </li>\\n        <li>\\n            Penalty for violating any GM responsibilities not outlined elsewhere in the ruleset\\n            <ol>\\n                <li>\\n                    1st offense: Warning\\n                </li>\\n                <li>\\n                    2nd offense or particularly severe incident: Loss of earliest owned rookie pick and forfeit the right to any prize winnings for the season.\\n                </li>\\n                <li>\\n                    3rd offense or extremely severe incident: Removed from league and forfeit the right to the team and any prize winnings\\n                </li>\\n            </ol>\\n        </li>\\n    </ol>\\n\\n\\n    <h2 class=\\"sectionHeading\\" bind:this={b}>Section B: Roster, Draft & Important Dates</h2>\\n    \\n    <h3 bind:this={b_1}>B.1 Roster</h3>\\n\\n    <ol>\\n        <li>\\n            30 Player In-Season Roster [Starters + Bench]\\n        </li>\\n        <li>\\n            No Taxi Squad, No IR\\n        </li>\\n        <li>\\n            10 Starters  [1 QB | 2 RB | 3 WR | 3 FLEX| 1 SUPERFLEX]\\n        </li>\\n        <li>\\n            35 Player Off-Season Roster\\n            <ol>\\n                <li>\\n                    Roster Size Increased after Week 16\\n                </li>\\n                <li>\\n                    Roster Size cut down back to 30 the Monday after Final Preseason Weekend l\\n                </li>\\n            </ol>\\n        </li>\\n        <li>\\n            No positional roster requirements/maximums\\n        </li>\\n    </ol>\\n\\n    <h3 bind:this={b_2}>B.2 Inaugural Draft</h3>\\n    <ol>\\n        <li>\\n            The Inaugural Draft consists of 30 rounds, and includes both NFL veterans AND rookies that have been drafted or signed to rookie free agent contracts by NFL teams.\\n        </li>\\n        <li>\\n            The Inaugural draft must be scheduled to take place after the NFL rookie draft.\\n        </li>\\n        <li>\\n            3rd Round Reversal is in effect.\\n        </li>\\n        <li>\\n            Trading of later inaugural draft picks as well as future rookie draft picks is allowed.\\n        </li>\\n        <li>\\n            Draft order determined by 2k16 sim\\n        </li>\\n        <li>\\n            5 minute soft-cap timer per draft pick. Draft picks should be prompt but not stressful\\n        </li>\\n    </ol>\\n    \\n    <h3 bind:this={b_3}>B.3 Annual Rookie Draft</h3>\\n    <ol>\\n        <li>\\n            4 rounds\\n        </li>\\n        <li>\\n            Straight Format (i.e. 1-2-3, 1-2-3)\\n        </li>\\n        <li>\\n            Rookies and Free Agents are both available to be drafted.\\n        </li>\\n        <li>\\n            Rookie draft picks will be granted to all teams for the current and future seasons.\\n        </li>\\n        <li>\\n            Draft order is as follows\\n            <ul>\\n                <li>\\n                Picks 1-6 are from lowest to highest max PF\\n                </li>\\n                <li>\\n                Picks 7-8 are from lowest to highest max PF for the 2 playoff teams that did not advance past the first round.\\n                </li>\\n                <li>\\n                Picks 9-12 are based on playoff finish, with the champion getting the last pick.\\n                </li>\\n            </ul>\\n        </li>\\n        <li>\\n            The draft order for picks 1-6 is determined by the \u201CPotential Points\u201D ranking (the highest possible points you could have gotten), which is to prevent tanking.\\n        </li>\\n        <li>\\n            The draft order for picks 1-6 is determined by the \u201CPotential Points\u201D ranking (the highest possible points you could have gotten), which is to prevent tanking.\\n        </li>\\n        <li>\\n            The rookie draft will be a long-running online draft, using the league software, starting on 1st Sunday of June at 12:00 PM EST. Owners are expected to plan around being available on this date and in the subsequent days / weeks to ensure an expeditious draft.\\n        </li>\\n        <li>\\n            GMs are allowed a 24 hour selection time limit. This time limit is for \\"just in case\\" scenarios and should not be abused. No one should continually hold up the draft or use the full allotted amount of time in a given round if they can help it.\\n        </li>\\n        <li>\\n            Teams that exceed their 24-hour selection time limit will have their pick skipped\\n        </li>\\n        <li>\\n            In such a scenario, it is the responsibility of the team GM to then contact the commissioners with the player they wish to select and said selection will be approved and processed if the player is still available\\n        </li>\\n        <li>\\n            If a GM misses two picks in a row, the draft will be stopped and the commissioner will try to contact the GM to discuss the situation.\\n        </li>\\n    </ol>\\n\\n    <h3 bind:this={b_4}>B.4 Important Dates</h3>\\n\\n    <ol>\\n        <li>\\n            Tuesday after Week 17  \u2013 Rule Changes Discussion Begins\\n        </li>\\n        <li>\\n            Tuesday after Week 17  \u2013 Free Agents are locked, Roster expanded to 35 players\\n        </li>\\n        <li>\\n            1st Sunday of June \u2013 Rookie Draft begins Annually, Dues must be paid\\n        </li>\\n        <li>\\n            After completion of Rookie Draft, auctions turned on\\n        </li>\\n        <li>\\n            Monday after Final Preseason Weekend \u2013 Roster cut to 30 players\\n        </li>\\n        <li>\\n            NFL Week 17 \u2013 Championship\\n        </li>\\n        <li>\\n            End of Week 17 \u2013 Rookie Draft order determined\\n        </li>\\n        <li>\\n            After NFL week 18 \u2013 Payouts are paid\\n        </li>\\n        <li>\\n            Weekly Event \u2013 Wednesday \u2013 3:15AM ET \u2013 Waivers Run\\n        </li>\\n    </ol>\\n    \\n    <h2 class=\\"sectionHeading\\" bind:this={c}>Section C: Divisions, Schedule & Playoff Brackets</h2>\\n\\n    <h3 bind:this={c_1}>C.1 Divisions</h3>\\n        <ol>\\n        <li>\\n            3 divisions of 4 teams.\\n        </li>\\n        <li>\\n            Divisions are randomized each season with 1 team from each quartile from the previous season\u2019s finishes.\\n        </li>\\n    </ol>\\n\\n    <h3 bind:this={c_2}>C.2 Regular Season Schedule</h3>\\n    <ol>\\n        <li>\\n            14 Weekly Match ups\\n        </li>\\n        <li>\\n            Each team will play the other 2 teams in their division twice and all other teams once.\\n        </li>\\n    </ol>\\n\\n    <h3 bind:this={c_3}>C.3 Loser's Bracket</h3>\\n    <ol>\\n        <li>\\n            3 Round Playoff\\n        </li>\\n        <li>\\n            Remaining 6 teams qualify\\n        </li>\\n        <li>\\n            Single Elimination\\n        </li>\\n        <li>\\n            Draft order is already determined at this point\\n        </li>\\n        <li>\\n            Schedule (Seeding is based off pick placement)\\n            <ol>\\n                <li>\\n                    Week 15: 6th & 5th pick Receive BYE\\n                </li>\\n                <li>\\n                    Week 15: 2nd vs 3rd | 1st vs 4th \\n                </li>\\n                <li>\\n                    Week 16: 1st vs. lowest remaining | 2nd vs. highest remaining\\n                </li>\\n                <li>\\n                    Week 17; ROOKIE BOWL: Winner Receives 2nd Round rookie pick (2.13)\\n                </li>\\n            </ol>\\n        </li>\\n    </ol>\\n\\n    <h3 bind:this={c_4}>C.4 Winner's Bracket</h3>\\n    <ol>\\n        <li>\\n            3 Round Playoff\\n        </li>\\n        <li>\\n            6 teams advance\\n        </li>\\n        <li>\\n            Single Elimination\\n        </li>\\n        <li>\\n            Seeding\\n            <ol>\\n                <li>\\n                    First 3 seeds are division winners.\\n                </li>\\n                <li>\\n                    4th and 5th seed determined by record first with applicable tiebreakers listed below.\\n                </li>\\n                <li>\\n                    6th seed determined by points for, with applicable tiebreakers listed below.\\n                </li>\\n            </ol>\\n        </li>\\n        <li>\\n            Schedule\\n            <ol>\\n                <li>\\n                    Week 15: 1st  & 2nd seed Receive BYE\\n                </li>\\n                <li>\\n                    Week 15: 5th vs 4th | 6th vs 3rd\\n                </li>\\n                <li>\\n                    Week 16: 1st vs. lowest remaining | 2nd vs. highest remaining\\n                </li>\\n                <li>\\n                    Week 17; CHAMPIONSHIP | 3rd place Matchup\\n                </li>\\n            </ol>\\n        </li>\\n    </ol>\\n    \\n    <h2 class=\\"sectionHeading\\" bind:this={d}>Section D: Buy-In & Pay Outs</h2>\\n    <ol>\\n        <li>\\n            Money is due 1 week prior to rookie draft at the latest.\\n        </li>\\n        <li>\\n            Offseason trades can\u2019t be made until dues are paid.\\n        </li>\\n        <li>\\n            Future assets cannot be traded until 50% of that year\u2019s buy in has been paid\\n        </li>\\n        <li>\\n            Commissioner will give a 24 hour warning for when payment will need to be made.\\n        </li>\\n        <li>\\n            Offending owners will lose their least valuable remaining pick if they still haven\u2019t paid after the warning.\\n        </li>\\n        <li>\\n            $20 each week goes to Highest Weekly Score (excluding Championship week 16) = $300\\n        </li>\\n        <li>\\n            $500 goes to the First Place Champion\\n        </li>\\n        <li>\\n            $200 goes to 2nd Place\\n        </li>\\n        <li>\\n            $100 goes to 3rd Place\\n        </li>\\n\\n        <li>\\n            $100 goes in DYNASTY pool.\\n            <ol>\\n                <li>\\n                    The DYNASTY pool is collected annually\\n                </li>\\n                <li>\\n                    Will be awarded to the Franchise that wins \u2018back-to-back\u2019 Championships. \\n                </li>\\n                <li>\\n                    If the league is disbanded and there is money in the dynasty pool, it will be divided evenly amongst the GM\u2019s\\n                </li>\\n            </ol>\\n        </li>\\n    </ol>\\n\\n    <h2 class=\\"sectionHeading\\" bind:this={e}>Section E: Waivers & Free Agency</h2>\\n    \\n    <h3 bind:this={e_1}>E.1 In-Season Waivers</h3>\\n    <ol>\\n        <li>\\n            Each team has a FAAB budget of $100\\n        </li>\\n        <li>\\n            Free agents will be processed by Sleeper\u2019s automated waiver window system. Waivers will be processed on Wednesday morning (3:15am ET), during the regular season starting at the completion of week one.\\n        </li>\\n        <li>\\n            Players not claimed by waivers will be available to be picked up for free until the start of their next game, or the first kickoff on Sunday if on Bye.\\n        </li>\\n        <li>\\n            There is no minimum bid and bids are done in increments of $1 (i.e. - no decimals).\\n        </li>\\n        <li>\\n            Once a player is dropped, he is locked until the next time waivers are processed.\\n        </li>\\n        <li>\\n            Waivers are available from the start of Week 1 until Wednesday on Week 16.\\n        </li>\\n    </ol>\\n\\n    <h3 bind:this={e_2}>E.2 Off-Season Free Agency</h3>\\n    <ol>\\n        <li>\\n            Free Agency is locked from the conclusion of Week 16 until the Rookie draft.\\n        </li>\\n        <li>\\n            This is meant as a way to allow owners to unplug from Fantasy/NFL during the offseason for a time without a loss of competitive advantage.\\n        </li>\\n    </ol>\\n\\n    <h2 class=\\"sectionHeading\\" bind:this={f}>Section F: Trading</h2>\\n    \\n    <h3 bind:this={f_1}>F.1 General Rules</h3>\\n    <ol>\\n        <li>\\n            Trades are processed immediately when accepted\\n        </li>\\n        <li>\\n            There is no trade deadline, including into the playoffs.\\n        </li>\\n        <li>\\n            Trade proposals are valid for up to 7 days. Take your time.\\n        </li>\\n        <li>\\n            FAAB budget may be obtained via trade.\\n        </li>\\n        <li>\\n            No trades may be made that include real cash, future considerations, a player to be named later, or anything outside the realm of the fantasy league.\\n        </li>\\n        <li>\\n            From kickoff of Week 1 through the league championship, a traded player cannot be traded between the same two teams for at least four (4) weeks.\\n            <ul><li>\\n                If an owner observes a trade they suspect to be in violation of this rule, please report it to the commissioner.\\n            </li></ul>\\n        </li>\\n    </ol>\\n    \\n    <h3 bind:this={f_2}>F.2 Conditional Trades</h3>\\n    <ol>\\n        <li>\\n            Commissioner must be made aware, with explicit approval from both parties on the conditional nature of the trade prior to it being executed.\\n        </li>\\n        <li>\\n            Commissioner may veto conditional nature of trades if deemed ambiguous.\\n        </li>\\n        <li>\\n            Assets included in conditional trades are locked up and may not be included in other trades.\\n        </li>\\n        <li>\\n            Examples\\n            <ul>\\n                <li>\\n                    Top 3 protected 2021 1st Rounder, Unprotected in 2022\\n                </li>\\n                <li>\\n                    2nd round 2021 pick if player starts X games. 3rd round 2021 pick otherwise.\\n                </li>\\n            </ul>\\n        </li>\\n    </ol>\\n\\n    <h3 bind:this={f_3}>F.3 Trade Vetoing</h3>\\n    <ol>\\n        <li>\\n            This league supports the spirit of \u201CTrades will not be vetoed, except in clear cases of collusion.\u201D However, for the integrity and longevity of the league, there must be a mechanism to handle \u2018league breaking\u2019 trades.\\n        <li>\\n            Commissioner reserves the right to deem a trade \u201Cleague breaking\u201D and reverse said trade.\\n        </li>\\n        <li>\\n            The term \u201Cleague breaking\u201D is an extremely high bar, and is not to be taken lightly.\\n        </li>\\n        <li>\\n            This mechanism isn\u2019t meant to handle trades where people have different player values and it isn\u2019t intended to impose the commissioner\u2019s player values on other people.\\n        </li>\\n    </ol>\\n\\n    <h3 bind:this={f_4}>F.4 Trading Draft Picks</h3>\\n    <ol>\\n        <li>\\n            You are allowed to trade up to 1-3 years in advance draft picks\\n        <li>\\n            If a player decides to trade a future draft pick, 50% of that season\u2019s dues must be paid before doing so\\n        </li>\\n    </ol>\\n\\n    <h2 class=\\"sectionHeading\\" bind:this={g}>Section G: Tie Breakers</h2>\\n    \\n    <h3 bind:this={g_1}>G.1 General Tiebreakers</h3>\\n     <ol>\\n        <li>\\n            Head-to-Head Winning %\\n        <li>\\n            Division Winning %\\n        </li>\\n        <li>\\n            Total Points Scored\\n        </li>\\n        <li>\\n            Total Points Against\\n        </li>\\n        <li>\\n            Rap Battle\\n        </li>\\n    </ol>\\n    \\n    <h3 bind:this={g_2}>G.2 Waiver Bid Tie Breakers</h3>\\n    <ol>\\n        <li>\\n            Sleeper implements a rolling waiver priority for tiebreakers. You are moved to the bottom of the priority queue after every successful waiver claim.\\n        </li>\\n    </ol>\\n\\n  \\n    <h3 bind:this={g_3}>G.3 Playoff Tiebreakers</h3>\\n   <ol>\\n        <li>\\n            QB Scoring\\n        </li>\\n        <li>\\n            Top RB + Top WR Combo Scoring\\n        </li>\\n        <li>\\n            Rap Battle\\n        </li>\\n    </ol>\\n\\n     <h2 class=\\"sectionHeading\\" bind:this={h}>Section H: Lineups & Scoring</h2>\\n    \\n    <h3 bind:this={h_1}>H.1 Lineups</h3>\\n    <ol>\\n        <li>\\n            10 Starters  [1 QB | 2 RB | 3 WR | 3 FLEX| 1 SUPERFLEX]\\n        </li>\\n        <li>\\n            Conditional Lineup Requests\\n            <ol>\\n                <li>\\n                    Owners may submit to the commissioner conditional lineup requests based on player availability and scheduling that makes fully informed decision making impossible.\\n                </li>\\n                <li>\\n                    Owner\u2019s must specify their request prior to the start of either potential players\u2019 games, and with enough time for the commissioner to approve it before said games begin.\\n                </li>\\n                <li>\\n                    The conditional nature is based solely on the availability of the given player or the occurrence of a game. The conditional nature cannot be based on the availability of any other player, and a player need only be available to be played - starting nor even playing a snap is required.\\n                </li>\\n                <li>\\n                    Conditional lineup requests may be made in batch form i.e. setting multiple replacements, or replacements for any player of a position type. Examples include.\\n                    <ul>\\n                        <li>\\n                            Start: Alvin Kamara\\\\n\\n                            Conditional: Latavius Murray\\n                        </li>\\n                        <li>\\n                            Start: Chris Carson, Austin Ekeler\\\\n\\n                            Conditional: Ronald Jones\\n                        </li>\\n                        <li>\\n                            Start: Julio Jones, Mike Evans, Keenan Allen\\\\n\\n                            Conditional: Brandin Cooks, Marvin Jones Jr\\n                        </li>\\n                    </ul>\\n                </li>\\n            </ol>\\n        </li>\\n        <li>\\n            Trade proposals are valid for up to 7 days. Take your time.\\n        </li>\\n        <li>\\n            FAAB budget may be obtained via trade.\\n        </li>\\n        <li>\\n            No trades may be made that include real cash, future considerations, a player to be named later, or anything outside the realm of the fantasy league.\\n        </li>\\n        <li>\\n            From kickoff of Week 1 through the league championship, a traded player cannot be traded between the same two teams for at least four (4) weeks.\\n            <ul><li>\\n                If an owner observes a trade they suspect to be in violation of this rule, please report it to the commissioner.\\n            </li></ul>\\n        </li>\\n    </ol>\\n    \\n    <h3 bind:this={h_2}>H.1 Scoring Settings</h3>\\n    <ol>\\n        <li>\\n            Number of Passing TDs [6 points each]\\n        <li>\\n            Passing Yards [.04 point for every 1]\\n        </li>\\n        <li>\\n            Completion [.2 points for each]\\n        </li>\\n        <li>\\n            Incompletions [-.4 for each]\\n        </li>\\n        <li>\\n            Interceptions Thrown [-4 for each]\\n        </li>\\n        <li>\\n            Passing 2 Pointers [2 points each]\\n        </li>\\n        <li>\\n            Number of Rushing TDs [6 points each]\\n        </li>\\n        <li>\\n            Rushing Yards [.1 point for every 1]\\n        </li>\\n        <li>\\n            Rushing 2 Pointers [2 points each]\\n        </li>\\n        <li>\\n            Number of Receiving TDs [6 points each]\\n        </li>\\n        <li>\\n            Receiving Yards [.1 point for every 1]\\n        </li>\\n        <li>\\n            First downs [1 point]\\n        </li>\\n        <li>\\n            Receptions [1 point, 2 points for TE]\\n        </li>\\n        <li>\\n            Receiving 2 Pointers [2 points each]\\n        </li>\\n        <li>\\n            Punt Return for Touchdown [6 points each]\\n        </li>\\n        <li>\\n            Kickoff Return for Touchdown [6 points each]\\n        </li>\\n        <li>\\n            Fumbles [-1 point]\\n        </li>\\n        <li>\\n            Fumbles lost [-1 point, total of -2]\\n        </li>\\n    </ol>\\n\\n</div>\\n"],"names":[],"mappings":"AAsBI,aAAa,8BAAC,CAAC,AACX,QAAQ,CAAE,QAAQ,CAClB,OAAO,CAAE,CAAC,CACV,KAAK,CAAE,GAAG,CACV,SAAS,CAAE,KAAK,CAChB,MAAM,CAAE,GAAG,CAAC,IAAI,CAAC,IAAI,AACzB,CAAC,AAED,EAAE,8BAAC,CAAC,AACA,SAAS,CAAE,GAAG,CACd,WAAW,CAAE,KAAK,CAClB,UAAU,CAAE,MAAM,CAClB,MAAM,CAAE,GAAG,CAAC,CAAC,CAAC,KAAK,AACvB,CAAC,AAED,EAAE,8BAAC,CAAC,AACA,SAAS,CAAE,KAAK,CAChB,WAAW,CAAE,KAAK,AACtB,CAAC,AAED,EAAE,8BAAC,CAAC,AACA,eAAe,CAAE,SAAS,CAC1B,SAAS,CAAE,KAAK,CAChB,WAAW,CAAE,KAAK,AACtB,CAAC,AAED,EAAE,8BAAC,CAAC,AACA,eAAe,CAAE,SAAS,CAC1B,WAAW,CAAE,GAAG,CAChB,SAAS,CAAE,KAAK,CAChB,WAAW,CAAE,KAAK,AACtB,CAAC,AAED,EAAE,8BAAC,CAAC,AACA,eAAe,CAAE,WAAW,AAChC,CAAC,AAED,iBAAE,CAAC,EAAE,eAAC,CAAC,AACH,eAAe,CAAE,WAAW,AAChC,CAAC,AAMD,eAAe,8BAAC,CAAC,AACb,MAAM,CAAE,GAAG,CAAC,CAAC,CAAC,KAAK,AACvB,CAAC,AAED,kBAAkB,8BAAC,CAAC,AAChB,MAAM,CAAE,KAAK,CAAC,CAAC,CAAC,KAAK,AACzB,CAAC,AAcD,aAAa,8BAAC,CAAC,AACX,eAAe,CAAE,IAAI,AACzB,CAAC,AAED,UAAU,8BAAC,CAAC,AACR,MAAM,CAAE,OAAO,AACnB,CAAC,AAED,wCAAU,MAAM,AAAC,CAAC,AACd,KAAK,CAAE,OAAO,AAClB,CAAC"}`
};
var prerender = true;
var Constitution = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let a, a_1, a_2, a_3, a_4;
  let b, b_1, b_2, b_3, b_4;
  let c, c_1, c_2, c_3, c_4;
  let d2;
  let e, e_1, e_2;
  let f, f_1, f_2, f_3, f_4;
  let g, g_1, g_2, g_3;
  let h, h_1, h_2;
  $$result.css.add(css$a);
  return `<div class="${"constitution svelte-1dfigg0"}"><h1 class="${"noUnderscore svelte-1dfigg0"}">TOMCAT DYNASTY LEAGUE CONSTITUTION</h1>
    <h1 class="${"noUnderscore svelte-1dfigg0"}">RULE #1: Be nice to Scott.</h1>
    
    <h2 class="${"noUnderscore svelte-1dfigg0"}">TABLE OF CONTENTS</h2>
    
    <h3 class="${"noUnderscore clickable svelte-1dfigg0"}">Section A: League Introduction &amp; Integrity</h3>
        <h4 class="${"noUnderscore clickable svelte-1dfigg0"}">A.1 Intro &amp; League Service</h4>
        <h4 class="${"noUnderscore clickable svelte-1dfigg0"}">A.2 League Integrity</h4>
        <h4 class="${"noUnderscore clickable svelte-1dfigg0"}">A.3 Comissioner Responsibilities</h4>
	
    <h3 class="${"noUnderscore clickable svelte-1dfigg0"}">Section B: Roster, Draft &amp; Important Dates</h3>
        <h4 class="${"noUnderscore clickable svelte-1dfigg0"}">B.1 Roster</h4>
        <h4 class="${"noUnderscore clickable svelte-1dfigg0"}">B.2 Inaugural Draft</h4>
        <h4 class="${"noUnderscore clickable svelte-1dfigg0"}">B.3 Annual Rookie Draft</h4>
	    <h4 class="${"noUnderscore clickable svelte-1dfigg0"}">B.4 Important Dates</h4>
	
    <h3 class="${"noUnderscore clickable svelte-1dfigg0"}">Section C: Divisions, Schedule &amp; Playoff Brackets</h3>
        <h4 class="${"noUnderscore clickable svelte-1dfigg0"}">C.1 Divisions</h4>
        <h4 class="${"noUnderscore clickable svelte-1dfigg0"}">C.2 Regular Season Schedule</h4>
        <h4 class="${"noUnderscore clickable svelte-1dfigg0"}">C.3 Loser&#39;s Bracket</h4>
	<h4 class="${"noUnderscore clickable svelte-1dfigg0"}">C.4 Winner&#39;s Bracket</h4>
	
    <h3 class="${"noUnderscore clickable svelte-1dfigg0"}">Section D: Buy-In &amp; Pay Outs</h3>
	
    <h3 class="${"noUnderscore clickable svelte-1dfigg0"}">Section E: Waivers &amp; Free Agency</h3>
        <h4 class="${"noUnderscore clickable svelte-1dfigg0"}">E.1 In Season Waivers</h4>
        <h4 class="${"noUnderscore clickable svelte-1dfigg0"}">E.2 Off-Season Free Agency</h4>
	
    <h3 class="${"noUnderscore clickable svelte-1dfigg0"}">Section F: Trading</h3>
        <h4 class="${"noUnderscore clickable svelte-1dfigg0"}">F.1 General Rules</h4>
        <h4 class="${"noUnderscore clickable svelte-1dfigg0"}">F.2 Conditional Trades</h4>
        <h4 class="${"noUnderscore clickable svelte-1dfigg0"}">F.3 Trade Vetoing</h4>
	   <h4 class="${"noUnderscore clickable svelte-1dfigg0"}">F.4 Trading Draft Picks</h4>
	
    <h3 class="${"noUnderscore clickable svelte-1dfigg0"}">Section G: Tie Breakers</h3>
        <h4 class="${"noUnderscore clickable svelte-1dfigg0"}">G.1 General Tiebreakers</h4>
        <h4 class="${"noUnderscore clickable svelte-1dfigg0"}">G.2 Waiver Bid Tie Breakers</h4>
        <h4 class="${"noUnderscore clickable svelte-1dfigg0"}">G.3 Playoff Tiebreakers</h4>
	
    <h3 class="${"noUnderscore clickable svelte-1dfigg0"}">Section H: Lineups &amp; Scoring</h3>
        <h4 class="${"noUnderscore clickable svelte-1dfigg0"}">H.1 Lineups</h4>
        <h4 class="${"noUnderscore clickable svelte-1dfigg0"}">H.2 Scoring Settings</h4>
    
    <hr>
    
    <h2 class="${"sectionHeading svelte-1dfigg0"}"${add_attribute("this", a, 0)}>Section A: League Introduction &amp; Integrity/h2&gt;
    
    <h3 class="${"subSectionHeading svelte-1dfigg0"}"${add_attribute("this", a_1, 0)}>A.1 Intro &amp; League Service</h3>

    <ol class="${"svelte-1dfigg0"}"><li>This is a DYNASTY Fantasy Football league. It requires commitment over multiple seasons. You\u2019re in it for the long haul. Players remain on the same Franchise from one season to the next unless they are traded or released.
        </li>
        <li>Be active. Be involved. Set lineups. Propose trades. Respond to trades promptly. Send messages in group chat. It makes the experience better for everyone and increases league longevity.
        </li>
        <li>Roster &amp; Scoring settings are fairly different from default settings. Make sure to read up on those sections below to be prepared.
        </li>
        <li>The league will be hosted on Sleeper. It is the best, free dynasty focused app for fantasy football on the market currently. Depending on the draft format, myfantasyleague may be used for the draft and exported.
        </li></ol>


    <h3 class="${"subSectionHeading svelte-1dfigg0"}"${add_attribute("this", a_2, 0)}>A.2 League Integrity</h3>
    
   <ol class="${"svelte-1dfigg0"}"><li>It is in the best interest of the league that all teams compete for all weeks of the year, when a team does not submit a competitive line up (resets each year):
            <ol class="${"svelte-1dfigg0"}"><li>First Offense: Warning
                </li>
                <li>Second Offense: Loss of 25% of total FAAB budget for the following season
                </li>
                <li>Third Offense: Loss of 3rd round rookie pick (theirs, or other\u2019s they own) or the latest draft pick they own, otherwise.
                </li>
                <li>4th Offense: Removal from league
                </li></ol></li>
        <li>Noncompetitive means when an owner submits a lineup that includes:
            <ol class="${"svelte-1dfigg0"}"><li>Any player that is a Free Agent
                </li>
                <li>Any player that is Suspended
                </li>
                <li>Any player that is on Injured Reserve 
                </li>
                <li>A lineup with less than required starters
                </li>
                <li>Any player that is OUT for multiple weeks. 
                    <ul><li>If a player gets downgraded to out on the same day of the game, that is allowed. If it becomes a trend then it may be looked at as an issue.
                    </li></ul></li>
                <li>The intent to lose a matchup on purpose (automatically elevates to 2nd offense)
                </li></ol></li>
        <li>It would be nice to see all owners return year to year; however we know that things happen so if an owner should choose not to return, the commissioner will find a replacement GM using whatever means necessary to keep the league stable.
        </li>
        <li>If a team is abandoned mid-season, the commissioner will assume control of setting lineups for the team until a new GM can be found. While under control of the commissioner, this team will be barred from making trades, and any monetary winnings it may make will be put towards the dynasty pool. GM\u2019s taking over an orphaned team mid season are not expected to pay an additional buy in.
        </li>
        <li>When ownership of a franchise changes, the new owner will keep the same players held by the previous owner. The new GM will also keep the drafting position held by the previous owner.
        </li>
        <li>Some things that will not be tolerated at all are collusion, cheating and hacking. 
        </li>
        <li>All of these rules are set and any changes will require a vote for the next season only. Any GM can propose rules changes in the off-season. A \u2154 majority vote is required to make a rule change.
        </li>
        <li>Scoring is not subject to change, as it would cause changes of player values that owners would not have been expecting.
        </li></ol>
    

    <h3 class="${"subSectionHeading svelte-1dfigg0"}"${add_attribute("this", a_3, 0)}>A.3 Comissioner Responsibilities</h3>

    <ol class="${"svelte-1dfigg0"}"><li>Because of the inability to account for all possible scenarios, the commissioner will assume a governing position for the league.
        </li>
        <li>The commissioner is responsible for interpreting league rules, settling league disputes, and handling day-to-day operations.
        </li>
        <li>The commissioner reserves the right to protect the integrity of the league, especially in cases of clear collusion, cheating, or intentional sabotage of the league.
        </li>
        <li>If any situation arises that is not covered by these rules, the commissioner will use their discretion to determine the best course of action, and enforce whatever action is necessary to maintain fair, fun, and honest play.
        </li>
        <li>The commissioner will act in the best interest of the league at all times.
        </li></ol>

    <h3 class="${"subSectionHeading svelte-1dfigg0"}"${add_attribute("this", a_4, 0)}>A.4 General Manager Responsibilities</h3>

    <ol class="${"svelte-1dfigg0"}"><li>Each GM shall behave in a responsible manner that would not harm other owners or the league.
        </li>
        <li>It is the responsibility of each GM to refrain from participating in collusion or anti-competitive behavior.
        </li>
        <li>Each GM must keep their contact information updated with the commissioner and the rest of the league
        </li>
        <li>Each GM may only control one team in the league.
        </li>
        <li>Penalty for violating any GM responsibilities not outlined elsewhere in the ruleset
            <ol class="${"svelte-1dfigg0"}"><li>1st offense: Warning
                </li>
                <li>2nd offense or particularly severe incident: Loss of earliest owned rookie pick and forfeit the right to any prize winnings for the season.
                </li>
                <li>3rd offense or extremely severe incident: Removed from league and forfeit the right to the team and any prize winnings
                </li></ol></li></ol>


    <h2 class="${"sectionHeading svelte-1dfigg0"}"${add_attribute("this", b, 0)}>Section B: Roster, Draft &amp; Important Dates</h2>
    
    <h3 class="${"svelte-1dfigg0"}"${add_attribute("this", b_1, 0)}>B.1 Roster</h3>

    <ol class="${"svelte-1dfigg0"}"><li>30 Player In-Season Roster [Starters + Bench]
        </li>
        <li>No Taxi Squad, No IR
        </li>
        <li>10 Starters  [1 QB | 2 RB | 3 WR | 3 FLEX| 1 SUPERFLEX]
        </li>
        <li>35 Player Off-Season Roster
            <ol class="${"svelte-1dfigg0"}"><li>Roster Size Increased after Week 16
                </li>
                <li>Roster Size cut down back to 30 the Monday after Final Preseason Weekend l
                </li></ol></li>
        <li>No positional roster requirements/maximums
        </li></ol>

    <h3 class="${"svelte-1dfigg0"}"${add_attribute("this", b_2, 0)}>B.2 Inaugural Draft</h3>
    <ol class="${"svelte-1dfigg0"}"><li>The Inaugural Draft consists of 30 rounds, and includes both NFL veterans AND rookies that have been drafted or signed to rookie free agent contracts by NFL teams.
        </li>
        <li>The Inaugural draft must be scheduled to take place after the NFL rookie draft.
        </li>
        <li>3rd Round Reversal is in effect.
        </li>
        <li>Trading of later inaugural draft picks as well as future rookie draft picks is allowed.
        </li>
        <li>Draft order determined by 2k16 sim
        </li>
        <li>5 minute soft-cap timer per draft pick. Draft picks should be prompt but not stressful
        </li></ol>
    
    <h3 class="${"svelte-1dfigg0"}"${add_attribute("this", b_3, 0)}>B.3 Annual Rookie Draft</h3>
    <ol class="${"svelte-1dfigg0"}"><li>4 rounds
        </li>
        <li>Straight Format (i.e. 1-2-3, 1-2-3)
        </li>
        <li>Rookies and Free Agents are both available to be drafted.
        </li>
        <li>Rookie draft picks will be granted to all teams for the current and future seasons.
        </li>
        <li>Draft order is as follows
            <ul><li>Picks 1-6 are from lowest to highest max PF
                </li>
                <li>Picks 7-8 are from lowest to highest max PF for the 2 playoff teams that did not advance past the first round.
                </li>
                <li>Picks 9-12 are based on playoff finish, with the champion getting the last pick.
                </li></ul></li>
        <li>The draft order for picks 1-6 is determined by the \u201CPotential Points\u201D ranking (the highest possible points you could have gotten), which is to prevent tanking.
        </li>
        <li>The draft order for picks 1-6 is determined by the \u201CPotential Points\u201D ranking (the highest possible points you could have gotten), which is to prevent tanking.
        </li>
        <li>The rookie draft will be a long-running online draft, using the league software, starting on 1st Sunday of June at 12:00 PM EST. Owners are expected to plan around being available on this date and in the subsequent days / weeks to ensure an expeditious draft.
        </li>
        <li>GMs are allowed a 24 hour selection time limit. This time limit is for &quot;just in case&quot; scenarios and should not be abused. No one should continually hold up the draft or use the full allotted amount of time in a given round if they can help it.
        </li>
        <li>Teams that exceed their 24-hour selection time limit will have their pick skipped
        </li>
        <li>In such a scenario, it is the responsibility of the team GM to then contact the commissioners with the player they wish to select and said selection will be approved and processed if the player is still available
        </li>
        <li>If a GM misses two picks in a row, the draft will be stopped and the commissioner will try to contact the GM to discuss the situation.
        </li></ol>

    <h3 class="${"svelte-1dfigg0"}"${add_attribute("this", b_4, 0)}>B.4 Important Dates</h3>

    <ol class="${"svelte-1dfigg0"}"><li>Tuesday after Week 17  \u2013 Rule Changes Discussion Begins
        </li>
        <li>Tuesday after Week 17  \u2013 Free Agents are locked, Roster expanded to 35 players
        </li>
        <li>1st Sunday of June \u2013 Rookie Draft begins Annually, Dues must be paid
        </li>
        <li>After completion of Rookie Draft, auctions turned on
        </li>
        <li>Monday after Final Preseason Weekend \u2013 Roster cut to 30 players
        </li>
        <li>NFL Week 17 \u2013 Championship
        </li>
        <li>End of Week 17 \u2013 Rookie Draft order determined
        </li>
        <li>After NFL week 18 \u2013 Payouts are paid
        </li>
        <li>Weekly Event \u2013 Wednesday \u2013 3:15AM ET \u2013 Waivers Run
        </li></ol>
    
    <h2 class="${"sectionHeading svelte-1dfigg0"}"${add_attribute("this", c, 0)}>Section C: Divisions, Schedule &amp; Playoff Brackets</h2>

    <h3 class="${"svelte-1dfigg0"}"${add_attribute("this", c_1, 0)}>C.1 Divisions</h3>
        <ol class="${"svelte-1dfigg0"}"><li>3 divisions of 4 teams.
        </li>
        <li>Divisions are randomized each season with 1 team from each quartile from the previous season\u2019s finishes.
        </li></ol>

    <h3 class="${"svelte-1dfigg0"}"${add_attribute("this", c_2, 0)}>C.2 Regular Season Schedule</h3>
    <ol class="${"svelte-1dfigg0"}"><li>14 Weekly Match ups
        </li>
        <li>Each team will play the other 2 teams in their division twice and all other teams once.
        </li></ol>

    <h3 class="${"svelte-1dfigg0"}"${add_attribute("this", c_3, 0)}>C.3 Loser&#39;s Bracket</h3>
    <ol class="${"svelte-1dfigg0"}"><li>3 Round Playoff
        </li>
        <li>Remaining 6 teams qualify
        </li>
        <li>Single Elimination
        </li>
        <li>Draft order is already determined at this point
        </li>
        <li>Schedule (Seeding is based off pick placement)
            <ol class="${"svelte-1dfigg0"}"><li>Week 15: 6th &amp; 5th pick Receive BYE
                </li>
                <li>Week 15: 2nd vs 3rd | 1st vs 4th 
                </li>
                <li>Week 16: 1st vs. lowest remaining | 2nd vs. highest remaining
                </li>
                <li>Week 17; ROOKIE BOWL: Winner Receives 2nd Round rookie pick (2.13)
                </li></ol></li></ol>

    <h3 class="${"svelte-1dfigg0"}"${add_attribute("this", c_4, 0)}>C.4 Winner&#39;s Bracket</h3>
    <ol class="${"svelte-1dfigg0"}"><li>3 Round Playoff
        </li>
        <li>6 teams advance
        </li>
        <li>Single Elimination
        </li>
        <li>Seeding
            <ol class="${"svelte-1dfigg0"}"><li>First 3 seeds are division winners.
                </li>
                <li>4th and 5th seed determined by record first with applicable tiebreakers listed below.
                </li>
                <li>6th seed determined by points for, with applicable tiebreakers listed below.
                </li></ol></li>
        <li>Schedule
            <ol class="${"svelte-1dfigg0"}"><li>Week 15: 1st  &amp; 2nd seed Receive BYE
                </li>
                <li>Week 15: 5th vs 4th | 6th vs 3rd
                </li>
                <li>Week 16: 1st vs. lowest remaining | 2nd vs. highest remaining
                </li>
                <li>Week 17; CHAMPIONSHIP | 3rd place Matchup
                </li></ol></li></ol>
    
    <h2 class="${"sectionHeading svelte-1dfigg0"}"${add_attribute("this", d2, 0)}>Section D: Buy-In &amp; Pay Outs</h2>
    <ol class="${"svelte-1dfigg0"}"><li>Money is due 1 week prior to rookie draft at the latest.
        </li>
        <li>Offseason trades can\u2019t be made until dues are paid.
        </li>
        <li>Future assets cannot be traded until 50% of that year\u2019s buy in has been paid
        </li>
        <li>Commissioner will give a 24 hour warning for when payment will need to be made.
        </li>
        <li>Offending owners will lose their least valuable remaining pick if they still haven\u2019t paid after the warning.
        </li>
        <li>$20 each week goes to Highest Weekly Score (excluding Championship week 16) = $300
        </li>
        <li>$500 goes to the First Place Champion
        </li>
        <li>$200 goes to 2nd Place
        </li>
        <li>$100 goes to 3rd Place
        </li>

        <li>$100 goes in DYNASTY pool.
            <ol class="${"svelte-1dfigg0"}"><li>The DYNASTY pool is collected annually
                </li>
                <li>Will be awarded to the Franchise that wins \u2018back-to-back\u2019 Championships. 
                </li>
                <li>If the league is disbanded and there is money in the dynasty pool, it will be divided evenly amongst the GM\u2019s
                </li></ol></li></ol>

    <h2 class="${"sectionHeading svelte-1dfigg0"}"${add_attribute("this", e, 0)}>Section E: Waivers &amp; Free Agency</h2>
    
    <h3 class="${"svelte-1dfigg0"}"${add_attribute("this", e_1, 0)}>E.1 In-Season Waivers</h3>
    <ol class="${"svelte-1dfigg0"}"><li>Each team has a FAAB budget of $100
        </li>
        <li>Free agents will be processed by Sleeper\u2019s automated waiver window system. Waivers will be processed on Wednesday morning (3:15am ET), during the regular season starting at the completion of week one.
        </li>
        <li>Players not claimed by waivers will be available to be picked up for free until the start of their next game, or the first kickoff on Sunday if on Bye.
        </li>
        <li>There is no minimum bid and bids are done in increments of $1 (i.e. - no decimals).
        </li>
        <li>Once a player is dropped, he is locked until the next time waivers are processed.
        </li>
        <li>Waivers are available from the start of Week 1 until Wednesday on Week 16.
        </li></ol>

    <h3 class="${"svelte-1dfigg0"}"${add_attribute("this", e_2, 0)}>E.2 Off-Season Free Agency</h3>
    <ol class="${"svelte-1dfigg0"}"><li>Free Agency is locked from the conclusion of Week 16 until the Rookie draft.
        </li>
        <li>This is meant as a way to allow owners to unplug from Fantasy/NFL during the offseason for a time without a loss of competitive advantage.
        </li></ol>

    <h2 class="${"sectionHeading svelte-1dfigg0"}"${add_attribute("this", f, 0)}>Section F: Trading</h2>
    
    <h3 class="${"svelte-1dfigg0"}"${add_attribute("this", f_1, 0)}>F.1 General Rules</h3>
    <ol class="${"svelte-1dfigg0"}"><li>Trades are processed immediately when accepted
        </li>
        <li>There is no trade deadline, including into the playoffs.
        </li>
        <li>Trade proposals are valid for up to 7 days. Take your time.
        </li>
        <li>FAAB budget may be obtained via trade.
        </li>
        <li>No trades may be made that include real cash, future considerations, a player to be named later, or anything outside the realm of the fantasy league.
        </li>
        <li>From kickoff of Week 1 through the league championship, a traded player cannot be traded between the same two teams for at least four (4) weeks.
            <ul><li>If an owner observes a trade they suspect to be in violation of this rule, please report it to the commissioner.
            </li></ul></li></ol>
    
    <h3 class="${"svelte-1dfigg0"}"${add_attribute("this", f_2, 0)}>F.2 Conditional Trades</h3>
    <ol class="${"svelte-1dfigg0"}"><li>Commissioner must be made aware, with explicit approval from both parties on the conditional nature of the trade prior to it being executed.
        </li>
        <li>Commissioner may veto conditional nature of trades if deemed ambiguous.
        </li>
        <li>Assets included in conditional trades are locked up and may not be included in other trades.
        </li>
        <li>Examples
            <ul><li>Top 3 protected 2021 1st Rounder, Unprotected in 2022
                </li>
                <li>2nd round 2021 pick if player starts X games. 3rd round 2021 pick otherwise.
                </li></ul></li></ol>

    <h3 class="${"svelte-1dfigg0"}"${add_attribute("this", f_3, 0)}>F.3 Trade Vetoing</h3>
    <ol class="${"svelte-1dfigg0"}"><li>This league supports the spirit of \u201CTrades will not be vetoed, except in clear cases of collusion.\u201D However, for the integrity and longevity of the league, there must be a mechanism to handle \u2018league breaking\u2019 trades.
        </li><li>Commissioner reserves the right to deem a trade \u201Cleague breaking\u201D and reverse said trade.
        </li>
        <li>The term \u201Cleague breaking\u201D is an extremely high bar, and is not to be taken lightly.
        </li>
        <li>This mechanism isn\u2019t meant to handle trades where people have different player values and it isn\u2019t intended to impose the commissioner\u2019s player values on other people.
        </li></ol>

    <h3 class="${"svelte-1dfigg0"}"${add_attribute("this", f_4, 0)}>F.4 Trading Draft Picks</h3>
    <ol class="${"svelte-1dfigg0"}"><li>You are allowed to trade up to 1-3 years in advance draft picks
        </li><li>If a player decides to trade a future draft pick, 50% of that season\u2019s dues must be paid before doing so
        </li></ol>

    <h2 class="${"sectionHeading svelte-1dfigg0"}"${add_attribute("this", g, 0)}>Section G: Tie Breakers</h2>
    
    <h3 class="${"svelte-1dfigg0"}"${add_attribute("this", g_1, 0)}>G.1 General Tiebreakers</h3>
     <ol class="${"svelte-1dfigg0"}"><li>Head-to-Head Winning %
        </li><li>Division Winning %
        </li>
        <li>Total Points Scored
        </li>
        <li>Total Points Against
        </li>
        <li>Rap Battle
        </li></ol>
    
    <h3 class="${"svelte-1dfigg0"}"${add_attribute("this", g_2, 0)}>G.2 Waiver Bid Tie Breakers</h3>
    <ol class="${"svelte-1dfigg0"}"><li>Sleeper implements a rolling waiver priority for tiebreakers. You are moved to the bottom of the priority queue after every successful waiver claim.
        </li></ol>

  
    <h3 class="${"svelte-1dfigg0"}"${add_attribute("this", g_3, 0)}>G.3 Playoff Tiebreakers</h3>
   <ol class="${"svelte-1dfigg0"}"><li>QB Scoring
        </li>
        <li>Top RB + Top WR Combo Scoring
        </li>
        <li>Rap Battle
        </li></ol>

     <h2 class="${"sectionHeading svelte-1dfigg0"}"${add_attribute("this", h, 0)}>Section H: Lineups &amp; Scoring</h2>
    
    <h3 class="${"svelte-1dfigg0"}"${add_attribute("this", h_1, 0)}>H.1 Lineups</h3>
    <ol class="${"svelte-1dfigg0"}"><li>10 Starters  [1 QB | 2 RB | 3 WR | 3 FLEX| 1 SUPERFLEX]
        </li>
        <li>Conditional Lineup Requests
            <ol class="${"svelte-1dfigg0"}"><li>Owners may submit to the commissioner conditional lineup requests based on player availability and scheduling that makes fully informed decision making impossible.
                </li>
                <li>Owner\u2019s must specify their request prior to the start of either potential players\u2019 games, and with enough time for the commissioner to approve it before said games begin.
                </li>
                <li>The conditional nature is based solely on the availability of the given player or the occurrence of a game. The conditional nature cannot be based on the availability of any other player, and a player need only be available to be played - starting nor even playing a snap is required.
                </li>
                <li>Conditional lineup requests may be made in batch form i.e. setting multiple replacements, or replacements for any player of a position type. Examples include.
                    <ul><li>Start: Alvin Kamara\\n
                            Conditional: Latavius Murray
                        </li>
                        <li>Start: Chris Carson, Austin Ekeler\\n
                            Conditional: Ronald Jones
                        </li>
                        <li>Start: Julio Jones, Mike Evans, Keenan Allen\\n
                            Conditional: Brandin Cooks, Marvin Jones Jr
                        </li></ul></li></ol></li>
        <li>Trade proposals are valid for up to 7 days. Take your time.
        </li>
        <li>FAAB budget may be obtained via trade.
        </li>
        <li>No trades may be made that include real cash, future considerations, a player to be named later, or anything outside the realm of the fantasy league.
        </li>
        <li>From kickoff of Week 1 through the league championship, a traded player cannot be traded between the same two teams for at least four (4) weeks.
            <ul><li>If an owner observes a trade they suspect to be in violation of this rule, please report it to the commissioner.
            </li></ul></li></ol>
    
    <h3 class="${"svelte-1dfigg0"}"${add_attribute("this", h_2, 0)}>H.1 Scoring Settings</h3>
    <ol class="${"svelte-1dfigg0"}"><li>Number of Passing TDs [6 points each]
        </li><li>Passing Yards [.04 point for every 1]
        </li>
        <li>Completion [.2 points for each]
        </li>
        <li>Incompletions [-.4 for each]
        </li>
        <li>Interceptions Thrown [-4 for each]
        </li>
        <li>Passing 2 Pointers [2 points each]
        </li>
        <li>Number of Rushing TDs [6 points each]
        </li>
        <li>Rushing Yards [.1 point for every 1]
        </li>
        <li>Rushing 2 Pointers [2 points each]
        </li>
        <li>Number of Receiving TDs [6 points each]
        </li>
        <li>Receiving Yards [.1 point for every 1]
        </li>
        <li>First downs [1 point]
        </li>
        <li>Receptions [1 point, 2 points for TE]
        </li>
        <li>Receiving 2 Pointers [2 points each]
        </li>
        <li>Punt Return for Touchdown [6 points each]
        </li>
        <li>Kickoff Return for Touchdown [6 points each]
        </li>
        <li>Fumbles [-1 point]
        </li>
        <li>Fumbles lost [-1 point, total of -2]
        </li></ol></h2></div>`;
});
var index$a = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Constitution,
  prerender
});
var css$9 = {
  code: "#main.svelte-1mup0xu{position:relative;z-index:1;display:block;margin:30px auto;width:95%;max-width:1000px;overflow-y:hidden}.loading.svelte-1mup0xu{display:block;position:relative;z-index:1;width:85%;max-width:500px;margin:80px auto}",
  map: `{"version":3,"file":"index.svelte","sources":["index.svelte"],"sourcesContent":["<script context=\\"module\\">\\n\\timport { getLeagueTransactions, loadPlayers, waitForAll } from '$lib/utils/helper';\\n\\n    export async function load({ page }) {\\n        const show = page.query.get('show');\\n        const query = page.query.get('query');\\n        const curPage = page.query.get('page');\\n\\n        const transactionsData = getLeagueTransactions(false);\\n\\n        const playersData = loadPlayers();\\n\\n        const bannedValued = [\\n            'undefined',\\n        ]\\n\\n        const props = {\\n            show: \\"both\\",\\n            query: \\"\\",\\n            playersData,\\n            transactionsData,\\n            page: 0,\\n        }\\n        if(show && (show == \\"trade\\" || show == \\"waiver\\" || show == \\"both\\")) {\\n            props.show = show;\\n        }\\n        if(query && !bannedValued.includes(query)) {\\n            props.query = query;\\n        }\\n        if(curPage && !isNaN(curPage)) {\\n            props.page = parseInt(curPage) - 1;\\n        }\\n\\t\\treturn { props };\\n\\t}\\n    \\n\\tconst perPage = 10;\\n<\/script>\\n\\n<script>\\n\\timport LinearProgress from '@smui/linear-progress';\\n\\timport { TransactionsPage } from '$lib/components'\\n\\n    export let show, query, page, playersData, transactionsData;\\n\\n    let el, masterOffset;\\n\\n    const resize = (w) => {\\n        masterOffset = el?.getBoundingClientRect() ? el?.getBoundingClientRect().left  : 0;\\n    }\\n\\n    $: resize(innerWidth);\\n\\n    let innerWidth;\\n\\n<\/script>\\n\\n<svelte:window bind:innerWidth={innerWidth} />\\n\\n<style>\\n    #main {\\n        position: relative;\\n        z-index: 1;\\n        display: block;\\n        margin: 30px auto;\\n\\t\\twidth: 95%;\\n\\t\\tmax-width: 1000px;\\n        overflow-y: hidden;\\n    }\\n\\n\\t.loading {\\n\\t\\tdisplay: block;\\n\\t\\tposition: relative;\\n\\t\\tz-index: 1;\\n\\t\\twidth: 85%;\\n\\t\\tmax-width: 500px;\\n\\t\\tmargin: 80px auto;\\n\\t}\\n</style>\\n\\n<div id=\\"main\\" bind:this={el}>\\n\\n\\n    {#await waitForAll(transactionsData, playersData)}\\n        <div class=\\"loading\\" >\\n            <p>Loading league transactions...</p>\\n            <LinearProgress indeterminate />\\n        </div>\\n    {:then [{transactions, currentManagers, stale}, playersInfo]}\\n        <TransactionsPage {playersInfo} {stale} {transactions} {currentManagers} {masterOffset} {show} {query} queryPage={page} {perPage} postUpdate={true} />\\n    {:catch error}\\n        <p class=\\"center\\">Something went wrong: {error.message}</p>\\n    {/await}\\n</div>"],"names":[],"mappings":"AA2DI,KAAK,eAAC,CAAC,AACH,QAAQ,CAAE,QAAQ,CAClB,OAAO,CAAE,CAAC,CACV,OAAO,CAAE,KAAK,CACd,MAAM,CAAE,IAAI,CAAC,IAAI,CACvB,KAAK,CAAE,GAAG,CACV,SAAS,CAAE,MAAM,CACX,UAAU,CAAE,MAAM,AACtB,CAAC,AAEJ,QAAQ,eAAC,CAAC,AACT,OAAO,CAAE,KAAK,CACd,QAAQ,CAAE,QAAQ,CAClB,OAAO,CAAE,CAAC,CACV,KAAK,CAAE,GAAG,CACV,SAAS,CAAE,KAAK,CAChB,MAAM,CAAE,IAAI,CAAC,IAAI,AAClB,CAAC"}`
};
async function load$9({ page }) {
  const show = page.query.get("show");
  const query = page.query.get("query");
  const curPage = page.query.get("page");
  const transactionsData = getLeagueTransactions(false);
  const playersData = loadPlayers();
  const bannedValued = ["undefined"];
  const props = {
    show: "both",
    query: "",
    playersData,
    transactionsData,
    page: 0
  };
  if (show && (show == "trade" || show == "waiver" || show == "both")) {
    props.show = show;
  }
  if (query && !bannedValued.includes(query)) {
    props.query = query;
  }
  if (curPage && !isNaN(curPage)) {
    props.page = parseInt(curPage) - 1;
  }
  return { props };
}
var perPage = 10;
var Transactions = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let { show, query, page, playersData, transactionsData } = $$props;
  let el, masterOffset;
  const resize = (w) => {
    masterOffset = (el == null ? void 0 : el.getBoundingClientRect()) ? el == null ? void 0 : el.getBoundingClientRect().left : 0;
  };
  if ($$props.show === void 0 && $$bindings.show && show !== void 0)
    $$bindings.show(show);
  if ($$props.query === void 0 && $$bindings.query && query !== void 0)
    $$bindings.query(query);
  if ($$props.page === void 0 && $$bindings.page && page !== void 0)
    $$bindings.page(page);
  if ($$props.playersData === void 0 && $$bindings.playersData && playersData !== void 0)
    $$bindings.playersData(playersData);
  if ($$props.transactionsData === void 0 && $$bindings.transactionsData && transactionsData !== void 0)
    $$bindings.transactionsData(transactionsData);
  $$result.css.add(css$9);
  {
    resize();
  }
  return `



<div id="${"main"}" class="${"svelte-1mup0xu"}"${add_attribute("this", el, 0)}>${function(__value) {
    if (is_promise(__value)) {
      __value.then(null, noop);
      return `
        <div class="${"loading svelte-1mup0xu"}"><p>Loading league transactions...</p>
            ${validate_component(LinearProgress, "LinearProgress").$$render($$result, { indeterminate: true }, {}, {})}</div>
    `;
    }
    return function([{ transactions, currentManagers, stale }, playersInfo]) {
      return `
        ${validate_component(TransactionsPage, "TransactionsPage").$$render($$result, {
        playersInfo,
        stale,
        transactions,
        currentManagers,
        masterOffset,
        show,
        query,
        queryPage: page,
        perPage,
        postUpdate: true
      }, {}, {})}
    `;
    }(__value);
  }(waitForAll(transactionsData, playersData))}</div>`;
});
var index$9 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Transactions,
  load: load$9
});
var css$8 = {
  code: ".loading.svelte-6mz26e{position:relative;z-index:1;width:85%;margin:0 auto 60px;max-width:800px}",
  map: `{"version":3,"file":"index.svelte","sources":["index.svelte"],"sourcesContent":["<script context=\\"module\\">\\n\\timport { getNews } from '$lib/utils/helper';\\n\\n    export async function load() {\\n\\t\\tconst articlesData = getNews();\\n\\t\\n\\t\\treturn {\\n\\t\\t\\tprops: {\\n\\t\\t\\t\\tarticlesData\\n\\t\\t\\t}\\n\\t\\t};\\n\\t}\\n<\/script>\\n\\n\\n<script>\\n\\timport LinearProgress from '@smui/linear-progress';\\n\\timport { News, Resources } from '$lib/components';\\n\\n\\texport let articlesData;\\n<\/script>\\n\\n<style>\\n\\t.loading {\\n\\t\\tposition: relative;\\n\\t\\tz-index: 1;\\n        width: 85%;\\n        margin: 0 auto 60px;\\n        max-width: 800px;\\n    }\\n</style>\\n\\n<Resources />\\n\\n<hr />\\n\\n{#await articlesData}\\n\\t<div class=\\"loading\\">\\n\\t\\t<p>Retrieving fantasy news...</p>\\n\\t\\t<br />\\n\\t\\t<LinearProgress indeterminate />\\n\\t</div>\\n{:then news}\\n\\t<!-- promise was fulfilled -->\\n\\t<News {news}/>\\n{:catch error}\\n\\t<!-- promise was rejected -->\\n\\t<p>Something went wrong: {error.message}</p>\\n{/await}\\n"],"names":[],"mappings":"AAuBC,QAAQ,cAAC,CAAC,AACT,QAAQ,CAAE,QAAQ,CAClB,OAAO,CAAE,CAAC,CACJ,KAAK,CAAE,GAAG,CACV,MAAM,CAAE,CAAC,CAAC,IAAI,CAAC,IAAI,CACnB,SAAS,CAAE,KAAK,AACpB,CAAC"}`
};
async function load$8() {
  const articlesData = getNews();
  return { props: { articlesData } };
}
var Resources_1 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let { articlesData } = $$props;
  if ($$props.articlesData === void 0 && $$bindings.articlesData && articlesData !== void 0)
    $$bindings.articlesData(articlesData);
  $$result.css.add(css$8);
  return `${validate_component(Resources, "Resources").$$render($$result, {}, {}, {})}

<hr>

${function(__value) {
    if (is_promise(__value)) {
      __value.then(null, noop);
      return `
	<div class="${"loading svelte-6mz26e"}"><p>Retrieving fantasy news...</p>
		<br>
		${validate_component(LinearProgress, "LinearProgress").$$render($$result, { indeterminate: true }, {}, {})}</div>
`;
    }
    return function(news2) {
      return `
	
	${validate_component(News, "News").$$render($$result, { news: news2 }, {}, {})}
`;
    }(__value);
  }(articlesData)}`;
});
var index$8 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Resources_1,
  load: load$8
});
var css$7 = {
  code: ".holder.svelte-131ijax{position:relative;z-index:1;text-align:center}",
  map: `{"version":3,"file":"index.svelte","sources":["index.svelte"],"sourcesContent":["<script context=\\"module\\">\\n\\timport { getLeagueStandings, getLeagueUsers } from '$lib/utils/helper';\\n\\n    export async function load() {\\n\\n\\t\\tconst standingsData = getLeagueStandings();\\n\\t\\tconst usersData = getLeagueUsers();\\n\\t\\n\\t\\treturn {\\n\\t\\t\\tprops: {\\n\\t\\t\\t\\tstandingsData,\\n\\t\\t\\t\\tusersData,\\n\\t\\t\\t}\\n\\t\\t};\\n\\t}\\n<\/script>\\n\\n<script>\\n\\timport { Standings } from '$lib/components'\\n\\n\\texport let standingsData, usersData;\\n<\/script>\\n\\n<style>\\n\\t.holder {\\n\\t\\tposition: relative;\\n\\t\\tz-index: 1;\\n\\t\\ttext-align: center;\\n\\t}\\n</style>\\n\\n<div class=\\"holder\\">\\n\\t<Standings {standingsData} {usersData} />\\n</div>\\n"],"names":[],"mappings":"AAwBC,OAAO,eAAC,CAAC,AACR,QAAQ,CAAE,QAAQ,CAClB,OAAO,CAAE,CAAC,CACV,UAAU,CAAE,MAAM,AACnB,CAAC"}`
};
async function load$7() {
  const standingsData = getLeagueStandings();
  const usersData = getLeagueUsers();
  return { props: { standingsData, usersData } };
}
var Standings_1 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let { standingsData, usersData } = $$props;
  if ($$props.standingsData === void 0 && $$bindings.standingsData && standingsData !== void 0)
    $$bindings.standingsData(standingsData);
  if ($$props.usersData === void 0 && $$bindings.usersData && usersData !== void 0)
    $$bindings.usersData(usersData);
  $$result.css.add(css$7);
  return `<div class="${"holder svelte-131ijax"}">${validate_component(Standings, "Standings").$$render($$result, { standingsData, usersData }, {}, {})}</div>`;
});
var index$7 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Standings_1,
  load: load$7
});
var css$6 = {
  code: ".main.svelte-70pmkv{position:relative;z-index:1}.loading.svelte-70pmkv{display:block;width:85%;max-width:500px;margin:80px auto}",
  map: `{"version":3,"file":"index.svelte","sources":["index.svelte"],"sourcesContent":["<script context=\\"module\\">\\n    import {\\n        waitForAll,\\n        getLeagueRosters,\\n        getLeagueUsers,\\n        getLeagueData,\\n        getLeagueTransactions,\\n        getAwards,\\n        getLeagueRecords,\\n        managers as managersObj\\n    } from '$lib/utils/helper';\\n\\t\\n    export async function load({ page }) {\\n        if(!managersObj.length) return false;\\n        const managersInfo = waitForAll(\\n            getLeagueRosters(),    \\n            getLeagueUsers(),\\n            getLeagueData(),\\n            getLeagueTransactions(),\\n            getAwards(),\\n            getLeagueRecords(),\\n        );\\n\\n        const manager = page.query.get('manager');\\n\\n        const props = {\\n            manager: null,\\n            managers: managersObj,\\n            managersInfo\\n        }\\n        if(manager && (manager >= 0 && manager < managersObj.length)) {\\n            props.manager = manager;\\n        }\\n    \\n\\t\\treturn { props };\\n\\t}\\n<\/script>\\n\\n<script>\\n\\timport LinearProgress from '@smui/linear-progress';\\n\\timport { Managers } from '$lib/components';\\n\\n\\texport let managers, manager, managersInfo;\\n<\/script>\\n\\n<style>\\n\\t.main {\\n\\t\\tposition: relative;\\n\\t\\tz-index: 1;\\n\\t}\\n    .loading {\\n        display: block;\\n        width: 85%;\\n        max-width: 500px;\\n        margin: 80px auto;\\n    }\\n</style>\\n\\n<div class=\\"main\\">\\n    {#await managersInfo}\\n        <!-- promise is pending -->\\n        <div class=\\"loading\\">\\n            <p>Retrieving managers...</p>\\n            <LinearProgress indeterminate />\\n        </div>\\n    {:then [rostersData, users, leagueData, transactionsData, awards, records]}\\n        <Managers {managers} {manager} {rostersData} {users} {leagueData} {transactionsData} {awards} {records} /> <!-- displays managers -->\\n    {:catch error}\\n        <!-- promise was rejected -->\\n        <p>Something went wrong: {error.message}</p>\\n    {/await}\\n</div>"],"names":[],"mappings":"AA8CC,KAAK,cAAC,CAAC,AACN,QAAQ,CAAE,QAAQ,CAClB,OAAO,CAAE,CAAC,AACX,CAAC,AACE,QAAQ,cAAC,CAAC,AACN,OAAO,CAAE,KAAK,CACd,KAAK,CAAE,GAAG,CACV,SAAS,CAAE,KAAK,CAChB,MAAM,CAAE,IAAI,CAAC,IAAI,AACrB,CAAC"}`
};
async function load$6({ page }) {
  if (!managers.length)
    return false;
  const managersInfo = waitForAll(getLeagueRosters(), getLeagueUsers(), getLeagueData(), getLeagueTransactions(), getAwards(), getLeagueRecords());
  const manager = page.query.get("manager");
  const props = {
    manager: null,
    managers,
    managersInfo
  };
  if (manager && (manager >= 0 && manager < managers.length)) {
    props.manager = manager;
  }
  return { props };
}
var Managers_1 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let { managers: managers2, manager, managersInfo } = $$props;
  if ($$props.managers === void 0 && $$bindings.managers && managers2 !== void 0)
    $$bindings.managers(managers2);
  if ($$props.manager === void 0 && $$bindings.manager && manager !== void 0)
    $$bindings.manager(manager);
  if ($$props.managersInfo === void 0 && $$bindings.managersInfo && managersInfo !== void 0)
    $$bindings.managersInfo(managersInfo);
  $$result.css.add(css$6);
  return `<div class="${"main svelte-70pmkv"}">${function(__value) {
    if (is_promise(__value)) {
      __value.then(null, noop);
      return `
        
        <div class="${"loading svelte-70pmkv"}"><p>Retrieving managers...</p>
            ${validate_component(LinearProgress, "LinearProgress").$$render($$result, { indeterminate: true }, {}, {})}</div>
    `;
    }
    return function([rostersData, users2, leagueData2, transactionsData, awards2, records2]) {
      return `
        ${validate_component(Managers, "Managers").$$render($$result, {
        managers: managers2,
        manager,
        rostersData,
        users: users2,
        leagueData: leagueData2,
        transactionsData,
        awards: awards2,
        records: records2
      }, {}, {})} 
    `;
    }(__value);
  }(managersInfo)}</div>`;
});
var index$6 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Managers_1,
  load: load$6
});
var css$5 = {
  code: "#main.svelte-19dg7xs{position:relative;z-index:1}",
  map: `{"version":3,"file":"index.svelte","sources":["index.svelte"],"sourcesContent":["<script context=\\"module\\">\\n\\timport { getBrackets, getLeagueMatchups, loadPlayers } from '$lib/utils/helper';\\n    export async function load({ page }) {\\n        const queryWeek = page.query.get('week');\\n\\t\\treturn {\\n\\t\\t\\tprops: {\\n\\t\\t\\t\\tqueryWeek: isNaN(queryWeek) ? null : queryWeek,\\n\\t\\t\\t\\tmatchupsData: getLeagueMatchups(),\\n\\t\\t\\t\\tbracketsData: getBrackets(),\\n\\t\\t\\t\\tplayersData: loadPlayers(),\\n\\t\\t\\t}\\n\\t\\t};\\n\\t}\\n<\/script>\\n\\n<script>\\n\\timport { MatchupsAndBrackets } from '$lib/components';\\n\\n\\texport let queryWeek, matchupsData, bracketsData, playersData;\\n<\/script>\\n\\n<style>\\n    #main {\\n        position: relative;\\n        z-index: 1;\\n    }\\n</style>\\n\\n<div id=\\"main\\">\\n    <MatchupsAndBrackets {queryWeek} {matchupsData} {bracketsData} {playersData} />\\n</div>"],"names":[],"mappings":"AAsBI,KAAK,eAAC,CAAC,AACH,QAAQ,CAAE,QAAQ,CAClB,OAAO,CAAE,CAAC,AACd,CAAC"}`
};
async function load$5({ page }) {
  const queryWeek = page.query.get("week");
  return {
    props: {
      queryWeek: isNaN(queryWeek) ? null : queryWeek,
      matchupsData: getLeagueMatchups(),
      bracketsData: getBrackets(),
      playersData: loadPlayers()
    }
  };
}
var Matchups = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let { queryWeek, matchupsData, bracketsData, playersData } = $$props;
  if ($$props.queryWeek === void 0 && $$bindings.queryWeek && queryWeek !== void 0)
    $$bindings.queryWeek(queryWeek);
  if ($$props.matchupsData === void 0 && $$bindings.matchupsData && matchupsData !== void 0)
    $$bindings.matchupsData(matchupsData);
  if ($$props.bracketsData === void 0 && $$bindings.bracketsData && bracketsData !== void 0)
    $$bindings.bracketsData(bracketsData);
  if ($$props.playersData === void 0 && $$bindings.playersData && playersData !== void 0)
    $$bindings.playersData(playersData);
  $$result.css.add(css$5);
  return `<div id="${"main"}" class="${"svelte-19dg7xs"}">${validate_component(MatchupsAndBrackets, "MatchupsAndBrackets").$$render($$result, {
    queryWeek,
    matchupsData,
    bracketsData,
    playersData
  }, {}, {})}</div>`;
});
var index$5 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Matchups,
  load: load$5
});
var css$4 = {
  code: "#main.svelte-1k46pdo{position:relative;z-index:1}.loading.svelte-1k46pdo{display:block;width:85%;max-width:500px;margin:80px auto}",
  map: `{"version":3,"file":"index.svelte","sources":["index.svelte"],"sourcesContent":["<script context=\\"module\\">\\n\\timport { getLeagueRecords, getLeagueTransactions, waitForAll } from '$lib/utils/helper';\\n\\n    export async function load() {\\n        const recordsInfo = waitForAll(\\n\\t\\t\\tgetLeagueRecords(false),\\n\\t\\t\\tgetLeagueTransactions(false),\\n\\t\\t)\\n\\t\\n\\t\\treturn {\\n\\t\\t\\tprops: {\\n\\t\\t\\t\\trecordsInfo\\n\\t\\t\\t}\\n\\t\\t};\\n\\t}\\n<\/script>\\n\\n<script>\\n\\timport LinearProgress from '@smui/linear-progress';\\n\\timport { Records } from '$lib/components';\\n\\n    export let recordsInfo;\\n<\/script>\\n\\n<style>\\n    #main {\\n        position: relative;\\n        z-index: 1;\\n    }\\n    .loading {\\n        display: block;\\n        width: 85%;\\n        max-width: 500px;\\n        margin: 80px auto;\\n    }\\n</style>\\n\\n<div id=\\"main\\">\\n    {#await recordsInfo}\\n        <!-- promise is pending -->\\n        <div class=\\"loading\\">\\n            <p>Loading league records...</p>\\n            <LinearProgress indeterminate />\\n        </div>\\n    {:then [leagueRecords, {totals, stale}]}\\n        <Records {leagueRecords} {totals} {stale} />\\n    {:catch error}\\n        <!-- promise was rejected -->\\n        <p>Something went wrong: {error.message}</p>\\n    {/await}\\n</div>\\n"],"names":[],"mappings":"AAyBI,KAAK,eAAC,CAAC,AACH,QAAQ,CAAE,QAAQ,CAClB,OAAO,CAAE,CAAC,AACd,CAAC,AACD,QAAQ,eAAC,CAAC,AACN,OAAO,CAAE,KAAK,CACd,KAAK,CAAE,GAAG,CACV,SAAS,CAAE,KAAK,CAChB,MAAM,CAAE,IAAI,CAAC,IAAI,AACrB,CAAC"}`
};
async function load$4() {
  const recordsInfo = waitForAll(getLeagueRecords(false), getLeagueTransactions(false));
  return { props: { recordsInfo } };
}
var Records_1 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let { recordsInfo } = $$props;
  if ($$props.recordsInfo === void 0 && $$bindings.recordsInfo && recordsInfo !== void 0)
    $$bindings.recordsInfo(recordsInfo);
  $$result.css.add(css$4);
  return `<div id="${"main"}" class="${"svelte-1k46pdo"}">${function(__value) {
    if (is_promise(__value)) {
      __value.then(null, noop);
      return `
        
        <div class="${"loading svelte-1k46pdo"}"><p>Loading league records...</p>
            ${validate_component(LinearProgress, "LinearProgress").$$render($$result, { indeterminate: true }, {}, {})}</div>
    `;
    }
    return function([leagueRecords, { totals, stale }]) {
      return `
        ${validate_component(Records, "Records").$$render($$result, { leagueRecords, totals, stale }, {}, {})}
    `;
    }(__value);
  }(recordsInfo)}</div>`;
});
var index$4 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Records_1,
  load: load$4
});
var css$3 = {
  code: ".holder.svelte-1swuelu{position:relative;z-index:1}.loading.svelte-1swuelu{display:block;width:85%;max-width:500px;margin:80px auto}",
  map: `{"version":3,"file":"index.svelte","sources":["index.svelte"],"sourcesContent":["<script context=\\"module\\">\\n\\timport { getLeagueData, getLeagueRosters, getLeagueUsers, loadPlayers, waitForAll } from '$lib/utils/helper';\\n\\n    export async function load() {\\n        const rostersInfo = waitForAll(\\n\\t\\t\\tgetLeagueData(),\\n\\t\\t\\tgetLeagueRosters(),\\n\\t\\t\\tgetLeagueUsers(),\\n\\t\\t\\tloadPlayers(),\\n\\t\\t)\\n\\t\\n\\t\\treturn {\\n\\t\\t\\tprops: {\\n\\t\\t\\t\\trostersInfo\\n\\t\\t\\t}\\n\\t\\t};\\n\\t}\\n<\/script>\\n\\n<script>\\n\\timport LinearProgress from '@smui/linear-progress';\\n\\timport { Rosters } from '$lib/components'\\n\\n\\texport let rostersInfo;\\n<\/script>\\n\\n<style>\\n\\t.holder {\\n\\t\\tposition: relative;\\n\\t\\tz-index: 1;\\n\\t}\\n\\t.loading {\\n\\t\\tdisplay: block;\\n\\t\\twidth: 85%;\\n\\t\\tmax-width: 500px;\\n\\t\\tmargin: 80px auto;\\n\\t}\\n</style>\\n\\n<div class=\\"holder\\">\\n\\t{#await rostersInfo}\\n\\t\\t<div class=\\"loading\\">\\n\\t\\t\\t<p>Retrieving roster data...</p>\\n\\t\\t\\t<br />\\n\\t\\t\\t<LinearProgress indeterminate />\\n\\t\\t</div>\\n\\t{:then [leagueData, rosterData, users, playersInfo]}\\n\\t\\t<!-- promise was fulfilled -->\\n\\t\\t<Rosters {leagueData} {rosterData} {users} {playersInfo} /> <!-- displays rosters -->\\n\\t{:catch error}\\n\\t\\t<!-- promise was rejected -->\\n\\t\\t<p>Something went wrong: {error.message}</p>\\n\\t{/await}\\n</div>\\n"],"names":[],"mappings":"AA2BC,OAAO,eAAC,CAAC,AACR,QAAQ,CAAE,QAAQ,CAClB,OAAO,CAAE,CAAC,AACX,CAAC,AACD,QAAQ,eAAC,CAAC,AACT,OAAO,CAAE,KAAK,CACd,KAAK,CAAE,GAAG,CACV,SAAS,CAAE,KAAK,CAChB,MAAM,CAAE,IAAI,CAAC,IAAI,AAClB,CAAC"}`
};
async function load$3() {
  const rostersInfo = waitForAll(getLeagueData(), getLeagueRosters(), getLeagueUsers(), loadPlayers());
  return { props: { rostersInfo } };
}
var Rosters_1 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let { rostersInfo } = $$props;
  if ($$props.rostersInfo === void 0 && $$bindings.rostersInfo && rostersInfo !== void 0)
    $$bindings.rostersInfo(rostersInfo);
  $$result.css.add(css$3);
  return `<div class="${"holder svelte-1swuelu"}">${function(__value) {
    if (is_promise(__value)) {
      __value.then(null, noop);
      return `
		<div class="${"loading svelte-1swuelu"}"><p>Retrieving roster data...</p>
			<br>
			${validate_component(LinearProgress, "LinearProgress").$$render($$result, { indeterminate: true }, {}, {})}</div>
	`;
    }
    return function([leagueData2, rosterData, users2, playersInfo]) {
      return `
		
		${validate_component(Rosters, "Rosters").$$render($$result, {
        leagueData: leagueData2,
        rosterData,
        users: users2,
        playersInfo
      }, {}, {})} 
	`;
    }(__value);
  }(rostersInfo)}</div>`;
});
var index$3 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Rosters_1,
  load: load$3
});
var css$2 = {
  code: ".awards.svelte-ocifrf{display:block;margin:30px auto;width:95%;max-width:1000px;position:relative;z-index:1;overflow-y:hidden}.loading.svelte-ocifrf{display:block;width:85%;max-width:500px;margin:80px auto}.nothingYet.svelte-ocifrf{display:block;width:85%;max-width:500px;margin:80px auto;text-align:center}",
  map: `{"version":3,"file":"index.svelte","sources":["index.svelte"],"sourcesContent":["<script context=\\"module\\">\\n\\timport { getAwards } from '$lib/utils/helper';\\n\\n    export async function load() {\\n        const awardsData = getAwards();\\n\\t\\n\\t\\treturn {\\n\\t\\t\\tprops: {\\n\\t\\t\\t\\tawardsData,\\n\\t\\t\\t}\\n\\t\\t};\\n\\t}\\n<\/script>\\n\\n<script>\\n\\timport { Awards } from '$lib/components'\\n\\timport LinearProgress from '@smui/linear-progress';\\n\\n    export let awardsData;\\n<\/script>\\n\\n<style>\\n    .awards {\\n        display: block;\\n        margin: 30px auto;\\n\\t\\twidth: 95%;\\n\\t\\tmax-width: 1000px;\\n\\t\\tposition: relative;\\n\\t\\tz-index: 1;\\n\\t\\toverflow-y: hidden;\\n    }\\n\\n\\t.loading {\\n\\t\\tdisplay: block;\\n\\t\\twidth: 85%;\\n\\t\\tmax-width: 500px;\\n\\t\\tmargin: 80px auto;\\n\\t}\\n\\n\\t.nothingYet {\\n\\t\\tdisplay: block;\\n\\t\\twidth: 85%;\\n\\t\\tmax-width: 500px;\\n\\t\\tmargin: 80px auto;\\n\\t\\ttext-align: center;\\n\\t}\\n</style>\\n\\n<div class=\\"awards\\">\\n\\t{#await awardsData }\\n\\t\\t<div class=\\"loading\\">\\n\\t\\t\\t<p>Retrieving awards data...</p>\\n\\t\\t\\t<LinearProgress indeterminate />\\n\\t\\t</div>\\n\\t{:then {podiums, currentManagers} }\\n\\t\\t{#each podiums as podium}\\n\\t\\t\\t<Awards {podium} {currentManagers} />\\n\\t\\t{:else}\\n\\t\\t\\t<p class=\\"nothingYet\\">No seasons have been completed yet, so no awards have been earned...</p>\\n\\t\\t{/each}\\n\\t{:catch error}\\n\\t\\t<!-- promise was rejected -->\\n\\t\\t<p>Something went wrong: {error.message}</p>\\n\\t{/await}\\n</div>"],"names":[],"mappings":"AAsBI,OAAO,cAAC,CAAC,AACL,OAAO,CAAE,KAAK,CACd,MAAM,CAAE,IAAI,CAAC,IAAI,CACvB,KAAK,CAAE,GAAG,CACV,SAAS,CAAE,MAAM,CACjB,QAAQ,CAAE,QAAQ,CAClB,OAAO,CAAE,CAAC,CACV,UAAU,CAAE,MAAM,AAChB,CAAC,AAEJ,QAAQ,cAAC,CAAC,AACT,OAAO,CAAE,KAAK,CACd,KAAK,CAAE,GAAG,CACV,SAAS,CAAE,KAAK,CAChB,MAAM,CAAE,IAAI,CAAC,IAAI,AAClB,CAAC,AAED,WAAW,cAAC,CAAC,AACZ,OAAO,CAAE,KAAK,CACd,KAAK,CAAE,GAAG,CACV,SAAS,CAAE,KAAK,CAChB,MAAM,CAAE,IAAI,CAAC,IAAI,CACjB,UAAU,CAAE,MAAM,AACnB,CAAC"}`
};
async function load$2() {
  const awardsData = getAwards();
  return { props: { awardsData } };
}
var Awards_1 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let { awardsData } = $$props;
  if ($$props.awardsData === void 0 && $$bindings.awardsData && awardsData !== void 0)
    $$bindings.awardsData(awardsData);
  $$result.css.add(css$2);
  return `<div class="${"awards svelte-ocifrf"}">${function(__value) {
    if (is_promise(__value)) {
      __value.then(null, noop);
      return `
		<div class="${"loading svelte-ocifrf"}"><p>Retrieving awards data...</p>
			${validate_component(LinearProgress, "LinearProgress").$$render($$result, { indeterminate: true }, {}, {})}</div>
	`;
    }
    return function({ podiums, currentManagers }) {
      return `
		${podiums.length ? each(podiums, (podium) => `${validate_component(Awards, "Awards").$$render($$result, { podium, currentManagers }, {}, {})}`) : `<p class="${"nothingYet svelte-ocifrf"}">No seasons have been completed yet, so no awards have been earned...</p>`}
	`;
    }(__value);
  }(awardsData)}</div>`;
});
var index$2 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Awards_1,
  load: load$2
});
var css$1 = {
  code: "#main.svelte-19dg7xs{position:relative;z-index:1}",
  map: `{"version":3,"file":"index.svelte","sources":["index.svelte"],"sourcesContent":["<script context=\\"module\\">\\n\\timport { getUpcomingDraft, getPreviousDrafts } from '$lib/utils/helper';\\n\\n    export async function load() {\\n        const upcomingDraftData = getUpcomingDraft();\\n        const previousDraftsData = getPreviousDrafts();\\n\\t\\n\\t\\treturn {\\n\\t\\t\\tprops: {\\n\\t\\t\\t\\tupcomingDraftData,\\n                previousDraftsData\\n\\t\\t\\t}\\n\\t\\t};\\n\\t}\\n<\/script>\\n\\n<script>\\n\\timport { Drafts } from '$lib/components';\\n\\n    export let upcomingDraftData, previousDraftsData;\\n<\/script>\\n\\n<style>\\n    #main {\\n        position: relative;\\n        z-index: 1;\\n    }\\n</style>\\n\\n<div id=\\"main\\">\\n\\t<Drafts {upcomingDraftData} {previousDraftsData} />\\n</div>"],"names":[],"mappings":"AAuBI,KAAK,eAAC,CAAC,AACH,QAAQ,CAAE,QAAQ,CAClB,OAAO,CAAE,CAAC,AACd,CAAC"}`
};
async function load$1() {
  const upcomingDraftData = getUpcomingDraft();
  const previousDraftsData = getPreviousDrafts();
  return {
    props: { upcomingDraftData, previousDraftsData }
  };
}
var Drafts_1 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let { upcomingDraftData, previousDraftsData } = $$props;
  if ($$props.upcomingDraftData === void 0 && $$bindings.upcomingDraftData && upcomingDraftData !== void 0)
    $$bindings.upcomingDraftData(upcomingDraftData);
  if ($$props.previousDraftsData === void 0 && $$bindings.previousDraftsData && previousDraftsData !== void 0)
    $$bindings.previousDraftsData(previousDraftsData);
  $$result.css.add(css$1);
  return `<div id="${"main"}" class="${"svelte-19dg7xs"}">${validate_component(Drafts, "Drafts").$$render($$result, { upcomingDraftData, previousDraftsData }, {}, {})}</div>`;
});
var index$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Drafts_1,
  load: load$1
});
var css = {
  code: "#main.svelte-v5y0of{position:relative;z-index:1;display:block;margin:30px auto;width:95%;max-width:1000px;overflow-y:hidden}",
  map: `{"version":3,"file":"index.svelte","sources":["index.svelte"],"sourcesContent":["<script context=\\"module\\">\\n\\timport { enableBlog, getBlogPosts, getLeagueRosters, getLeagueUsers } from '$lib/utils/helper';\\n\\n    export function load({ page }) {\\n        if(!enableBlog) return false;\\n        const queryPage = page.query.get('page') || 1;\\n        const filterKey = page.query.get('filter') || '';\\n\\t\\tconst postsData = getBlogPosts();\\n\\t\\tconst usersData = getLeagueUsers();\\n\\t\\tconst rostersData = getLeagueRosters();\\n\\t\\n\\t\\treturn {\\n\\t\\t\\tprops: {\\n                queryPage,\\n\\t\\t\\t\\tpostsData,\\n                filterKey,\\n                usersData,\\n                rostersData,\\n\\t\\t\\t}\\n\\t\\t};\\n\\t}\\n<\/script>\\n\\n<script>\\n    import { Posts } from \\"$lib/components\\";\\n\\n    export let postsData, queryPage, filterKey, usersData, rostersData;\\n<\/script>\\n\\n<style>\\n    #main {\\n        position: relative;\\n        z-index: 1;\\n        display: block;\\n        margin: 30px auto;\\n\\t\\twidth: 95%;\\n\\t\\tmax-width: 1000px;\\n        overflow-y: hidden;\\n    }\\n</style>\\n\\n<div id=\\"main\\">\\n    <Posts {rostersData} {postsData} {queryPage} {filterKey} {usersData} />\\n</div>"],"names":[],"mappings":"AA8BI,KAAK,cAAC,CAAC,AACH,QAAQ,CAAE,QAAQ,CAClB,OAAO,CAAE,CAAC,CACV,OAAO,CAAE,KAAK,CACd,MAAM,CAAE,IAAI,CAAC,IAAI,CACvB,KAAK,CAAE,GAAG,CACV,SAAS,CAAE,MAAM,CACX,UAAU,CAAE,MAAM,AACtB,CAAC"}`
};
function load({ page }) {
  return false;
}
var Blog = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let { postsData, queryPage, filterKey, usersData, rostersData } = $$props;
  if ($$props.postsData === void 0 && $$bindings.postsData && postsData !== void 0)
    $$bindings.postsData(postsData);
  if ($$props.queryPage === void 0 && $$bindings.queryPage && queryPage !== void 0)
    $$bindings.queryPage(queryPage);
  if ($$props.filterKey === void 0 && $$bindings.filterKey && filterKey !== void 0)
    $$bindings.filterKey(filterKey);
  if ($$props.usersData === void 0 && $$bindings.usersData && usersData !== void 0)
    $$bindings.usersData(usersData);
  if ($$props.rostersData === void 0 && $$bindings.rostersData && rostersData !== void 0)
    $$bindings.rostersData(rostersData);
  $$result.css.add(css);
  return `<div id="${"main"}" class="${"svelte-v5y0of"}">${validate_component(Posts, "Posts").$$render($$result, {
    rostersData,
    postsData,
    queryPage,
    filterKey,
    usersData
  }, {}, {})}</div>`;
});
var index = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Blog,
  load
});

// .svelte-kit/vercel/entry.js
init();
var entry_default = async (req, res) => {
  const { pathname, searchParams } = new URL(req.url || "", "http://localhost");
  let body;
  try {
    body = await getRawBody(req);
  } catch (err) {
    res.statusCode = err.status || 400;
    return res.end(err.reason || "Invalid request body");
  }
  const rendered = await render({
    method: req.method,
    headers: req.headers,
    path: pathname,
    query: searchParams,
    rawBody: body
  });
  if (rendered) {
    const { status, headers, body: body2 } = rendered;
    return res.writeHead(status, headers).end(body2);
  }
  return res.writeHead(404).end();
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {});
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/**
 * @license
 * Copyright 2019 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
